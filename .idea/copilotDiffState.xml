<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Archive&#10;  type: http&#10;  seq: 15&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/archive/cancel/:tracker-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  tracker-id: archive123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Upload&#10;  type: http&#10;  seq: 6&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/cancel/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Copy Files&#10;  type: http&#10;  seq: 7&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/copy&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Create New Entry&#10;  type: http&#10;  seq: 11&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/new&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;path&quot;: &quot;new-folder&quot;,&#10;    &quot;is_directory&quot;: true&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Delete Files&#10;  type: http&#10;  seq: 10&#10;}&#10;&#10;delete {&#10;  url: {{baseurl}}/server/:server-id/fs/&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;paths&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;, &quot;file2.txt&quot;]&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id:&#10;}" />
              <option name="updatedContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?filepath&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath:&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?path=&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  path: &#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Move Files&#10;  type: http&#10;  seq: 8&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/move&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Rename File&#10;  type: http&#10;  seq: 9&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/rename&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;source&quot;: &quot;oldfile.txt&quot;,&#10;    &quot;destination&quot;: &quot;newfile.txt&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Search Files&#10;  type: http&#10;  seq: 12&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/search?q=config&amp;filename_only=false&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  q: config&#10;  filename_only: false&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru" />
              <option name="originalContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?filepath=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath: example.txt&#10;&#10;params:path {&#10;  server-id: &#10;  server-id:&#10;&#10;body:text {&#10;  This is the content of the uploaded file.&#10;}&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?upload_id=upload123&amp;path=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  upload_id: upload123&#10;  path: example.txt&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:text {&#10;  This is the content of the uploaded file.&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Upload Progress&#10;  type: http&#10;  seq: 5&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/progress/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Cargo.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Cargo.toml" />
              <option name="originalContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;obsidian-upnp = { git = &quot;https://github.com/Obsidian-Minecraft-Server-Portal/upnp.git&quot; }&#10;&#10;[build-dependencies]&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;" />
              <option name="updatedContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;tar = &quot;0.4.44&quot;&#10;obsidian-upnp = { git = &quot;https://github.com/Obsidian-Minecraft-Server-Portal/upnp.git&quot; }&#10;&#10;[build-dependencies]&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src-actix/server/filesystem/extract_wrapper.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src-actix/server/filesystem/extract_wrapper.rs" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="use actix_web_lab::sse;&#10;use actix_web_lab::sse::Event;&#10;use anyhow::Result;&#10;use log::{debug, error, info, trace, warn};&#10;use std::fs;&#10;use std::io::{BufReader, Read, Write};&#10;use std::path::{Path, PathBuf};&#10;use std::sync::atomic::{AtomicBool, Ordering};&#10;use tokio::sync::mpsc::Sender;&#10;&#10;pub async fn extract(&#10;    archive_path: impl AsRef&lt;Path&gt;,&#10;    output_path: impl AsRef&lt;Path&gt;,&#10;    sender: &amp;Sender&lt;Event&gt;,&#10;    cancelled: &amp;AtomicBool,&#10;) -&gt; Result&lt;()&gt; {&#10;    let archive_path = archive_path.as_ref();&#10;    let output_path = output_path.as_ref();&#10;&#10;    info!(&quot;Starting extraction of {} to {}&quot;, archive_path.display(), output_path.display());&#10;&#10;    // Create output directory if it doesn't exist&#10;    std::fs::create_dir_all(output_path)?;&#10;&#10;    // Determine archive type by extension&#10;    let extension = archive_path&#10;        .extension()&#10;        .and_then(|ext| ext.to_str())&#10;        .unwrap_or(&quot;&quot;);&#10;&#10;    match extension.to_lowercase().as_str() {&#10;        &quot;zip&quot; =&gt; extract_zip(archive_path, output_path, sender, cancelled).await,&#10;        &quot;gz&quot; | &quot;tgz&quot; =&gt; {&#10;            // Check if it's a tar.gz file&#10;            let stem = archive_path.file_stem().and_then(|s| s.to_str()).unwrap_or(&quot;&quot;);&#10;            if stem.ends_with(&quot;.tar&quot;) || extension == &quot;tgz&quot; {&#10;                extract_tar_gz(archive_path, output_path, sender, cancelled).await&#10;            } else {&#10;                Err(anyhow::anyhow!(&quot;Unsupported archive format: {}&quot;, extension))&#10;            }&#10;        }&#10;        _ =&gt; Err(anyhow::anyhow!(&quot;Unsupported archive format: {}&quot;, extension)),&#10;    }&#10;}&#10;&#10;async fn extract_zip(&#10;    archive_path: &amp;Path,&#10;    output_path: &amp;Path,&#10;    sender: &amp;Sender&lt;Event&gt;,&#10;    cancelled: &amp;AtomicBool,&#10;) -&gt; Result&lt;()&gt; {&#10;    info!(&quot;Extracting ZIP archive: {}&quot;, archive_path.display());&#10;&#10;    let file = fs::File::open(archive_path)?;&#10;    let mut archive = zip::ZipArchive::new(file)?;&#10;&#10;    let total_files = archive.len();&#10;    let mut processed_files = 0u64;&#10;    let mut processed_bytes = 0u64;&#10;    let mut total_bytes = 0u64;&#10;&#10;    // Calculate total uncompressed size&#10;    for i in 0..archive.len() {&#10;        if let Ok(file) = archive.by_index(i) {&#10;            total_bytes += file.size();&#10;        }&#10;    }&#10;&#10;    info!(&quot;ZIP archive contains {} files, {} total bytes&quot;, total_files, total_bytes);&#10;&#10;    // Send initial progress&#10;    let _ = sender.send(Event::from(sse::Data::new(format!(&#10;        &quot;{{ \&quot;progress\&quot;: 0.0, \&quot;status\&quot;: \&quot;extracting\&quot;, \&quot;filesProcessed\&quot;: 0, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;        total_files&#10;    )))).await;&#10;&#10;    let mut last_progress_update = std::time::Instant::now();&#10;&#10;    for i in 0..archive.len() {&#10;        // Check if operation was cancelled&#10;        if cancelled.load(Ordering::Relaxed) {&#10;            info!(&quot;Extract operation cancelled by user&quot;);&#10;            let _ = sender.send(Event::from(sse::Data::new(&quot;{ \&quot;progress\&quot;: 0, \&quot;status\&quot;: \&quot;cancelled\&quot; }&quot;))).await;&#10;            return Ok(());&#10;        }&#10;&#10;        let mut file = archive.by_index(i)?;&#10;        let file_path = output_path.join(file.mangled_name());&#10;&#10;        debug!(&quot;Extracting: {} -&gt; {}&quot;, file.name(), file_path.display());&#10;&#10;        if file.name().ends_with('/') {&#10;            // Directory&#10;            std::fs::create_dir_all(&amp;file_path)?;&#10;            trace!(&quot;Created directory: {}&quot;, file_path.display());&#10;        } else {&#10;            // File&#10;            if let Some(parent) = file_path.parent() {&#10;                std::fs::create_dir_all(parent)?;&#10;            }&#10;&#10;            let mut output_file = fs::File::create(&amp;file_path)?;&#10;            let mut buffer = [0; 4096];&#10;&#10;            loop {&#10;                // Check cancellation during file extraction&#10;                if cancelled.load(Ordering::Relaxed) {&#10;                    info!(&quot;Extract operation cancelled by user while extracting {}&quot;, file.name());&#10;                    let _ = sender.send(Event::from(sse::Data::new(&quot;{ \&quot;progress\&quot;: 0, \&quot;status\&quot;: \&quot;cancelled\&quot; }&quot;))).await;&#10;                    return Ok(());&#10;                }&#10;&#10;                let bytes_read = match file.read(&amp;mut buffer) {&#10;                    Ok(0) =&gt; break, // EOF&#10;                    Ok(n) =&gt; n,&#10;                    Err(e) =&gt; {&#10;                        error!(&quot;Error reading from archive file {}: {}&quot;, file.name(), e);&#10;                        return Err(anyhow::anyhow!(&quot;Error reading archive: {}&quot;, e));&#10;                    }&#10;                };&#10;&#10;                output_file.write_all(&amp;buffer[..bytes_read])?;&#10;                processed_bytes += bytes_read as u64;&#10;&#10;                // Send progress update with rate limiting&#10;                let now = std::time::Instant::now();&#10;                if now.duration_since(last_progress_update).as_millis() &gt; 100 {&#10;                    let progress = if total_bytes &gt; 0 {&#10;                        (processed_bytes as f32 / total_bytes as f32) * 100.0&#10;                    } else {&#10;                        (processed_files as f32 / total_files as f32) * 100.0&#10;                    };&#10;&#10;                    let _ = sender.send(Event::from(sse::Data::new(format!(&#10;                        &quot;{{ \&quot;progress\&quot;: {:.1}, \&quot;status\&quot;: \&quot;extracting\&quot;, \&quot;filesProcessed\&quot;: {}, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;                        progress, processed_files, total_files&#10;                    )))).await;&#10;&#10;                    debug!(&quot;Progress update: {:.1}% ({}/{})&quot;, progress, processed_files, total_files);&#10;                    last_progress_update = now;&#10;                }&#10;            }&#10;&#10;            trace!(&quot;Extracted file: {}&quot;, file_path.display());&#10;        }&#10;&#10;        processed_files += 1;&#10;    }&#10;&#10;    // Send completion&#10;    let _ = sender.send(Event::from(sse::Data::new(format!(&#10;        &quot;{{ \&quot;progress\&quot;: 100.0, \&quot;status\&quot;: \&quot;complete\&quot;, \&quot;filesProcessed\&quot;: {}, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;        processed_files, total_files&#10;    )))).await;&#10;&#10;    info!(&quot;ZIP extraction completed successfully&quot;);&#10;    Ok(())&#10;}&#10;&#10;async fn extract_tar_gz(&#10;    archive_path: &amp;Path,&#10;    output_path: &amp;Path,&#10;    sender: &amp;Sender&lt;Event&gt;,&#10;    cancelled: &amp;AtomicBool,&#10;) -&gt; Result&lt;()&gt; {&#10;    info!(&quot;Extracting TAR.GZ archive: {}&quot;, archive_path.display());&#10;    &#10;    // First pass: count entries&#10;    let file = fs::File::open(archive_path)?;&#10;    let decoder = flate2::read::GzDecoder::new(file);&#10;    let mut archive = tar::Archive::new(decoder);&#10;    &#10;    let total_files = archive.entries()?.count();&#10;    info!(&quot;TAR.GZ archive contains {} entries&quot;, total_files);&#10;    &#10;    // Send initial progress&#10;    let _ = sender.send(Event::from(sse::Data::new(format!(&#10;        &quot;{{ \&quot;progress\&quot;: 0.0, \&quot;status\&quot;: \&quot;extracting\&quot;, \&quot;filesProcessed\&quot;: 0, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;        total_files&#10;    )))).await;&#10;    &#10;    let mut last_progress_update = std::time::Instant::now();&#10;    let mut processed_files = 0u64;&#10;    &#10;    // Second pass: extract files&#10;    let file = fs::File::open(archive_path)?;&#10;    let decoder = flate2::read::GzDecoder::new(file);&#10;    let mut archive = tar::Archive::new(decoder);&#10;    &#10;    for entry_result in archive.entries()? {&#10;        // Check if operation was cancelled before processing each entry&#10;        if cancelled.load(Ordering::Relaxed) {&#10;            info!(&quot;Extract operation cancelled by user&quot;);&#10;            let _ = sender.send(Event::from(sse::Data::new(&quot;{ \&quot;progress\&quot;: 0, \&quot;status\&quot;: \&quot;cancelled\&quot; }&quot;))).await;&#10;            return Ok(());&#10;        }&#10;        &#10;        let mut entry = entry_result?;&#10;        let entry_path = entry.path()?;&#10;        let output_file_path = output_path.join(&amp;entry_path);&#10;        &#10;        debug!(&quot;Extracting: {} -&gt; {}&quot;, entry_path.display(), output_file_path.display());&#10;        &#10;        // Extract the entry&#10;        entry.unpack(&amp;output_file_path)?;&#10;        trace!(&quot;Extracted: {}&quot;, output_file_path.display());&#10;        &#10;        processed_files += 1;&#10;        &#10;        // Send progress update with rate limiting&#10;        let now = std::time::Instant::now();&#10;        if now.duration_since(last_progress_update).as_millis() &gt; 100 {&#10;            let progress = (processed_files as f32 / total_files as f32) * 100.0;&#10;            &#10;            let _ = sender.send(Event::from(sse::Data::new(format!(&#10;                &quot;{{ \&quot;progress\&quot;: {:.1}, \&quot;status\&quot;: \&quot;extracting\&quot;, \&quot;filesProcessed\&quot;: {}, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;                progress, processed_files, total_files&#10;            )))).await;&#10;            &#10;            debug!(&quot;Progress update: {:.1}% ({}/{})&quot;, progress, processed_files, total_files);&#10;            last_progress_update = now;&#10;        }&#10;    }&#10;    &#10;    // Send completion&#10;    let _ = sender.send(Event::from(sse::Data::new(format!(&#10;        &quot;{{ \&quot;progress\&quot;: 100.0, \&quot;status\&quot;: \&quot;complete\&quot;, \&quot;filesProcessed\&quot;: {}, \&quot;totalFiles\&quot;: {} }}&quot;,&#10;        processed_files, total_files&#10;    )))).await;&#10;    &#10;    info!(&quot;TAR.GZ extraction completed successfully&quot;);&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src-actix/server/filesystem/filesystem_endpoint.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src-actix/server/filesystem/filesystem_endpoint.rs" />
              <option name="originalContent" value="use crate::actix_util::http_error::Result;&#10;use crate::server::filesystem::filesystem_data::FilesystemData;&#10;use crate::server::server_data::ServerData;&#10;use actix_web::{HttpMessage, HttpRequest, HttpResponse, Responder, delete, get, post, web};&#10;use serde_hash::hashids::decode_single;&#10;use serde_json::json;&#10;use std::collections::HashMap;&#10;use std::sync::Arc;&#10;use std::sync::OnceLock;&#10;use std::sync::atomic::{AtomicBool, Ordering};&#10;use tokio::sync::Mutex;&#10;&#10;use crate::server::filesystem::download_parameters::DownloadParameters;&#10;use actix_web::http::header::{ContentDisposition, ContentType};&#10;use actix_web::test::default_service;&#10;use actix_web_lab::sse::Sse;&#10;use actix_web_lab::sse::{Data, Event};&#10;use anyhow::anyhow;&#10;use futures::{StreamExt, TryStreamExt};&#10;use log::{debug, error, warn};&#10;use serde::Deserialize;&#10;use std::ffi::OsStr;&#10;use std::io::ErrorKind;&#10;use std::path::PathBuf;&#10;use std::time::Duration;&#10;use tokio::fs::File;&#10;use tokio::io::AsyncWriteExt;&#10;use tokio::io::duplex;&#10;use tokio::sync::mpsc::Sender;&#10;use tokio_util::io::ReaderStream;&#10;&#10;// Global state for tracking operations&#10;type FileProcessTracker = Arc&lt;Mutex&lt;HashMap&lt;String, Sender&lt;Event&gt;&gt;&gt;&gt;;&#10;type UploadCancelFlags = Arc&lt;Mutex&lt;HashMap&lt;String, Arc&lt;AtomicBool&gt;&gt;&gt;&gt;;&#10;type ArchiveCancelFlags = Arc&lt;Mutex&lt;HashMap&lt;String, Arc&lt;AtomicBool&gt;&gt;&gt;&gt;;&#10;&#10;static UPLOAD_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static ARCHIVE_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static EXTRACT_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static UPLOAD_CANCEL_FLAGS: OnceLock&lt;UploadCancelFlags&gt; = OnceLock::new();&#10;static ARCHIVE_CANCEL_FLAGS: OnceLock&lt;ArchiveCancelFlags&gt; = OnceLock::new();&#10;&#10;fn get_upload_trackers() -&gt; &amp;'static FileProcessTracker {&#10;    UPLOAD_TRACKERS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_archive_trackers() -&gt; &amp;'static FileProcessTracker {&#10;    ARCHIVE_TRACKERS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_archive_cancel_flags() -&gt; &amp;'static ArchiveCancelFlags {&#10;    ARCHIVE_CANCEL_FLAGS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_upload_cancel_flags() -&gt; &amp;'static UploadCancelFlags {&#10;    UPLOAD_CANCEL_FLAGS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;// Request/Response structures&#10;#[derive(Deserialize)]&#10;struct CopyMoveRequest {&#10;    entries: Vec&lt;String&gt;,&#10;    path: String,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct RenameRequest {&#10;    source: String,&#10;    destination: String,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct DeleteRequest {&#10;    paths: Vec&lt;String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct NewEntryRequest {&#10;    path: String,&#10;    is_directory: bool,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct ArchiveRequest {&#10;    entries: Vec&lt;String&gt;,&#10;    cwd: String,&#10;    filename: String,&#10;    tracker_id: String,&#10;}&#10;&#10;#[get(&quot;/files&quot;)]&#10;pub async fn get_files(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;    let path = query.get(&quot;path&quot;).unwrap_or(&amp;String::from(&quot;&quot;)).to_string();&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let server_directory = server.get_directory_path();&#10;    let directory = server.get_directory_path().join(&amp;path);&#10;    if !directory.exists() {&#10;        return Err(anyhow::anyhow!(&quot;Directory not found&quot;).into());&#10;    }&#10;&#10;    let mut entries: FilesystemData = directory.try_into()?;&#10;    entries.entries = entries&#10;        .entries&#10;        .into_iter()&#10;        .map(|mut entry| {&#10;            entry.path = entry.path.trim_start_matches(server_directory.as_os_str().to_string_lossy().to_string().as_str()).to_string();&#10;            entry&#10;        })&#10;        .collect();&#10;&#10;    Ok(HttpResponse::Ok().json(entries))&#10;}&#10;&#10;#[post(&quot;/upload&quot;)]&#10;pub async fn upload_file(&#10;    server_id: web::Path&lt;String&gt;,&#10;    query: web::Query&lt;HashMap&lt;String, String&gt;&gt;,&#10;    mut payload: web::Payload,&#10;    req: HttpRequest,&#10;) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // Extract upload ID and file path from query parameters&#10;    let upload_id = query.get(&quot;upload_id&quot;).ok_or(anyhow::anyhow!(&quot;upload_id parameter is required&quot;))?.clone();&#10;    let file_path = query.get(&quot;path&quot;).ok_or(anyhow::anyhow!(&quot;path parameter is required&quot;))?.clone();&#10;    // trim leading slashes from file path&#10;    let file_path = file_path.trim_start_matches('/').trim_start_matches('\\').to_string();&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let full_path = server.get_directory_path().join(&amp;file_path);&#10;    let directory = full_path.parent().ok_or(anyhow::anyhow!(&quot;Invalid file path&quot;))?;&#10;    std::fs::create_dir_all(directory)?;&#10;&#10;    // Get the progress sender for this upload&#10;    let progress_sender = {&#10;        let trackers = get_upload_trackers().lock().await;&#10;        trackers.get(&amp;upload_id).cloned()&#10;    };&#10;&#10;    // Create a cancellation flag for this upload&#10;    let cancel_flag = Arc::new(AtomicBool::new(false));&#10;    {&#10;        let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;        cancel_flags.insert(upload_id.clone(), cancel_flag.clone());&#10;    }&#10;&#10;    let mut file = match File::create(&amp;full_path).await {&#10;        Ok(file) =&gt; file,&#10;        Err(_) =&gt; {&#10;            // Clean up the cancellation flag&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;            return Err(anyhow::anyhow!(&quot;Failed to create file&quot;).into());&#10;        }&#10;    };&#10;&#10;    let mut total_bytes = 0u64;&#10;&#10;    // Process the upload&#10;    while let Some(chunk) = payload.next().await {&#10;        // Check if upload was cancelled&#10;        if cancel_flag.load(Ordering::Relaxed) {&#10;            // Send cancellation event&#10;            if let Some(sender) = &amp;progress_sender {&#10;                let _ = sender&#10;                    .send(Event::from(Data::new(&#10;                        json!({&#10;                            &quot;status&quot;: &quot;cancelled&quot;,&#10;                            &quot;bytesUploaded&quot;: total_bytes&#10;                        })&#10;                        .to_string(),&#10;                    )))&#10;                    .await;&#10;            }&#10;&#10;            // Clean up&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;&#10;            // Close and delete the partial file&#10;            file.shutdown().await.ok();&#10;            tokio::fs::remove_file(&amp;full_path).await.ok();&#10;&#10;            return Ok(HttpResponse::Ok().json(json!({&#10;                &quot;status&quot;: &quot;cancelled&quot;,&#10;                &quot;message&quot;: &quot;Upload cancelled by user&quot;&#10;            })));&#10;        }&#10;&#10;        let bytes = match chunk {&#10;            Ok(bytes) =&gt; bytes,&#10;            Err(_) =&gt; {&#10;                // Clean up the cancellation flag&#10;                let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;                cancel_flags.remove(&amp;upload_id);&#10;                return Err(anyhow::anyhow!(&quot;Failed to read upload data&quot;).into());&#10;            }&#10;        };&#10;&#10;        if file.write_all(&amp;bytes).await.is_err() {&#10;            // Clean up the cancellation flag&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;            return Err(anyhow::anyhow!(&quot;Failed to write file&quot;).into());&#10;        }&#10;&#10;        total_bytes += bytes.len() as u64;&#10;&#10;        // Send progress update if we have a sender&#10;        if let Some(sender) = &amp;progress_sender {&#10;            let _ = sender&#10;                .send(Event::from(Data::new(&#10;                    json!({&#10;                        &quot;status&quot;: &quot;progress&quot;,&#10;                        &quot;bytesUploaded&quot;: total_bytes&#10;                    })&#10;                    .to_string(),&#10;                )))&#10;                .await;&#10;        }&#10;    }&#10;&#10;    // Send completion event&#10;    if let Some(sender) = &amp;progress_sender {&#10;        let _ = sender&#10;            .send(Event::from(Data::new(&#10;                json!({&#10;                    &quot;status&quot;: &quot;complete&quot;,&#10;                    &quot;bytesUploaded&quot;: total_bytes&#10;                })&#10;                .to_string(),&#10;            )))&#10;            .await;&#10;    }&#10;&#10;    // Clean up the cancellation flag&#10;    let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;    cancel_flags.remove(&amp;upload_id);&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&#10;        &quot;status&quot;: &quot;complete&quot;,&#10;        &quot;bytesUploaded&quot;: total_bytes&#10;    })))&#10;}&#10;&#10;#[get(&quot;/upload/progress/{upload_id}&quot;)]&#10;pub async fn upload_progress(params: web::Path&lt;(String, String)&gt;) -&gt; impl Responder {&#10;    let (_, upload_id) = params.into_inner();&#10;    let (tx, rx) = tokio::sync::mpsc::channel(100);&#10;&#10;    // Store the sender in our tracker&#10;    {&#10;        let mut trackers = get_upload_trackers().lock().await;&#10;        trackers.insert(upload_id.to_string(), tx);&#10;    }&#10;&#10;    Sse::from_infallible_receiver(rx).with_keep_alive(Duration::from_secs(3))&#10;}&#10;&#10;#[post(&quot;/upload/cancel/{upload_id}&quot;)]&#10;pub async fn cancel_upload(upload_id: web::Path&lt;String&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    let upload_id = upload_id.into_inner();&#10;&#10;    // Get the cancellation flag for this upload&#10;    let cancel_flags = get_upload_cancel_flags().lock().await;&#10;&#10;    if let Some(flag) = cancel_flags.get(&amp;upload_id) {&#10;        // Set the flag to true to signal cancellation&#10;        flag.store(true, Ordering::Relaxed);&#10;&#10;        Ok(HttpResponse::Ok().json(json!({&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;message&quot;: &quot;Upload operation cancelled&quot;&#10;        })))&#10;    } else {&#10;        // If the tracker doesn't exist, it might have already completed or never existed&#10;        Ok(HttpResponse::NotFound().json(json!({&#10;            &quot;status&quot;: &quot;error&quot;,&#10;            &quot;message&quot;: &quot;Upload operation not found or already completed&quot;&#10;        })))&#10;    }&#10;}&#10;&#10;#[get(&quot;/upload-url&quot;)]&#10;pub async fn upload_url(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let (sender, receiver) = tokio::sync::mpsc::channel(1);&#10;    let filepath = query.get(&quot;filepath&quot;).unwrap_or(&amp;String::from(&quot;&quot;)).to_string();&#10;    let url = query.get(&quot;url&quot;).ok_or(anyhow::anyhow!(&quot;URL parameter is required&quot;))?.clone();&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let filepath = server.get_directory_path().join(filepath);&#10;    let directory = filepath.parent().ok_or(anyhow::anyhow!(&quot;Invalid file path&quot;))?;&#10;    std::fs::create_dir_all(directory)?;&#10;    tokio::spawn(async move {&#10;        let resp = match reqwest::get(&amp;url).await {&#10;            Ok(r) =&gt; r,&#10;            Err(e) =&gt; {&#10;                error!(&quot;Failed to download file: {}&quot;, e);&#10;                let data = json!({&quot;error&quot;: format!(&quot;Failed to download file: {}&quot;, e)});&#10;                if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                    let message = Data::new(json).event(&quot;error&quot;);&#10;                    let _ = sender.send(message.into()).await;&#10;                }&#10;                return;&#10;            }&#10;        };&#10;        let total_size = resp.content_length().unwrap_or(0);&#10;        let mut downloaded: u64 = 0;&#10;        let mut body = Vec::new();&#10;&#10;        let mut stream = resp.bytes_stream();&#10;        while let Some(chunk) = match stream.try_next().await {&#10;            Ok(c) =&gt; c,&#10;            Err(e) =&gt; {&#10;                error!(&quot;Failed to read chunk: {}&quot;, e);&#10;                let data = json!({&quot;error&quot;: format!(&quot;Failed to read chunk: {}&quot;, e)});&#10;                if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                    let message = Data::new(json).event(&quot;error&quot;);&#10;                    let _ = sender.send(message.into()).await;&#10;                }&#10;                return;&#10;            }&#10;        } {&#10;            body.extend_from_slice(&amp;chunk);&#10;            downloaded += chunk.len() as u64;&#10;            if total_size &gt; 0 {&#10;                debug!(&quot;Download progress: {} - {}%&quot;, url, ((downloaded as f32) / total_size as f32) * 100f32);&#10;                let data = json!({&#10;                    &quot;progress&quot;: (downloaded as f32) / total_size as f32,&#10;                    &quot;downloaded&quot;: downloaded,&#10;                    &quot;total&quot;: total_size,&#10;                });&#10;                let message = Data::new(match serde_json::to_string(&amp;data) {&#10;                    Ok(s) =&gt; s,&#10;                    Err(e) =&gt; {&#10;                        error!(&quot;Failed to serialize progress data: {}&quot;, e);&#10;                        let data = json!({&quot;error&quot;: format!(&quot;Failed to serialize progress data: {}&quot;, e)});&#10;                        if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                            let message = Data::new(json).event(&quot;error&quot;);&#10;                            let _ = sender.send(message.into()).await;&#10;                        }&#10;                        return;&#10;                    }&#10;                })&#10;                .event(&quot;progress&quot;);&#10;                if let Err(e) = sender.send(message.into()).await {&#10;                    error!(&quot;Failed to send progress message: {}&quot;, e);&#10;                    let data = json!({&quot;error&quot;: format!(&quot;Failed to send progress message: {}&quot;, e)});&#10;                    if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                        let message = Data::new(json).event(&quot;error&quot;);&#10;                        let _ = sender.send(message.into()).await;&#10;                    }&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if let Err(e) = tokio::fs::write(filepath, body).await {&#10;            error!(&quot;Failed to write file: {}&quot;, e);&#10;            let data = json!({&quot;error&quot;: format!(&quot;Failed to write file: {}&quot;, e)});&#10;            if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                let message = Data::new(json).event(&quot;error&quot;);&#10;                let _ = sender.send(message.into()).await;&#10;            };&#10;        }&#10;&#10;        sender.try_send(Data::new_json(json!({&quot;message&quot;: &quot;File uploaded!&quot;})).unwrap().event(&quot;complete&quot;).into()).unwrap();&#10;    });&#10;&#10;    Ok(Sse::from_infallible_receiver(receiver).with_keep_alive(Duration::from_secs(10)))&#10;}&#10;&#10;#[get(&quot;/download&quot;)]&#10;async fn download(server_id: web::Path&lt;String&gt;, req: HttpRequest, query: web::Query&lt;DownloadParameters&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    use archflow::compress::FileOptions;&#10;    use archflow::compress::tokio::archive::ZipArchive;&#10;    use archflow::compression::CompressionMethod;&#10;    use archflow::error::ArchiveError;&#10;    use archflow::types::FileDateTime;&#10;&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let server_directory = server.get_directory_path();&#10;    let items: Vec&lt;PathBuf&gt; = query.items.iter().map(|item| server_directory.join(item.trim_start_matches(&quot;\\&quot;).trim_start_matches(&quot;/&quot;))).collect();&#10;&#10;    let is_single_entry = items.len() == 1;&#10;    let is_single_entry_directory = is_single_entry &amp;&amp; items[0].is_dir();&#10;&#10;    let filename: String = if is_single_entry {&#10;        let guid = uuid::Uuid::new_v4().to_string();&#10;        let name = items[0].file_name().unwrap_or(OsStr::new(&amp;guid)).to_string_lossy().into_owned();&#10;        if is_single_entry_directory { format!(&quot;{}.zip&quot;, name) } else { name.to_string() }&#10;    } else {&#10;        format!(&quot;{}.zip&quot;, uuid::Uuid::new_v4())&#10;    };&#10;&#10;    // If there is only one entry, and it's a file,&#10;    // then stream the individual file to the client.&#10;    if is_single_entry &amp;&amp; !is_single_entry_directory {&#10;        let filepath = items[0].clone();&#10;        debug!(&quot;Downloading single file: {}&quot;, filepath.display());&#10;&#10;        let file = File::open(&amp;filepath).await.map_err(|_| anyhow!(&quot;Failed to open file for download: {}&quot;, filepath.display()))?;&#10;        let stream = ReaderStream::new(file);&#10;&#10;        return Ok(HttpResponse::Ok()&#10;            .content_type(&quot;application/octet-stream&quot;)&#10;            .insert_header(ContentDisposition::attachment(filename))&#10;            .streaming(stream));&#10;    }&#10;&#10;    debug!(&quot;Downloading multiple files: {:?}&quot;, items);&#10;&#10;    // For directories or multiple files, create a zip archive&#10;    let (w, r) = duplex(4096);&#10;    let items = items.clone();&#10;&#10;    tokio::spawn(async move {&#10;        let mut archive = ZipArchive::new_streamable(w);&#10;        let options = FileOptions::default().last_modified_time(FileDateTime::Now).compression_method(CompressionMethod::Store());&#10;&#10;        // Collect all files paths to put in the zip&#10;        let items_to_write = if is_single_entry_directory {&#10;            match tokio::fs::read_dir(items[0].clone()).await {&#10;                Ok(mut dir) =&gt; {&#10;                    let mut paths = Vec::new();&#10;                    while let Ok(Some(entry)) = dir.next_entry().await {&#10;                        paths.push(entry.path());&#10;                    }&#10;                    paths&#10;                }&#10;                Err(_) =&gt; items,&#10;            }&#10;        } else {&#10;            items&#10;        };&#10;&#10;        for item in items_to_write {&#10;            if let Some(filename) = item.file_name() {&#10;                let filename = filename.to_string_lossy().into_owned();&#10;                if item.is_dir() {&#10;                    // Process directory&#10;                    let walker = walkdir::WalkDir::new(&amp;item);&#10;                    if let Err(e) = archive.append_directory(filename.as_str(), &amp;options).await {&#10;                        error!(&quot;Failed to add directory to zip archive: {}&quot;, e);&#10;                        continue;&#10;                    }&#10;&#10;                    for entry in walker.into_iter().flatten() {&#10;                        let path = entry.path();&#10;                        let relative_path = path.strip_prefix(&amp;server_directory).unwrap_or(path);&#10;&#10;                        if path.is_dir() {&#10;                            debug!(&quot;Adding directory to zip archive: {} -&gt; {}&quot;, path.display(), relative_path.display());&#10;                            if let Err(e) = archive.append_directory(relative_path.to_string_lossy().replace('\\', &quot;/&quot;).as_ref(), &amp;options).await {&#10;                                error!(&quot;Failed to add directory to zip archive: {}&quot;, e);&#10;                                continue;&#10;                            }&#10;                            continue; // Directories are automatically created when adding files&#10;                        }&#10;&#10;                        debug!(&quot;Adding file to zip archive: {} -&gt; {}&quot;, path.display(), relative_path.display());&#10;                        if let Ok(mut file) = File::open(path).await {&#10;                            let _ = archive.append(relative_path.to_string_lossy().replace('\\', &quot;/&quot;).as_ref(), &amp;options, &amp;mut file).await;&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Process a single file&#10;                    debug!(&quot;Adding file to zip archive: {} -&gt; {}&quot;, item.display(), filename);&#10;                    if let Ok(mut file) = File::open(&amp;item).await {&#10;                        if let Err(e) = archive.append(filename.as_str(), &amp;options, &amp;mut file).await {&#10;                            if matches!(&amp;e, ArchiveError::IoError(err) if err.kind() == ErrorKind::BrokenPipe) {&#10;                                warn!(&quot;Zip archive stream closed, this is most-likely due to the client closing the connection.&quot;);&#10;                                break;&#10;                            }&#10;                            error!(&quot;Failed to add file to zip archive: {}&quot;, e);&#10;                            continue;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        let _ = archive.finalize().await;&#10;    });&#10;&#10;    Ok(HttpResponse::Ok().content_type(&quot;application/zip&quot;).insert_header(ContentDisposition::attachment(filename)).streaming(ReaderStream::new(r)))&#10;}&#10;&#10;#[post(&quot;/copy&quot;)]&#10;pub async fn copy_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;CopyMoveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for entry_path in &amp;body.entries {&#10;        let source = base_path.join(entry_path);&#10;        let dest = base_path.join(&amp;body.path).join(source.file_name().ok_or(anyhow::anyhow!(&quot;Invalid source path&quot;))?);&#10;&#10;        if source.is_dir() {&#10;            copy_dir_all(&amp;source, &amp;dest)?;&#10;        } else {&#10;            if let Some(parent) = dest.parent() {&#10;                std::fs::create_dir_all(parent)?;&#10;            }&#10;            std::fs::copy(&amp;source, &amp;dest)?;&#10;        }&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;fn copy_dir_all(src: &amp;std::path::Path, dst: &amp;std::path::Path) -&gt; std::io::Result&lt;()&gt; {&#10;    std::fs::create_dir_all(dst)?;&#10;    for entry in std::fs::read_dir(src)? {&#10;        let entry = entry?;&#10;        let ty = entry.file_type()?;&#10;        if ty.is_dir() {&#10;            copy_dir_all(&amp;entry.path(), &amp;dst.join(entry.file_name()))?;&#10;        } else {&#10;            std::fs::copy(entry.path(), dst.join(entry.file_name()))?;&#10;        }&#10;    }&#10;    Ok(())&#10;}&#10;&#10;#[post(&quot;/move&quot;)]&#10;pub async fn move_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;CopyMoveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for entry_path in &amp;body.entries {&#10;        let source = base_path.join(entry_path);&#10;        let dest = base_path.join(&amp;body.path).join(source.file_name().ok_or(anyhow::anyhow!(&quot;Invalid source path&quot;))?);&#10;&#10;        if let Some(parent) = dest.parent() {&#10;            std::fs::create_dir_all(parent)?;&#10;        }&#10;        std::fs::rename(&amp;source, &amp;dest)?;&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/rename&quot;)]&#10;pub async fn rename_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;RenameRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    let source = base_path.join(&amp;body.source);&#10;    let dest = base_path.join(&amp;body.destination);&#10;&#10;    if let Some(parent) = dest.parent() {&#10;        std::fs::create_dir_all(parent)?;&#10;    }&#10;    std::fs::rename(&amp;source, &amp;dest)?;&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[delete(&quot;/&quot;)]&#10;pub async fn delete_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;DeleteRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for path in &amp;body.paths {&#10;        let full_path = base_path.join(path);&#10;        if full_path.is_dir() {&#10;            std::fs::remove_dir_all(&amp;full_path)?;&#10;        } else {&#10;            std::fs::remove_file(&amp;full_path)?;&#10;        }&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/new&quot;)]&#10;pub async fn create_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;NewEntryRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let full_path = base_path.join(&amp;body.path);&#10;&#10;    if body.is_directory {&#10;        std::fs::create_dir_all(&amp;full_path)?;&#10;    } else {&#10;        if let Some(parent) = full_path.parent() {&#10;            std::fs::create_dir_all(parent)?;&#10;        }&#10;        std::fs::File::create(&amp;full_path)?;&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[get(&quot;/search&quot;)]&#10;pub async fn search(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let search_query = query.get(&quot;q&quot;).ok_or(anyhow::anyhow!(&quot;Search query parameter 'q' is required&quot;))?.clone();&#10;    let filename_only = query.get(&quot;filename_only&quot;).unwrap_or(&amp;&quot;false&quot;.to_string()) == &quot;true&quot;;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    let mut results = Vec::new();&#10;    search_directory(&amp;base_path, &amp;search_query, filename_only, &amp;mut results)?;&#10;&#10;    Ok(HttpResponse::Ok().json(results))&#10;}&#10;&#10;fn search_directory(dir: &amp;std::path::Path, query: &amp;str, filename_only: bool, results: &amp;mut Vec&lt;serde_json::Value&gt;) -&gt; std::io::Result&lt;()&gt; {&#10;    for entry in std::fs::read_dir(dir)? {&#10;        let entry = entry?;&#10;        let path = entry.path();&#10;        let filename = entry.file_name().to_string_lossy().to_lowercase();&#10;&#10;        let matches = if filename_only {&#10;            filename.contains(&amp;query.to_lowercase())&#10;        } else {&#10;            filename.contains(&amp;query.to_lowercase()) || path.to_string_lossy().to_lowercase().contains(&amp;query.to_lowercase())&#10;        };&#10;&#10;        if matches {&#10;            let metadata = path.metadata()?;&#10;            results.push(json!({&#10;                &quot;filename&quot;: entry.file_name().to_string_lossy(),&#10;                &quot;path&quot;: path.to_string_lossy(),&#10;                &quot;size&quot;: metadata.len(),&#10;                &quot;ctime&quot;: metadata.created().ok().and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok()).map(|d| d.as_secs()).unwrap_or(0),&#10;                &quot;mtime&quot;: metadata.modified().ok().and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok()).map(|d| d.as_secs()).unwrap_or(0),&#10;            }));&#10;        }&#10;&#10;        if path.is_dir() {&#10;            search_directory(&amp;path, query, filename_only, results)?;&#10;        }&#10;    }&#10;    Ok(())&#10;}&#10;&#10;#[post(&quot;/archive&quot;)]&#10;pub async fn archive_files(server_id: web::Path&lt;String&gt;, body: web::Json&lt;ArchiveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let cwd = base_path.join(&amp;body.cwd);&#10;    let archive_path = cwd.join(&amp;body.filename);&#10;&#10;    let trackers = get_archive_trackers().lock().await;&#10;    if let Some(tracker) = trackers.get(&amp;body.tracker_id) {&#10;        // Create a new cancellation flag for this operation&#10;        let cancel_flag = Arc::new(AtomicBool::new(false));&#10;&#10;        // Store the cancellation flag&#10;        {&#10;            let mut cancel_flags = get_archive_cancel_flags().lock().await;&#10;            cancel_flags.insert(body.tracker_id.clone(), cancel_flag.clone());&#10;        }&#10;&#10;        let absolute_file_paths: Vec&lt;PathBuf&gt; = body.entries.iter().map(|entry| cwd.join(entry)).collect();&#10;&#10;        // Use the archive_wrapper to create the archive&#10;        crate::server::filesystem::archive_wrapper::archive(archive_path.clone(), absolute_file_paths, tracker, &amp;cancel_flag)&#10;            .await&#10;            .map_err(|e| anyhow::anyhow!(&quot;Failed to create archive: {} - {}&quot;, archive_path.display(), e))?;&#10;&#10;        // Clean up the cancellation flag&#10;        {&#10;            let mut cancel_flags = get_archive_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;body.tracker_id);&#10;        }&#10;    } else {&#10;        return Err(anyhow::anyhow!(&quot;Invalid tracker id&quot;).into());&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[get(&quot;/archive/status/{tracker_id}&quot;)]&#10;pub async fn archive_status(params: web::Path&lt;(String, String)&gt;) -&gt; impl Responder {&#10;    let (_, tracker_id) = params.into_inner();&#10;    let (tx, rx) = tokio::sync::mpsc::channel(100);&#10;&#10;    // Store the sender in our tracker&#10;    {&#10;        let mut trackers = get_archive_trackers().lock().await;&#10;        trackers.insert(tracker_id.to_string(), tx);&#10;    }&#10;&#10;    Sse::from_infallible_receiver(rx).with_keep_alive(Duration::from_secs(3))&#10;}&#10;&#10;#[post(&quot;/archive/cancel/{tracker_id}&quot;)]&#10;pub async fn cancel_archive(tracker_id: web::Path&lt;String&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    let tracker_id = tracker_id.into_inner();&#10;&#10;    // Get the cancellation flag for this tracker&#10;    let cancel_flags = get_archive_cancel_flags().lock().await;&#10;&#10;    if let Some(flag) = cancel_flags.get(&amp;tracker_id) {&#10;        // Set the flag to true to signal cancellation&#10;        flag.store(true, Ordering::Relaxed);&#10;&#10;        Ok(HttpResponse::Ok().json(json!({&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;message&quot;: &quot;Archive operation cancelled&quot;&#10;        })))&#10;    } else {&#10;        // If the tracker doesn't exist, it might have already completed or never existed&#10;        Ok(HttpResponse::NotFound().json(json!({&#10;            &quot;status&quot;: &quot;error&quot;,&#10;            &quot;message&quot;: &quot;Archive operation not found or already completed&quot;&#10;        })))&#10;    }&#10;}&#10;&#10;#[get(&quot;/contents&quot;)]&#10;pub async fn get_file_contents(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let filepath = query.get(&quot;filepath&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'filepath' query parameter&quot;))?;&#10;    let filepath = base_path.join(filepath);&#10;    if !filepath.exists() || !filepath.is_file() {&#10;        return Err(anyhow::anyhow!(&quot;File not found&quot;).into());&#10;    }&#10;    let content = tokio::fs::read_to_string(filepath).await?;&#10;    Ok(HttpResponse::Ok().content_type(ContentType::plaintext()).body(content))&#10;}&#10;#[post(&quot;/contents&quot;)]&#10;pub async fn set_file_contents(&#10;    server_id: web::Path&lt;String&gt;,&#10;    query: web::Query&lt;HashMap&lt;String, String&gt;&gt;,&#10;    body: web::Bytes,&#10;    req: HttpRequest,&#10;) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let filepath = base_path.join(query.get(&quot;filepath&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'filepath' query parameter&quot;))?);&#10;    if !filepath.exists() || !filepath.is_file() {&#10;        return Err(anyhow::anyhow!(&quot;File not found&quot;).into());&#10;    }&#10;    tokio::fs::write(filepath, body.to_vec()).await?;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/extract&quot;)]&#10;pub async fn extract_archive(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let archive_path = base_path.join(query.get(&quot;archive&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'filepath' query parameter&quot;))?);&#10;    let output_path = base_path.join(query.get(&quot;directory&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'directory' query parameter&quot;))?);&#10;    let tracker_id = query.get(&quot;tracker&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'tracker' query parameter&quot;))?;&#10;&#10;&#10;    Ok(HttpResponse::Ok().finish())&#10;}&#10;&#10;pub fn configure(cfg: &amp;mut web::ServiceConfig) {&#10;    cfg.service(&#10;        web::scope(&quot;/fs&quot;)&#10;            .service(get_files)&#10;            .service(upload_file)&#10;            .service(upload_progress)&#10;            .service(cancel_upload)&#10;            .service(upload_url)&#10;            .service(download)&#10;            .service(copy_entry)&#10;            .service(move_entry)&#10;            .service(rename_entry)&#10;            .service(delete_entry)&#10;            .service(create_entry)&#10;            .service(search)&#10;            .service(archive_files)&#10;            .service(archive_status)&#10;            .service(cancel_archive)&#10;            .service(get_file_contents)&#10;            .service(set_file_contents)&#10;            .default_service(web::to(|| async {&#10;                HttpResponse::NotFound().json(json!({&#10;                    &quot;error&quot;: &quot;API endpoint not found&quot;.to_string(),&#10;                }))&#10;            })),&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="use crate::actix_util::http_error::Result;&#10;use crate::server::filesystem::filesystem_data::FilesystemData;&#10;use crate::server::server_data::ServerData;&#10;use actix_web::{HttpMessage, HttpRequest, HttpResponse, Responder, delete, get, post, web};&#10;use serde_hash::hashids::decode_single;&#10;use serde_json::json;&#10;use std::collections::HashMap;&#10;use std::sync::Arc;&#10;use std::sync::OnceLock;&#10;use std::sync::atomic::{AtomicBool, Ordering};&#10;use tokio::sync::Mutex;&#10;&#10;use crate::server::filesystem::download_parameters::DownloadParameters;&#10;use actix_web::http::header::{ContentDisposition, ContentType};&#10;use actix_web::test::default_service;&#10;use actix_web_lab::sse::Sse;&#10;use actix_web_lab::sse::{Data, Event};&#10;use actix_web_lab::sse;&#10;use anyhow::anyhow;&#10;use futures::{StreamExt, TryStreamExt};&#10;use log::{debug, error, warn};&#10;use serde::Deserialize;&#10;use std::ffi::OsStr;&#10;use std::io::ErrorKind;&#10;use std::path::PathBuf;&#10;use std::time::Duration;&#10;use tokio::fs::File;&#10;use tokio::io::AsyncWriteExt;&#10;use tokio::io::duplex;&#10;use tokio::sync::mpsc::Sender;&#10;use tokio_util::io::ReaderStream;&#10;&#10;// Global state for tracking operations&#10;type FileProcessTracker = Arc&lt;Mutex&lt;HashMap&lt;String, Sender&lt;Event&gt;&gt;&gt;&gt;;&#10;type UploadCancelFlags = Arc&lt;Mutex&lt;HashMap&lt;String, Arc&lt;AtomicBool&gt;&gt;&gt;&gt;;&#10;type ArchiveCancelFlags = Arc&lt;Mutex&lt;HashMap&lt;String, Arc&lt;AtomicBool&gt;&gt;&gt;&gt;;&#10;type ExtractCancelFlags = Arc&lt;Mutex&lt;HashMap&lt;String, Arc&lt;AtomicBool&gt;&gt;&gt;&gt;;&#10;&#10;static UPLOAD_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static ARCHIVE_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static EXTRACT_TRACKERS: OnceLock&lt;FileProcessTracker&gt; = OnceLock::new();&#10;static UPLOAD_CANCEL_FLAGS: OnceLock&lt;UploadCancelFlags&gt; = OnceLock::new();&#10;static ARCHIVE_CANCEL_FLAGS: OnceLock&lt;ArchiveCancelFlags&gt; = OnceLock::new();&#10;static EXTRACT_CANCEL_FLAGS: OnceLock&lt;ExtractCancelFlags&gt; = OnceLock::new();&#10;&#10;fn get_upload_trackers() -&gt; &amp;'static FileProcessTracker {&#10;    UPLOAD_TRACKERS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_archive_trackers() -&gt; &amp;'static FileProcessTracker {&#10;    ARCHIVE_TRACKERS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_extract_trackers() -&gt; &amp;'static FileProcessTracker {&#10;    EXTRACT_TRACKERS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_archive_cancel_flags() -&gt; &amp;'static ArchiveCancelFlags {&#10;    ARCHIVE_CANCEL_FLAGS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_upload_cancel_flags() -&gt; &amp;'static UploadCancelFlags {&#10;    UPLOAD_CANCEL_FLAGS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;fn get_extract_cancel_flags() -&gt; &amp;'static ExtractCancelFlags {&#10;    EXTRACT_CANCEL_FLAGS.get_or_init(|| Arc::new(Mutex::new(HashMap::new())))&#10;}&#10;&#10;// Request/Response structures&#10;#[derive(Deserialize)]&#10;struct CopyMoveRequest {&#10;    entries: Vec&lt;String&gt;,&#10;    path: String,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct RenameRequest {&#10;    source: String,&#10;    destination: String,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct DeleteRequest {&#10;    paths: Vec&lt;String&gt;,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct NewEntryRequest {&#10;    path: String,&#10;    is_directory: bool,&#10;}&#10;&#10;#[derive(Deserialize)]&#10;struct ArchiveRequest {&#10;    entries: Vec&lt;String&gt;,&#10;    cwd: String,&#10;    filename: String,&#10;    tracker_id: String,&#10;}&#10;&#10;#[get(&quot;/files&quot;)]&#10;pub async fn get_files(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;    let path = query.get(&quot;path&quot;).unwrap_or(&amp;String::from(&quot;&quot;)).to_string();&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let server_directory = server.get_directory_path();&#10;    let directory = server.get_directory_path().join(&amp;path);&#10;    if !directory.exists() {&#10;        return Err(anyhow::anyhow!(&quot;Directory not found&quot;).into());&#10;    }&#10;&#10;    let mut entries: FilesystemData = directory.try_into()?;&#10;    entries.entries = entries&#10;        .entries&#10;        .into_iter()&#10;        .map(|mut entry| {&#10;            entry.path = entry.path.trim_start_matches(server_directory.as_os_str().to_string_lossy().to_string().as_str()).to_string();&#10;            entry&#10;        })&#10;        .collect();&#10;&#10;    Ok(HttpResponse::Ok().json(entries))&#10;}&#10;&#10;#[post(&quot;/upload&quot;)]&#10;pub async fn upload_file(&#10;    server_id: web::Path&lt;String&gt;,&#10;    query: web::Query&lt;HashMap&lt;String, String&gt;&gt;,&#10;    mut payload: web::Payload,&#10;    req: HttpRequest,&#10;) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // Extract upload ID and file path from query parameters&#10;    let upload_id = query.get(&quot;upload_id&quot;).ok_or(anyhow::anyhow!(&quot;upload_id parameter is required&quot;))?.clone();&#10;    let file_path = query.get(&quot;path&quot;).ok_or(anyhow::anyhow!(&quot;path parameter is required&quot;))?.clone();&#10;    // trim leading slashes from file path&#10;    let file_path = file_path.trim_start_matches('/').trim_start_matches('\\').to_string();&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let full_path = server.get_directory_path().join(&amp;file_path);&#10;    let directory = full_path.parent().ok_or(anyhow::anyhow!(&quot;Invalid file path&quot;))?;&#10;    std::fs::create_dir_all(directory)?;&#10;&#10;    // Get the progress sender for this upload&#10;    let progress_sender = {&#10;        let trackers = get_upload_trackers().lock().await;&#10;        trackers.get(&amp;upload_id).cloned()&#10;    };&#10;&#10;    // Create a cancellation flag for this upload&#10;    let cancel_flag = Arc::new(AtomicBool::new(false));&#10;    {&#10;        let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;        cancel_flags.insert(upload_id.clone(), cancel_flag.clone());&#10;    }&#10;&#10;    let mut file = match File::create(&amp;full_path).await {&#10;        Ok(file) =&gt; file,&#10;        Err(_) =&gt; {&#10;            // Clean up the cancellation flag&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;            return Err(anyhow::anyhow!(&quot;Failed to create file&quot;).into());&#10;        }&#10;    };&#10;&#10;    let mut total_bytes = 0u64;&#10;&#10;    // Process the upload&#10;    while let Some(chunk) = payload.next().await {&#10;        // Check if upload was cancelled&#10;        if cancel_flag.load(Ordering::Relaxed) {&#10;            // Send cancellation event&#10;            if let Some(sender) = &amp;progress_sender {&#10;                let _ = sender&#10;                    .send(Event::from(Data::new(&#10;                        json!({&#10;                            &quot;status&quot;: &quot;cancelled&quot;,&#10;                            &quot;bytesUploaded&quot;: total_bytes&#10;                        })&#10;                        .to_string(),&#10;                    )))&#10;                    .await;&#10;            }&#10;&#10;            // Clean up&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;&#10;            // Close and delete the partial file&#10;            file.shutdown().await.ok();&#10;            tokio::fs::remove_file(&amp;full_path).await.ok();&#10;&#10;            return Ok(HttpResponse::Ok().json(json!({&#10;                &quot;status&quot;: &quot;cancelled&quot;,&#10;                &quot;message&quot;: &quot;Upload cancelled by user&quot;&#10;            })));&#10;        }&#10;&#10;        let bytes = match chunk {&#10;            Ok(bytes) =&gt; bytes,&#10;            Err(_) =&gt; {&#10;                // Clean up the cancellation flag&#10;                let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;                cancel_flags.remove(&amp;upload_id);&#10;                return Err(anyhow::anyhow!(&quot;Failed to read upload data&quot;).into());&#10;            }&#10;        };&#10;&#10;        if file.write_all(&amp;bytes).await.is_err() {&#10;            // Clean up the cancellation flag&#10;            let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;upload_id);&#10;            return Err(anyhow::anyhow!(&quot;Failed to write file&quot;).into());&#10;        }&#10;&#10;        total_bytes += bytes.len() as u64;&#10;&#10;        // Send progress update if we have a sender&#10;        if let Some(sender) = &amp;progress_sender {&#10;            let _ = sender&#10;                .send(Event::from(Data::new(&#10;                    json!({&#10;                        &quot;status&quot;: &quot;progress&quot;,&#10;                        &quot;bytesUploaded&quot;: total_bytes&#10;                    })&#10;                    .to_string(),&#10;                )))&#10;                .await;&#10;        }&#10;    }&#10;&#10;    // Send completion event&#10;    if let Some(sender) = &amp;progress_sender {&#10;        let _ = sender&#10;            .send(Event::from(Data::new(&#10;                json!({&#10;                    &quot;status&quot;: &quot;complete&quot;,&#10;                    &quot;bytesUploaded&quot;: total_bytes&#10;                })&#10;                .to_string(),&#10;            )))&#10;            .await;&#10;    }&#10;&#10;    // Clean up the cancellation flag&#10;    let mut cancel_flags = get_upload_cancel_flags().lock().await;&#10;    cancel_flags.remove(&amp;upload_id);&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&#10;        &quot;status&quot;: &quot;complete&quot;,&#10;        &quot;bytesUploaded&quot;: total_bytes&#10;    })))&#10;}&#10;&#10;#[get(&quot;/upload/progress/{upload_id}&quot;)]&#10;pub async fn upload_progress(params: web::Path&lt;(String, String)&gt;) -&gt; impl Responder {&#10;    let (_, upload_id) = params.into_inner();&#10;    let (tx, rx) = tokio::sync::mpsc::channel(100);&#10;&#10;    // Store the sender in our tracker&#10;    {&#10;        let mut trackers = get_upload_trackers().lock().await;&#10;        trackers.insert(upload_id.to_string(), tx);&#10;    }&#10;&#10;    Sse::from_infallible_receiver(rx).with_keep_alive(Duration::from_secs(3))&#10;}&#10;&#10;#[post(&quot;/upload/cancel/{upload_id}&quot;)]&#10;pub async fn cancel_upload(upload_id: web::Path&lt;String&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    let upload_id = upload_id.into_inner();&#10;&#10;    // Get the cancellation flag for this upload&#10;    let cancel_flags = get_upload_cancel_flags().lock().await;&#10;&#10;    if let Some(flag) = cancel_flags.get(&amp;upload_id) {&#10;        // Set the flag to true to signal cancellation&#10;        flag.store(true, Ordering::Relaxed);&#10;&#10;        Ok(HttpResponse::Ok().json(json!({&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;message&quot;: &quot;Upload operation cancelled&quot;&#10;        })))&#10;    } else {&#10;        // If the tracker doesn't exist, it might have already completed or never existed&#10;        Ok(HttpResponse::NotFound().json(json!({&#10;            &quot;status&quot;: &quot;error&quot;,&#10;            &quot;message&quot;: &quot;Upload operation not found or already completed&quot;&#10;        })))&#10;    }&#10;}&#10;&#10;#[get(&quot;/upload-url&quot;)]&#10;pub async fn upload_url(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let (sender, receiver) = tokio::sync::mpsc::channel(1);&#10;    let filepath = query.get(&quot;filepath&quot;).unwrap_or(&amp;String::from(&quot;&quot;)).to_string();&#10;    let url = query.get(&quot;url&quot;).ok_or(anyhow::anyhow!(&quot;URL parameter is required&quot;))?.clone();&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let filepath = server.get_directory_path().join(filepath);&#10;    let directory = filepath.parent().ok_or(anyhow::anyhow!(&quot;Invalid file path&quot;))?;&#10;    std::fs::create_dir_all(directory)?;&#10;    tokio::spawn(async move {&#10;        let resp = match reqwest::get(&amp;url).await {&#10;            Ok(r) =&gt; r,&#10;            Err(e) =&gt; {&#10;                error!(&quot;Failed to download file: {}&quot;, e);&#10;                let data = json!({&quot;error&quot;: format!(&quot;Failed to download file: {}&quot;, e)});&#10;                if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                    let message = Data::new(json).event(&quot;error&quot;);&#10;                    let _ = sender.send(message.into()).await;&#10;                }&#10;                return;&#10;            }&#10;        };&#10;        let total_size = resp.content_length().unwrap_or(0);&#10;        let mut downloaded: u64 = 0;&#10;        let mut body = Vec::new();&#10;&#10;        let mut stream = resp.bytes_stream();&#10;        while let Some(chunk) = match stream.try_next().await {&#10;            Ok(c) =&gt; c,&#10;            Err(e) =&gt; {&#10;                error!(&quot;Failed to read chunk: {}&quot;, e);&#10;                let data = json!({&quot;error&quot;: format!(&quot;Failed to read chunk: {}&quot;, e)});&#10;                if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                    let message = Data::new(json).event(&quot;error&quot;);&#10;                    let _ = sender.send(message.into()).await;&#10;                }&#10;                return;&#10;            }&#10;        } {&#10;            body.extend_from_slice(&amp;chunk);&#10;            downloaded += chunk.len() as u64;&#10;            if total_size &gt; 0 {&#10;                debug!(&quot;Download progress: {} - {}%&quot;, url, ((downloaded as f32) / total_size as f32) * 100f32);&#10;                let data = json!({&#10;                    &quot;progress&quot;: (downloaded as f32) / total_size as f32,&#10;                    &quot;downloaded&quot;: downloaded,&#10;                    &quot;total&quot;: total_size,&#10;                });&#10;                let message = Data::new(match serde_json::to_string(&amp;data) {&#10;                    Ok(s) =&gt; s,&#10;                    Err(e) =&gt; {&#10;                        error!(&quot;Failed to serialize progress data: {}&quot;, e);&#10;                        let data = json!({&quot;error&quot;: format!(&quot;Failed to serialize progress data: {}&quot;, e)});&#10;                        if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                            let message = Data::new(json).event(&quot;error&quot;);&#10;                            let _ = sender.send(message.into()).await;&#10;                        }&#10;                        return;&#10;                    }&#10;                })&#10;                .event(&quot;progress&quot;);&#10;                if let Err(e) = sender.send(message.into()).await {&#10;                    error!(&quot;Failed to send progress message: {}&quot;, e);&#10;                    let data = json!({&quot;error&quot;: format!(&quot;Failed to send progress message: {}&quot;, e)});&#10;                    if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                        let message = Data::new(json).event(&quot;error&quot;);&#10;                        let _ = sender.send(message.into()).await;&#10;                    }&#10;                    return;&#10;                }&#10;            }&#10;        }&#10;&#10;        if let Err(e) = tokio::fs::write(filepath, body).await {&#10;            error!(&quot;Failed to write file: {}&quot;, e);&#10;            let data = json!({&quot;error&quot;: format!(&quot;Failed to write file: {}&quot;, e)});&#10;            if let Ok(json) = serde_json::to_string(&amp;data) {&#10;                let message = Data::new(json).event(&quot;error&quot;);&#10;                let _ = sender.send(message.into()).await;&#10;            };&#10;        }&#10;&#10;        sender.try_send(Data::new_json(json!({&quot;message&quot;: &quot;File uploaded!&quot;})).unwrap().event(&quot;complete&quot;).into()).unwrap();&#10;    });&#10;&#10;    Ok(Sse::from_infallible_receiver(receiver).with_keep_alive(Duration::from_secs(10)))&#10;}&#10;&#10;#[get(&quot;/download&quot;)]&#10;async fn download(server_id: web::Path&lt;String&gt;, req: HttpRequest, query: web::Query&lt;DownloadParameters&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    use archflow::compress::FileOptions;&#10;    use archflow::compress::tokio::archive::ZipArchive;&#10;    use archflow::compression::CompressionMethod;&#10;    use archflow::error::ArchiveError;&#10;    use archflow::types::FileDateTime;&#10;&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    // get server from server id&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;&#10;    let server_directory = server.get_directory_path();&#10;    let items: Vec&lt;PathBuf&gt; = query.items.iter().map(|item| server_directory.join(item.trim_start_matches(&quot;\\&quot;).trim_start_matches(&quot;/&quot;))).collect();&#10;&#10;    let is_single_entry = items.len() == 1;&#10;    let is_single_entry_directory = is_single_entry &amp;&amp; items[0].is_dir();&#10;&#10;    let filename: String = if is_single_entry {&#10;        let guid = uuid::Uuid::new_v4().to_string();&#10;        let name = items[0].file_name().unwrap_or(OsStr::new(&amp;guid)).to_string_lossy().into_owned();&#10;        if is_single_entry_directory { format!(&quot;{}.zip&quot;, name) } else { name.to_string() }&#10;    } else {&#10;        format!(&quot;{}.zip&quot;, uuid::Uuid::new_v4())&#10;    };&#10;&#10;    // If there is only one entry, and it's a file,&#10;    // then stream the individual file to the client.&#10;    if is_single_entry &amp;&amp; !is_single_entry_directory {&#10;        let filepath = items[0].clone();&#10;        debug!(&quot;Downloading single file: {}&quot;, filepath.display());&#10;&#10;        let file = File::open(&amp;filepath).await.map_err(|_| anyhow!(&quot;Failed to open file for download: {}&quot;, filepath.display()))?;&#10;        let stream = ReaderStream::new(file);&#10;&#10;        return Ok(HttpResponse::Ok()&#10;            .content_type(&quot;application/octet-stream&quot;)&#10;            .insert_header(ContentDisposition::attachment(filename))&#10;            .streaming(stream));&#10;    }&#10;&#10;    debug!(&quot;Downloading multiple files: {:?}&quot;, items);&#10;&#10;    // For directories or multiple files, create a zip archive&#10;    let (w, r) = duplex(4096);&#10;    let items = items.clone();&#10;&#10;    tokio::spawn(async move {&#10;        let mut archive = ZipArchive::new_streamable(w);&#10;        let options = FileOptions::default().last_modified_time(FileDateTime::Now).compression_method(CompressionMethod::Store());&#10;&#10;        // Collect all files paths to put in the zip&#10;        let items_to_write = if is_single_entry_directory {&#10;            match tokio::fs::read_dir(items[0].clone()).await {&#10;                Ok(mut dir) =&gt; {&#10;                    let mut paths = Vec::new();&#10;                    while let Ok(Some(entry)) = dir.next_entry().await {&#10;                        paths.push(entry.path());&#10;                    }&#10;                    paths&#10;                }&#10;                Err(_) =&gt; items,&#10;            }&#10;        } else {&#10;            items&#10;        };&#10;&#10;        for item in items_to_write {&#10;            if let Some(filename) = item.file_name() {&#10;                let filename = filename.to_string_lossy().into_owned();&#10;                if item.is_dir() {&#10;                    // Process directory&#10;                    let walker = walkdir::WalkDir::new(&amp;item);&#10;                    if let Err(e) = archive.append_directory(filename.as_str(), &amp;options).await {&#10;                        error!(&quot;Failed to add directory to zip archive: {}&quot;, e);&#10;                        continue;&#10;                    }&#10;&#10;                    for entry in walker.into_iter().flatten() {&#10;                        let path = entry.path();&#10;                        let relative_path = path.strip_prefix(&amp;server_directory).unwrap_or(path);&#10;&#10;                        if path.is_dir() {&#10;                            debug!(&quot;Adding directory to zip archive: {} -&gt; {}&quot;, path.display(), relative_path.display());&#10;                            if let Err(e) = archive.append_directory(relative_path.to_string_lossy().replace('\\', &quot;/&quot;).as_ref(), &amp;options).await {&#10;                                error!(&quot;Failed to add directory to zip archive: {}&quot;, e);&#10;                                continue;&#10;                            }&#10;                            continue; // Directories are automatically created when adding files&#10;                        }&#10;&#10;                        debug!(&quot;Adding file to zip archive: {} -&gt; {}&quot;, path.display(), relative_path.display());&#10;                        if let Ok(mut file) = File::open(path).await {&#10;                            let _ = archive.append(relative_path.to_string_lossy().replace('\\', &quot;/&quot;).as_ref(), &amp;options, &amp;mut file).await;&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Process a single file&#10;                    debug!(&quot;Adding file to zip archive: {} -&gt; {}&quot;, item.display(), filename);&#10;                    if let Ok(mut file) = File::open(&amp;item).await {&#10;                        if let Err(e) = archive.append(filename.as_str(), &amp;options, &amp;mut file).await {&#10;                            if matches!(&amp;e, ArchiveError::IoError(err) if err.kind() == ErrorKind::BrokenPipe) {&#10;                                warn!(&quot;Zip archive stream closed, this is most-likely due to the client closing the connection.&quot;);&#10;                                break;&#10;                            }&#10;                            error!(&quot;Failed to add file to zip archive: {}&quot;, e);&#10;                            continue;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        let _ = archive.finalize().await;&#10;    });&#10;&#10;    Ok(HttpResponse::Ok().content_type(&quot;application/zip&quot;).insert_header(ContentDisposition::attachment(filename)).streaming(ReaderStream::new(r)))&#10;}&#10;&#10;#[post(&quot;/copy&quot;)]&#10;pub async fn copy_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;CopyMoveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for entry_path in &amp;body.entries {&#10;        let source = base_path.join(entry_path);&#10;        let dest = base_path.join(&amp;body.path).join(source.file_name().ok_or(anyhow::anyhow!(&quot;Invalid source path&quot;))?);&#10;&#10;        if source.is_dir() {&#10;            copy_dir_all(&amp;source, &amp;dest)?;&#10;        } else {&#10;            if let Some(parent) = dest.parent() {&#10;                std::fs::create_dir_all(parent)?;&#10;            }&#10;            std::fs::copy(&amp;source, &amp;dest)?;&#10;        }&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;fn copy_dir_all(src: &amp;std::path::Path, dst: &amp;std::path::Path) -&gt; std::io::Result&lt;()&gt; {&#10;    std::fs::create_dir_all(dst)?;&#10;    for entry in std::fs::read_dir(src)? {&#10;        let entry = entry?;&#10;        let ty = entry.file_type()?;&#10;        if ty.is_dir() {&#10;            copy_dir_all(&amp;entry.path(), &amp;dst.join(entry.file_name()))?;&#10;        } else {&#10;            std::fs::copy(entry.path(), dst.join(entry.file_name()))?;&#10;        }&#10;    }&#10;    Ok(())&#10;}&#10;&#10;#[post(&quot;/move&quot;)]&#10;pub async fn move_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;CopyMoveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for entry_path in &amp;body.entries {&#10;        let source = base_path.join(entry_path);&#10;        let dest = base_path.join(&amp;body.path).join(source.file_name().ok_or(anyhow::anyhow!(&quot;Invalid source path&quot;))?);&#10;&#10;        if let Some(parent) = dest.parent() {&#10;            std::fs::create_dir_all(parent)?;&#10;        }&#10;        std::fs::rename(&amp;source, &amp;dest)?;&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/rename&quot;)]&#10;pub async fn rename_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;RenameRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    let source = base_path.join(&amp;body.source);&#10;    let dest = base_path.join(&amp;body.destination);&#10;&#10;    if let Some(parent) = dest.parent() {&#10;        std::fs::create_dir_all(parent)?;&#10;    }&#10;    std::fs::rename(&amp;source, &amp;dest)?;&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[delete(&quot;/&quot;)]&#10;pub async fn delete_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;DeleteRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    for path in &amp;body.paths {&#10;        let full_path = base_path.join(path);&#10;        if full_path.is_dir() {&#10;            std::fs::remove_dir_all(&amp;full_path)?;&#10;        } else {&#10;            std::fs::remove_file(&amp;full_path)?;&#10;        }&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/new&quot;)]&#10;pub async fn create_entry(server_id: web::Path&lt;String&gt;, body: web::Json&lt;NewEntryRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let full_path = base_path.join(&amp;body.path);&#10;&#10;    if body.is_directory {&#10;        std::fs::create_dir_all(&amp;full_path)?;&#10;    } else {&#10;        if let Some(parent) = full_path.parent() {&#10;            std::fs::create_dir_all(parent)?;&#10;        }&#10;        std::fs::File::create(&amp;full_path)?;&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[get(&quot;/search&quot;)]&#10;pub async fn search(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let search_query = query.get(&quot;q&quot;).ok_or(anyhow::anyhow!(&quot;Search query parameter 'q' is required&quot;))?.clone();&#10;    let filename_only = query.get(&quot;filename_only&quot;).unwrap_or(&amp;&quot;false&quot;.to_string()) == &quot;true&quot;;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    let mut results = Vec::new();&#10;    search_directory(&amp;base_path, &amp;search_query, filename_only, &amp;mut results)?;&#10;&#10;    Ok(HttpResponse::Ok().json(results))&#10;}&#10;&#10;fn search_directory(dir: &amp;std::path::Path, query: &amp;str, filename_only: bool, results: &amp;mut Vec&lt;serde_json::Value&gt;) -&gt; std::io::Result&lt;()&gt; {&#10;    for entry in std::fs::read_dir(dir)? {&#10;        let entry = entry?;&#10;        let path = entry.path();&#10;        let filename = entry.file_name().to_string_lossy().to_lowercase();&#10;&#10;        let matches = if filename_only {&#10;            filename.contains(&amp;query.to_lowercase())&#10;        } else {&#10;            filename.contains(&amp;query.to_lowercase()) || path.to_string_lossy().to_lowercase().contains(&amp;query.to_lowercase())&#10;        };&#10;&#10;        if matches {&#10;            let metadata = path.metadata()?;&#10;            results.push(json!({&#10;                &quot;filename&quot;: entry.file_name().to_string_lossy(),&#10;                &quot;path&quot;: path.to_string_lossy(),&#10;                &quot;size&quot;: metadata.len(),&#10;                &quot;ctime&quot;: metadata.created().ok().and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok()).map(|d| d.as_secs()).unwrap_or(0),&#10;                &quot;mtime&quot;: metadata.modified().ok().and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok()).map(|d| d.as_secs()).unwrap_or(0),&#10;            }));&#10;        }&#10;&#10;        if path.is_dir() {&#10;            search_directory(&amp;path, query, filename_only, results)?;&#10;        }&#10;    }&#10;    Ok(())&#10;}&#10;&#10;#[post(&quot;/archive&quot;)]&#10;pub async fn archive_files(server_id: web::Path&lt;String&gt;, body: web::Json&lt;ArchiveRequest&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let cwd = base_path.join(&amp;body.cwd);&#10;    let archive_path = cwd.join(&amp;body.filename);&#10;&#10;    let trackers = get_archive_trackers().lock().await;&#10;    if let Some(tracker) = trackers.get(&amp;body.tracker_id) {&#10;        // Create a new cancellation flag for this operation&#10;        let cancel_flag = Arc::new(AtomicBool::new(false));&#10;&#10;        // Store the cancellation flag&#10;        {&#10;            let mut cancel_flags = get_archive_cancel_flags().lock().await;&#10;            cancel_flags.insert(body.tracker_id.clone(), cancel_flag.clone());&#10;        }&#10;&#10;        let absolute_file_paths: Vec&lt;PathBuf&gt; = body.entries.iter().map(|entry| cwd.join(entry)).collect();&#10;&#10;        // Use the archive_wrapper to create the archive&#10;        crate::server::filesystem::archive_wrapper::archive(archive_path.clone(), absolute_file_paths, tracker, &amp;cancel_flag)&#10;            .await&#10;            .map_err(|e| anyhow::anyhow!(&quot;Failed to create archive: {} - {}&quot;, archive_path.display(), e))?;&#10;&#10;        // Clean up the cancellation flag&#10;        {&#10;            let mut cancel_flags = get_archive_cancel_flags().lock().await;&#10;            cancel_flags.remove(&amp;body.tracker_id);&#10;        }&#10;    } else {&#10;        return Err(anyhow::anyhow!(&quot;Invalid tracker id&quot;).into());&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[get(&quot;/archive/status/{tracker_id}&quot;)]&#10;pub async fn archive_status(params: web::Path&lt;(String, String)&gt;) -&gt; impl Responder {&#10;    let (_, tracker_id) = params.into_inner();&#10;    let (tx, rx) = tokio::sync::mpsc::channel(100);&#10;&#10;    // Store the sender in our tracker&#10;    {&#10;        let mut trackers = get_archive_trackers().lock().await;&#10;        trackers.insert(tracker_id.to_string(), tx);&#10;    }&#10;&#10;    Sse::from_infallible_receiver(rx).with_keep_alive(Duration::from_secs(3))&#10;}&#10;&#10;#[post(&quot;/archive/cancel/{tracker_id}&quot;)]&#10;pub async fn cancel_archive(tracker_id: web::Path&lt;String&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    let tracker_id = tracker_id.into_inner();&#10;&#10;    // Get the cancellation flag for this tracker&#10;    let cancel_flags = get_archive_cancel_flags().lock().await;&#10;&#10;    if let Some(flag) = cancel_flags.get(&amp;tracker_id) {&#10;        // Set the flag to true to signal cancellation&#10;        flag.store(true, Ordering::Relaxed);&#10;&#10;        Ok(HttpResponse::Ok().json(json!({&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;message&quot;: &quot;Archive operation cancelled&quot;&#10;        })))&#10;    } else {&#10;        // If the tracker doesn't exist, it might have already completed or never existed&#10;        Ok(HttpResponse::NotFound().json(json!({&#10;            &quot;status&quot;: &quot;error&quot;,&#10;            &quot;message&quot;: &quot;Archive operation not found or already completed&quot;&#10;        })))&#10;    }&#10;}&#10;&#10;#[get(&quot;/contents&quot;)]&#10;pub async fn get_file_contents(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let filepath = query.get(&quot;filepath&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'filepath' query parameter&quot;))?;&#10;    let filepath = base_path.join(filepath);&#10;    if !filepath.exists() || !filepath.is_file() {&#10;        return Err(anyhow::anyhow!(&quot;File not found&quot;).into());&#10;    }&#10;    let content = tokio::fs::read_to_string(filepath).await?;&#10;    Ok(HttpResponse::Ok().content_type(ContentType::plaintext()).body(content))&#10;}&#10;#[post(&quot;/contents&quot;)]&#10;pub async fn set_file_contents(&#10;    server_id: web::Path&lt;String&gt;,&#10;    query: web::Query&lt;HashMap&lt;String, String&gt;&gt;,&#10;    body: web::Bytes,&#10;    req: HttpRequest,&#10;) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;    let filepath = base_path.join(query.get(&quot;filepath&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'filepath' query parameter&quot;))?);&#10;    if !filepath.exists() || !filepath.is_file() {&#10;        return Err(anyhow::anyhow!(&quot;File not found&quot;).into());&#10;    }&#10;    tokio::fs::write(filepath, body.to_vec()).await?;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[post(&quot;/extract&quot;)]&#10;pub async fn extract_archive(server_id: web::Path&lt;String&gt;, query: web::Query&lt;HashMap&lt;String, String&gt;&gt;, req: HttpRequest) -&gt; Result&lt;impl Responder&gt; {&#10;    let server_id = decode_single(server_id.as_str())?;&#10;    let user = req.extensions().get::&lt;crate::authentication::auth_data::UserData&gt;().cloned().ok_or(anyhow::anyhow!(&quot;User not found in request&quot;))?;&#10;    let user_id = user.id.ok_or(anyhow::anyhow!(&quot;User ID not found&quot;))?;&#10;&#10;    let server = ServerData::get(server_id, user_id).await?.ok_or(anyhow::anyhow!(&quot;Server not found&quot;))?;&#10;    let base_path = server.get_directory_path();&#10;&#10;    // Trim leading slashes and get paths relative to server directory&#10;    let archive_param = query.get(&quot;archive&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'archive' query parameter&quot;))?;&#10;    let output_param = query.get(&quot;directory&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'directory' query parameter&quot;))?;&#10;    let tracker_id = query.get(&quot;tracker&quot;).ok_or(anyhow::anyhow!(&quot;Missing 'tracker' query parameter&quot;))?;&#10;&#10;    let archive_path = base_path.join(archive_param.trim_start_matches('/').trim_start_matches('\\'));&#10;    let output_path = base_path.join(output_param.trim_start_matches('/').trim_start_matches('\\'));&#10;&#10;    // Validate archive exists&#10;    if !archive_path.exists() || !archive_path.is_file() {&#10;        return Err(anyhow::anyhow!(&quot;Archive file not found&quot;).into());&#10;    }&#10;&#10;    // Get tracker for progress updates&#10;    let trackers = get_extract_trackers().lock().await;&#10;    if let Some(tracker) = trackers.get(tracker_id) {&#10;        // Create a new cancellation flag for this operation&#10;        let cancel_flag = Arc::new(AtomicBool::new(false));&#10;&#10;        // Store the cancellation flag&#10;        {&#10;            let mut cancel_flags = get_extract_cancel_flags().lock().await;&#10;            cancel_flags.insert(tracker_id.clone(), cancel_flag.clone());&#10;        }&#10;&#10;        // Use the extract_wrapper to extract the archive&#10;        tokio::task::spawn_blocking({&#10;            let archive_path = archive_path.clone();&#10;            let output_path = output_path.clone();&#10;            let tracker = tracker.clone();&#10;            let cancel_flag = cancel_flag.clone();&#10;            let tracker_id = tracker_id.clone();&#10;            &#10;            move || {&#10;                let rt = tokio::runtime::Handle::current();&#10;                rt.block_on(async {&#10;                    let result = crate::server::filesystem::extract_wrapper::extract(&#10;                        archive_path, &#10;                        output_path, &#10;                        &amp;tracker, &#10;                        &amp;cancel_flag&#10;                    ).await;&#10;                    &#10;                    if let Err(e) = result {&#10;                        error!(&quot;Failed to extract archive: {}&quot;, e);&#10;                        let _ = tracker.send(Event::from(sse::Data::new(format!(&#10;                            &quot;{{ \&quot;progress\&quot;: 0, \&quot;status\&quot;: \&quot;error\&quot;, \&quot;error\&quot;: \&quot;{}\&quot; }}&quot;, &#10;                            e.to_string()&#10;                        )))).await;&#10;                    }&#10;                    &#10;                    // Clean up the cancellation flag&#10;                    let mut cancel_flags = get_extract_cancel_flags().lock().await;&#10;                    cancel_flags.remove(&amp;tracker_id);&#10;                })&#10;            }&#10;        });&#10;    } else {&#10;        return Err(anyhow::anyhow!(&quot;Invalid tracker id&quot;).into());&#10;    }&#10;&#10;    Ok(HttpResponse::Ok().json(json!({&quot;status&quot;: &quot;success&quot;})))&#10;}&#10;&#10;#[get(&quot;/extract/status/{tracker_id}&quot;)]&#10;pub async fn extract_status(params: web::Path&lt;(String, String)&gt;) -&gt; impl Responder {&#10;    let (_, tracker_id) = params.into_inner();&#10;    let (tx, rx) = tokio::sync::mpsc::channel(100);&#10;&#10;    // Store the sender in our tracker&#10;    {&#10;        let mut trackers = get_extract_trackers().lock().await;&#10;        trackers.insert(tracker_id.to_string(), tx);&#10;    }&#10;&#10;    Sse::from_infallible_receiver(rx).with_keep_alive(Duration::from_secs(3))&#10;}&#10;&#10;#[post(&quot;/extract/cancel/{tracker_id}&quot;)]&#10;pub async fn cancel_extract(tracker_id: web::Path&lt;String&gt;) -&gt; Result&lt;impl Responder&gt; {&#10;    let tracker_id = tracker_id.into_inner();&#10;&#10;    // Get the cancellation flag for this tracker&#10;    let cancel_flags = get_extract_cancel_flags().lock().await;&#10;&#10;    if let Some(flag) = cancel_flags.get(&amp;tracker_id) {&#10;        // Set the flag to true to signal cancellation&#10;        flag.store(true, Ordering::Relaxed);&#10;&#10;        Ok(HttpResponse::Ok().json(json!({&#10;            &quot;status&quot;: &quot;success&quot;,&#10;            &quot;message&quot;: &quot;Extract operation cancelled&quot;&#10;        })))&#10;    } else {&#10;        // If the tracker doesn't exist, it might have already completed or never existed&#10;        Ok(HttpResponse::NotFound().json(json!({&#10;            &quot;status&quot;: &quot;error&quot;,&#10;            &quot;message&quot;: &quot;Extract operation not found or already completed&quot;&#10;        })))&#10;    }&#10;}&#10;&#10;pub fn configure(cfg: &amp;mut web::ServiceConfig) {&#10;    cfg.service(&#10;        web::scope(&quot;/fs&quot;)&#10;            .service(get_files)&#10;            .service(upload_file)&#10;            .service(upload_progress)&#10;            .service(cancel_upload)&#10;            .service(upload_url)&#10;            .service(download)&#10;            .service(copy_entry)&#10;            .service(move_entry)&#10;            .service(rename_entry)&#10;            .service(delete_entry)&#10;            .service(create_entry)&#10;            .service(search)&#10;            .service(archive_files)&#10;            .service(archive_status)&#10;            .service(cancel_archive)&#10;            .service(get_file_contents)&#10;            .service(set_file_contents)&#10;            .service(extract_archive)&#10;            .service(extract_status)&#10;            .service(cancel_extract)&#10;            .default_service(web::to(|| async {&#10;                HttpResponse::NotFound().json(json!({&#10;                    &quot;error&quot;: &quot;API endpoint not found&quot;.to_string(),&#10;                }))&#10;            })),&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs" />
              <option name="originalContent" value="mod filesystem_data;&#10;mod filesystem_endpoint;&#10;mod download_parameters;&#10;mod archive_wrapper;&#10;mod normalize_path;&#10;&#10;pub use filesystem_endpoint::configure;&#10;" />
              <option name="updatedContent" value="mod filesystem_data;&#13;&#10;mod filesystem_endpoint;&#13;&#10;mod download_parameters;&#13;&#10;mod archive_wrapper;&#13;&#10;mod extract_wrapper;&#13;&#10;mod normalize_path;&#13;&#10;&#13;&#10;pub use filesystem_endpoint::configure;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/MessageModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/MessageModal.tsx" />
              <option name="originalContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={isOpen}&#10;            onClose={() =&gt; onClose(responseType === MessageResponseType.Close ? null : false)}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{&#10;                closeButton: &quot;rounded-none&quot;,&#10;                backdrop: severity === &quot;danger&quot; ? &quot;bg-danger/10&quot; : &quot;&quot;&#10;            }}&#10;            data-severity={severity}&#10;            isDismissable={false}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {() =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;flex flex-row items-center gap-2 text-2xl&quot;}&gt;&#10;                            &lt;span className={&quot;text-3xl h-[30px]&quot;}&gt;{typeof icon === &quot;string&quot; ? &lt;Icon icon={icon}/&gt; : icon == null ? &lt;MessageIcon severity={severity}/&gt; : icon}&lt;/span&gt;&#10;                            &lt;span&#10;                                className={&quot;data-[severity=danger]:text-danger data-[severity=warning]:text-warning data-[severity=info]:text-blue-500 data-[severity=success]:text-success&quot;}&#10;                                data-severity={severity}&#10;                            &gt;&#10;                                {title}&#10;                            &lt;/span&gt;&#10;                        &lt;/ModalHeader&gt;&#10;                        &lt;ModalBody&gt;&#10;                            {body}&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            {({&#10;                                [MessageResponseType.YesNo]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Yes&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;No&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.OkayCancel]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Okay&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;Cancel&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.Close]: (&#10;                                    &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} autoFocus&gt;Close&lt;/Button&gt;&#10;                                )&#10;                            })[responseType]}&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;const MessageIcon = ({severity}: { severity: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot; | undefined }) =&gt;&#10;{&#10;    switch (severity)&#10;    {&#10;        case &quot;info&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:info-box&quot;} className={&quot;text-blue-500&quot;}/&gt;;&#10;        case &quot;warning&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:warning-box&quot;} className={&quot;text-warning&quot;}/&gt;;&#10;        case &quot;danger&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:alert&quot;} className={&quot;text-danger&quot;}/&gt;;&#10;        case &quot;success&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:radio-on&quot;} className={&quot;text-success&quot;}/&gt;;&#10;        default:&#10;            return null;&#10;    }&#10;};" />
              <option name="updatedContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode, useEffect} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;&#10;    // Handle keyboard events for Enter and Space&#10;    useEffect(() =&gt; {&#10;        if (!isOpen) return;&#10;&#10;        const handleKeyDown = (event: KeyboardEvent) =&gt; {&#10;            if (event.key === 'Enter' || event.key === ' ') {&#10;                event.preventDefault();&#10;                event.stopPropagation();&#10;                // Trigger the primary action (Yes/Okay/Close)&#10;                onClose(true);&#10;            }&#10;        };&#10;&#10;        // Add event listener when modal is open&#10;        document.addEventListener('keydown', handleKeyDown);&#10;&#10;        // Cleanup event listener when modal closes or component unmounts&#10;        return () =&gt; {&#10;            document.removeEventListener('keydown', handleKeyDown);&#10;        };&#10;    }, [isOpen, onClose]);&#10;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={isOpen}&#10;            onClose={() =&gt; onClose(responseType === MessageResponseType.Close ? null : false)}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{&#10;                closeButton: &quot;rounded-none&quot;,&#10;                backdrop: severity === &quot;danger&quot; ? &quot;bg-danger/10&quot; : &quot;&quot;&#10;            }}&#10;            data-severity={severity}&#10;            isDismissable={false}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {() =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;flex flex-row items-center gap-2 text-2xl&quot;}&gt;&#10;                            &lt;span className={&quot;text-3xl h-[30px]&quot;}&gt;{typeof icon === &quot;string&quot; ? &lt;Icon icon={icon}/&gt; : icon == null ? &lt;MessageIcon severity={severity}/&gt; : icon}&lt;/span&gt;&#10;                            &lt;span&#10;                                className={&quot;data-[severity=danger]:text-danger data-[severity=warning]:text-warning data-[severity=info]:text-blue-500 data-[severity=success]:text-success&quot;}&#10;                                data-severity={severity}&#10;                            &gt;&#10;                                {title}&#10;                            &lt;/span&gt;&#10;                        &lt;/ModalHeader&gt;&#10;                        &lt;ModalBody&gt;&#10;                            {body}&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            {({&#10;                                [MessageResponseType.YesNo]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Yes&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;No&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.OkayCancel]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Okay&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;Cancel&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.Close]: (&#10;                                    &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} autoFocus&gt;Close&lt;/Button&gt;&#10;                                )&#10;                            })[responseType]}&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;const MessageIcon = ({severity}: { severity: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot; | undefined }) =&gt;&#10;{&#10;    switch (severity)&#10;    {&#10;        case &quot;info&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:info-box&quot;} className={&quot;text-blue-500&quot;}/&gt;;&#10;        case &quot;warning&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:warning-box&quot;} className={&quot;text-warning&quot;}/&gt;;&#10;        case &quot;danger&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:alert&quot;} className={&quot;text-danger&quot;}/&gt;;&#10;        case &quot;success&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:radio-on&quot;} className={&quot;text-success&quot;}/&gt;;&#10;        default:&#10;            return null;&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx" />
              <option name="originalContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;export type ContextMenuOptions = {&#10;    entry?: FilesystemEntry | FilesystemEntry[];&#10;    x: number;&#10;    y: number;&#10;    isOpen: boolean;&#10;}&#10;type RowContextMenuProps = {&#10;    onRename: (entry: FilesystemEntry) =&gt; void;&#10;    onDelete: (entry: FilesystemEntry[]) =&gt; void;&#10;    onArchive: (entry: FilesystemEntry[]) =&gt; void;&#10;    onEdit: (entry: FilesystemEntry) =&gt; void;&#10;    onClose: () =&gt; void;&#10;} &amp; ContextMenuOptions;&#10;&#10;export function RowContextMenu({entry, y, x, isOpen, onClose, onRename, onDelete, onArchive, onEdit}: RowContextMenuProps)&#10;{&#10;    const {downloadEntry} = useServer();&#10;    const [position, setPosition] = useState({x, y});&#10;    const menuRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;&#10;    const downloadSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;        onClose();&#10;        await downloadEntry(entry);&#10;    }, [entry, downloadEntry, isOpen]);&#10;&#10;    const deleteSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;&#10;        onClose();&#10;        if (Array.isArray(entry)) onDelete(entry);&#10;        else onDelete([entry]);&#10;    }, [entry, isOpen]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let parent = $(&quot;#server-file-browser&quot;);&#10;        let menu = menuRef.current;&#10;        if (parent.length === 0 || !menu) return;&#10;        let menuElement = $(menu);&#10;&#10;        let offset = parent.offset();&#10;        let parentWidth = parent.width();&#10;        let parentHeight = parent.height();&#10;        let menuWidth = menuElement.outerWidth();&#10;        let menuHeight = menuElement.outerHeight();&#10;        if (!offset || !menuWidth || !menuHeight || !parentWidth || !parentHeight) return;&#10;&#10;&#10;        let newX = x;&#10;        let newY = y;&#10;        if (newX + menuWidth &gt; offset.left + parentWidth)&#10;        {&#10;            newX = (offset.left + parentWidth) - menuWidth - 10; // 10px padding&#10;        }&#10;        if (newY + menuHeight &gt; offset.top + parentHeight)&#10;        {&#10;            newY = (offset.top + parentHeight) - menuHeight - 10; // 10px padding&#10;        }&#10;&#10;        setPosition({x: newX - 50, y: newY - 340});&#10;    }, [x, y, isOpen, onClose]);&#10;    return (&#10;        &lt;Listbox&#10;            id={&quot;server-files-context-menu&quot;}&#10;            ref={menuRef}&#10;            className={&quot;absolute z-50 w-64 bg-background/50 backdrop-blur-sm border border-primary/50 shadow-lg data-[open=true]:opacity-100 data-[open=false]:opacity-0 transition-opacity duration-200 data-[open=false]:pointer-events-none font-minecraft-body&quot;}&#10;            style={{top: position.y, left: position.x}}&#10;            itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&#10;            data-open={isOpen}&#10;            onSelectionChange={() =&gt; onClose()}&#10;            tabIndex={1}&#10;        &gt;&#10;            &lt;ListboxSection title={Array.isArray(entry) ? `${entry.length} Items Selected` : entry?.filename ?? &quot;&quot;} itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&gt;&#10;                {!Array.isArray(entry) &amp;&amp; entry ? (() =&gt;&#10;                {&#10;                    let singleItemOptions = [];&#10;                    if (!entry?.is_dir &amp;&amp; isTextFile(entry?.path))&#10;                    {&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;edit&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:edit-box&quot;}/&gt;} onPress={() =&gt; onEdit(entry)}&gt;Edit&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;&#10;                    return (&#10;                        &lt;&gt;&#10;                            {...singleItemOptions}&#10;                            &lt;ListboxItem key={&quot;rename&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:unlink&quot;}/&gt;} onPress={() =&gt;&#10;                            {&#10;                                onRename(entry);&#10;                                onClose();&#10;                            }}&gt;Rename&lt;/ListboxItem&gt;&#10;                        &lt;/&gt;&#10;                    );&#10;                })() : null}&#10;                &lt;ListboxItem key={&quot;archive&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;} onPress={() =&gt; onArchive(Array.isArray(entry) ? entry : [entry] as FilesystemEntry[])}&gt;Archive&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;download&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:flatten&quot;}/&gt;} onPress={downloadSelectedEntries}&gt;Download&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;delete&quot;} color={&quot;danger&quot;} className={&quot;text-danger&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;} onPress={deleteSelectedEntries}&gt;Delete&lt;/ListboxItem&gt;&#10;            &lt;/ListboxSection&gt;&#10;        &lt;/Listbox&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;// Helper function to check if a file is an archive&#10;const isArchiveFile = (filename: string): boolean =&gt; {&#10;    const archiveExtensions = ['.zip', '.tar.gz', '.tgz', '.tar', '.rar', '.7z'];&#10;    const lowerFilename = filename.toLowerCase();&#10;    return archiveExtensions.some(ext =&gt; lowerFilename.endsWith(ext));&#10;};&#10;&#10;// Helper function to get archive name without extension&#10;const getArchiveBaseName = (filename: string): string =&gt; {&#10;    if (filename.toLowerCase().endsWith('.tar.gz')) {&#10;        return filename.slice(0, -7); // Remove .tar.gz&#10;    } else if (filename.toLowerCase().endsWith('.tgz')) {&#10;        return filename.slice(0, -4); // Remove .tgz&#10;    } else {&#10;        // Remove last extension for other formats&#10;        const lastDotIndex = filename.lastIndexOf('.');&#10;        return lastDotIndex &gt; 0 ? filename.slice(0, lastDotIndex) : filename;&#10;    }&#10;};&#10;&#10;export type ContextMenuOptions = {&#10;    entry?: FilesystemEntry | FilesystemEntry[];&#10;    x: number;&#10;    y: number;&#10;    isOpen: boolean;&#10;}&#10;type RowContextMenuProps = {&#10;    onRename: (entry: FilesystemEntry) =&gt; void;&#10;    onDelete: (entry: FilesystemEntry[]) =&gt; void;&#10;    onArchive: (entry: FilesystemEntry[]) =&gt; void;&#10;    onExtract: (entry: FilesystemEntry, outputPath?: string) =&gt; void;&#10;    onEdit: (entry: FilesystemEntry) =&gt; void;&#10;    onClose: () =&gt; void;&#10;} &amp; ContextMenuOptions;&#10;&#10;export function RowContextMenu({entry, y, x, isOpen, onClose, onRename, onDelete, onArchive, onEdit, onExtract}: RowContextMenuProps)&#10;{&#10;    const {downloadEntry} = useServer();&#10;    const [position, setPosition] = useState({x, y});&#10;    const menuRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;&#10;    const downloadSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;        onClose();&#10;        await downloadEntry(entry);&#10;    }, [entry, downloadEntry, isOpen]);&#10;&#10;    const deleteSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;&#10;        onClose();&#10;        if (Array.isArray(entry)) onDelete(entry);&#10;        else onDelete([entry]);&#10;    }, [entry, isOpen]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let parent = $(&quot;#server-file-browser&quot;);&#10;        let menu = menuRef.current;&#10;        if (parent.length === 0 || !menu) return;&#10;        let menuElement = $(menu);&#10;&#10;        let offset = parent.offset();&#10;        let parentWidth = parent.width();&#10;        let parentHeight = parent.height();&#10;        let menuWidth = menuElement.outerWidth();&#10;        let menuHeight = menuElement.outerHeight();&#10;        if (!offset || !menuWidth || !menuHeight || !parentWidth || !parentHeight) return;&#10;&#10;&#10;        let newX = x;&#10;        let newY = y;&#10;        if (newX + menuWidth &gt; offset.left + parentWidth)&#10;        {&#10;            newX = (offset.left + parentWidth) - menuWidth - 10; // 10px padding&#10;        }&#10;        if (newY + menuHeight &gt; offset.top + parentHeight)&#10;        {&#10;            newY = (offset.top + parentHeight) - menuHeight - 10; // 10px padding&#10;        }&#10;&#10;        setPosition({x: newX - 50, y: newY - 340});&#10;    }, [x, y, isOpen, onClose]);&#10;    return (&#10;        &lt;Listbox&#10;            id={&quot;server-files-context-menu&quot;}&#10;            ref={menuRef}&#10;            className={&quot;absolute z-50 w-64 bg-background/50 backdrop-blur-sm border border-primary/50 shadow-lg data-[open=true]:opacity-100 data-[open=false]:opacity-0 transition-opacity duration-200 data-[open=false]:pointer-events-none font-minecraft-body&quot;}&#10;            style={{top: position.y, left: position.x}}&#10;            itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&#10;            data-open={isOpen}&#10;            onSelectionChange={() =&gt; onClose()}&#10;            tabIndex={1}&#10;        &gt;&#10;            &lt;ListboxSection title={Array.isArray(entry) ? `${entry.length} Items Selected` : entry?.filename ?? &quot;&quot;} itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&gt;&#10;                {!Array.isArray(entry) &amp;&amp; entry ? (() =&gt;&#10;                {&#10;                    let singleItemOptions = [];&#10;                    if (!entry?.is_dir &amp;&amp; isTextFile(entry?.path))&#10;                    {&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;edit&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:edit-box&quot;}/&gt;} onPress={() =&gt; onEdit(entry)}&gt;Edit&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    // Add extract options for archive files&#10;                    if (!entry?.is_dir &amp;&amp; isArchiveFile(entry?.filename))&#10;                    {&#10;                        const archiveBaseName = getArchiveBaseName(entry.filename);&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-here&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:extract&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry);&#10;                                onClose();&#10;                            }}&gt;Extract Here&lt;/ListboxItem&gt;&#10;                        );&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-to-folder&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:folder-open&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry, archiveBaseName);&#10;                                onClose();&#10;                            }}&gt;Extract to {archiveBaseName}&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    return (&#10;                        &lt;&gt;&#10;                            {...singleItemOptions}&#10;                            &lt;ListboxItem key={&quot;rename&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:unlink&quot;}/&gt;} onPress={() =&gt;&#10;                            {&#10;                                onRename(entry);&#10;                                onClose();&#10;                            }}&gt;Rename&lt;/ListboxItem&gt;&#10;                        &lt;/&gt;&#10;                    );&#10;                })() : null}&#10;                &lt;ListboxItem key={&quot;archive&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;} onPress={() =&gt; onArchive(Array.isArray(entry) ? entry : [entry] as FilesystemEntry[])}&gt;Archive&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;download&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:flatten&quot;}/&gt;} onPress={downloadSelectedEntries}&gt;Download&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;delete&quot;} color={&quot;danger&quot;} className={&quot;text-danger&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;} onPress={deleteSelectedEntries}&gt;Delete&lt;/ListboxItem&gt;&#10;            &lt;/ListboxSection&gt;&#10;        &lt;/Listbox&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/ServerFiles.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/ServerFiles.tsx" />
              <option name="originalContent" value="import {Button, ButtonGroup, Chip, cn, Input, Progress, Skeleton, Table, TableBody, TableCell, TableColumn, TableHeader, TableRow} from &quot;@heroui/react&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import {KeyboardEvent, useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {FilesystemData, FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import &quot;../../../../ts/math-ext.ts&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {ContextMenuOptions, RowContextMenu} from &quot;./RowContextMenu.tsx&quot;;&#10;import {useMessage} from &quot;../../../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../../../MessageModal.tsx&quot;;&#10;import {FileTableBreadcrumbs} from &quot;./FileTableBreadcrumbs.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {ErrorBoundary} from &quot;../../../ErrorBoundry.tsx&quot;;&#10;import {FileEntryIcon} from &quot;./FileEntryIcon.tsx&quot;;&#10;import {Editor} from &quot;@monaco-editor/react&quot;;&#10;import {getMonacoLanguage, isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {registerMinecraftPropertiesLanguage} from &quot;../../../../ts/minecraft-properties-language.ts&quot;;&#10;import {motion, AnimatePresence} from &quot;framer-motion&quot;;&#10;&#10;// Define the theme outside of the component&#10;const defineObsidianTheme = (monaco: any) =&gt;&#10;{&#10;    monaco.editor.defineTheme(&quot;obsidian-editor-theme&quot;, {&#10;        base: &quot;vs-dark&quot;,&#10;        inherit: true,&#10;        rules: [&#10;            {token: &quot;key&quot;, foreground: &quot;#47ebb4&quot;},&#10;            {token: &quot;value&quot;, foreground: &quot;#CE9178&quot;},&#10;            {token: &quot;comment&quot;, foreground: &quot;#57718e&quot;, fontStyle: &quot;italic&quot;},&#10;            {token: &quot;operator&quot;, foreground: &quot;#0aa370&quot;}&#10;        ],&#10;        colors: {&#10;            &quot;editor.background&quot;: &quot;#0b0b0e&quot;&#10;        }&#10;    });&#10;};&#10;&#10;type UploadProgress = {&#10;    entry: FilesystemEntry;&#10;    progress: number;&#10;    files: string[]&#10;    isUploading: boolean;&#10;    uploadGroup?: string;&#10;    filesProcessed?: number;&#10;    totalFiles?: number;&#10;    operationType: 'upload' | 'archive' | 'extract';&#10;}&#10;&#10;export function ServerFiles()&#10;{&#10;    const {getEntries, renameEntry, createEntry, deleteEntry, uploadFile, archiveFiles, extractArchive, getFileContents, setFileContents} = useServer();&#10;    const {open} = useMessage();&#10;    const [path, setPath] = useState(&quot;&quot;);&#10;    const [data, setData] = useState&lt;FilesystemData&gt;();&#10;    const [selectedEntries, setSelectedEntries] = useState&lt;FilesystemEntry[]&gt;([]);&#10;    const [contextMenuOptions, setContextMenuOptions] = useState&lt;ContextMenuOptions&gt;({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [renamingEntry, setRenamingEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newItemCreationEntry, setNewItemCreationEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newArchiveEntry, setNewArchiveEntry] = useState&lt;UploadProgress | undefined&gt;(undefined);&#10;    const [fileUploadEntries, setFileUploadEntries] = useState&lt;UploadProgress[]&gt;([]);&#10;    const [isDraggingOver, setIsDraggingOver] = useState(false);&#10;    const [isEditingFile, setIsEditingFile] = useState(false);&#10;    const [selectedFileContents, setSelectedFileContents] = useState(&quot;&quot;);&#10;    const [isDragging, setIsDragging] = useState(false);&#10;    const [editorWidth, setEditorWidth] = useState(() =&gt;&#10;    {&#10;        // Load saved width from localStorage or use default&#10;        const savedWidth = localStorage.getItem(&quot;editor-width&quot;);&#10;        return savedWidth ? parseInt(savedWidth, 10) : 400;&#10;    });&#10;    const editorRef = useRef&lt;any&gt;(null);&#10;    const monacoRef = useRef&lt;any&gt;(null);&#10;    const editorWrapperRef = useRef&lt;HTMLDivElement&gt;(null);&#10;    const editorSaveTimerRef = useRef&lt;number | undefined&gt;(undefined);&#10;    const [needsToSave, setNeedsToSave] = useState(false);&#10;    const newContentRef = useRef&lt;string&gt;(&quot;&quot;);&#10;&#10;    const selectedEntriesRef = useRef&lt;FilesystemEntry[]&gt;([]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        selectedEntriesRef.current = selectedEntries;&#10;    }, [selectedEntries]);&#10;&#10;    const scrollToTop = useCallback(() =&gt;&#10;    {&#10;        $(&quot;#server-files-table&quot;).parent().scrollTop(0);&#10;    }, [path]);&#10;&#10;    const saveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        const file = currentSelectedEntries[0]?.path;&#10;&#10;        console.log(&quot;Attempting to save content:&quot;, newContentRef, &quot;Needs to save:&quot;, needsToSave, &quot;File:&quot;, currentSelectedEntries);&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        setNeedsToSave(false);&#10;&#10;        try&#10;        {&#10;            if (!file || !newContentRef.current)&#10;            {&#10;                console.warn(&quot;No file selected or content is empty, skipping save.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Save the content to the file&#10;            console.log(&quot;Saving file:&quot;, file, newContentRef.current);&#10;            await setFileContents(file, newContentRef.current);&#10;            newContentRef.current = &quot;&quot;;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save file:&quot;, error);&#10;            await open({&#10;                title: &quot;Save File Failed&quot;,&#10;                body: &quot;An error occurred while saving the file. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [newContentRef, editorSaveTimerRef, needsToSave, open]);&#10;&#10;    const reboundSaveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        if (!currentSelectedEntries || currentSelectedEntries.length !== 1 || !isTextFile(currentSelectedEntries[0].path)) return;&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        editorSaveTimerRef.current = setTimeout(async () =&gt;&#10;        {&#10;            await saveContent();&#10;        }, 5000);&#10;    }, [saveContent]);&#10;&#10;    const upload = useCallback(async (files: File[]) =&gt;&#10;    {&#10;        let uploadGroup = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);&#10;        let promises = [];&#10;        for (let file of files)&#10;        {&#10;            let entry = {filename: file.name, path, is_dir: false, size: file.size, file_type: file.type, operationType: 'upload'} as FilesystemEntry;&#10;            setFileUploadEntries(prev =&gt; [...prev, {entry, progress: 0, files: [file.name], isUploading: true, uploadGroup, operationType: 'upload'}]);&#10;            let totalSize = file.size;&#10;            const {promise} = await uploadFile(file, entry.path, async bytes =&gt;&#10;                {&#10;                    let progress = bytes / totalSize;&#10;                    setFileUploadEntries(prev =&gt; prev.map(upload =&gt; upload.entry === entry ? {...upload, progress} : upload));&#10;                    console.log(&quot;Upload progress:&quot;, progress);&#10;                }, async () =&gt;&#10;                {&#10;                    // On Canceled&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.entry !== entry));&#10;                    await refresh();&#10;                }&#10;            );&#10;            promises.push(promise);&#10;        }&#10;        await Promise.all(promises);&#10;        await refresh();&#10;        setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== uploadGroup));&#10;    }, [setFileUploadEntries, fileUploadEntries, path]);&#10;&#10;    const refresh = useCallback(async () =&gt;&#10;    {&#10;        scrollToTop();&#10;        setIsLoading(true);&#10;        const data = await getEntries(path);&#10;        data.entries = data.entries.sort((a, b) =&gt;&#10;        {&#10;            if (a.is_dir &amp;&amp; !b.is_dir) return -1; // Directories first&#10;            if (!a.is_dir &amp;&amp; b.is_dir) return 1; // Files after directories&#10;            return a.filename.localeCompare(b.filename); // Sort alphabetically&#10;        });&#10;        setData(data);&#10;        setIsLoading(false);&#10;        setSelectedEntries([]);&#10;        setContextMenuOptions({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    }, [path, data]);&#10;&#10;    const renameSelectedEntry = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!renamingEntry || newName.trim() === &quot;&quot; || newName === renamingEntry.filename)&#10;        {&#10;            setRenamingEntry(undefined);&#10;            return;&#10;        }&#10;&#10;        let newPath = `${path}/${newName}`;&#10;        try&#10;        {&#10;            await renameEntry(renamingEntry.path, newPath);&#10;            setRenamingEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Rename Failed&quot;,&#10;                body: &quot;An error occurred while renaming the entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [renamingEntry, path]);&#10;&#10;    const startEntryCreation = useCallback(async (directory: boolean) =&gt;&#10;    {&#10;        scrollToTop();&#10;        let filename = `New ${directory ? &quot;Directory&quot; : &quot;File.txt&quot;}`;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === filename))&#10;        {&#10;            index++;&#10;            filename = `New ${directory ? &quot;Directory&quot; : &quot;File&quot;} (${index}).txt`;&#10;        }&#10;        let entry = {filename, path, is_dir: directory, size: 0, file_type: directory ? &quot;Directory&quot; : &quot;File&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewItemCreationEntry(entry);&#10;    }, [data, path]);&#10;&#10;    const completeEntryCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!newItemCreationEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            await createEntry(newName, path, newItemCreationEntry.is_dir);&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Creation Failed&quot;,&#10;                body: &quot;An error occurred while create new entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [data, path]);&#10;&#10;    const startArchiveCreation = useCallback(async () =&gt;&#10;    {&#10;        setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        scrollToTop();&#10;        let filename = &quot;New Archive&quot;;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === `${filename}.zip`))&#10;        {&#10;            index++;&#10;            filename = `New Archive (${index})`;&#10;        }&#10;        let entry = {filename, path, is_dir: false, size: 0, file_type: &quot;Archive&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewArchiveEntry({entry, progress: 0, files: selectedEntries.map(entry =&gt; entry.path), isUploading: false, operationType: 'archive'});&#10;    }, [path, data, selectedEntries]);&#10;&#10;    const completeArchiveCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        setNewArchiveEntry(prev =&gt; prev ? {...prev, isUploading: true, operationType: 'archive'} : undefined);&#10;        if (!newArchiveEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewArchiveEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            archiveFiles(`${newName}.zip`, newArchiveEntry.files, path, progress =&gt;&#10;            {&#10;                setNewArchiveEntry(prev =&gt; prev ? {...prev, progress} : undefined);&#10;                console.log(&quot;Archive progress:&quot;, progress);&#10;            }, async () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;                await refresh();&#10;            }, error =&gt;&#10;            {&#10;                open({&#10;                    title: &quot;Archive Creation Failed&quot;,&#10;                    body: `An error occurred while creating the archive: ${error}`,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;                console.error(&quot;Failed to create archive:&quot;, error);&#10;                setNewArchiveEntry(undefined);&#10;            }, () =&gt; {&#10;                setNewArchiveEntry(undefined);&#10;            });&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to create archive:&quot;, error);&#10;            await open({&#10;                title: &quot;Archive Creation Failed&quot;,&#10;                body: &quot;An error occurred while creating the archive. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            setNewArchiveEntry(undefined);&#10;        }&#10;    }, [data, path, newArchiveEntry]);&#10;&#10;    const handleExtract = useCallback(async (entry: FilesystemEntry, outputPath?: string) =&gt; {&#10;        scrollToTop();&#10;&#10;        // Determine output path - either provided or current directory&#10;        const extractPath = outputPath || path;&#10;&#10;        // Create a temporary entry to show progress&#10;        const extractEntry: FilesystemEntry = {&#10;            filename: `Extracting ${entry.filename}...`,&#10;            path: `${path}/extracting-${entry.filename}`,&#10;            is_dir: false,&#10;            size: 0,&#10;            file_type: &quot;Extracting&quot;&#10;        };&#10;&#10;        const progressEntry: UploadProgress = {&#10;            entry: extractEntry,&#10;            progress: 0,&#10;            files: [entry.path],&#10;            isUploading: true,&#10;            operationType: 'extract',&#10;            filesProcessed: 0,&#10;            totalFiles: 0&#10;        };&#10;&#10;        setFileUploadEntries(prev =&gt; [...prev, progressEntry]);&#10;&#10;        try {&#10;            extractArchive(&#10;                entry.path,&#10;                extractPath,&#10;                (progress, filesProcessed, totalFiles) =&gt; {&#10;                    setFileUploadEntries(prev =&gt;&#10;                        prev.map(upload =&gt;&#10;                            upload === progressEntry&#10;                                ? {...upload, progress, filesProcessed, totalFiles}&#10;                                : upload&#10;                        )&#10;                    );&#10;                    console.log(&quot;Extract progress:&quot;, progress, &quot;Files:&quot;, filesProcessed, &quot;/&quot;, totalFiles);&#10;                },&#10;                async () =&gt; {&#10;                    // Success&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload !== progressEntry));&#10;                    await refresh();&#10;                },&#10;                (error) =&gt; {&#10;                    // Error&#10;                    console.error(&quot;Failed to extract archive:&quot;, error);&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload !== progressEntry));&#10;                    open({&#10;                        title: &quot;Extract Failed&quot;,&#10;                        body: `An error occurred while extracting the archive: ${error}`,&#10;                        responseType: MessageResponseType.Close,&#10;                        severity: &quot;danger&quot;&#10;                    });&#10;                },&#10;                () =&gt; {&#10;                    // Cancelled&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload !== progressEntry));&#10;                }&#10;            );&#10;        } catch (error) {&#10;            console.error(&quot;Failed to start extract:&quot;, error);&#10;            setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload !== progressEntry));&#10;            await open({&#10;                title: &quot;Extract Failed&quot;,&#10;                body: &quot;An error occurred while starting the extraction. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [path, extractArchive, open, refresh]);&#10;&#10;    const handleKeyDown = useCallback(async (e: KeyboardEvent&lt;HTMLTableElement&gt;) =&gt;&#10;    {&#10;        if (renamingEntry !== undefined)&#10;        {&#10;            e.preventDefault();&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Escape&quot;)&#10;        {&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        }&#10;        if (e.key === &quot;F2&quot;)&#10;        {&#10;            // Start renaming the first selected entry&#10;            if (selectedEntries.length &gt; 0)&#10;            {&#10;                e.preventDefault();&#10;                setRenamingEntry(selectedEntries[0]);&#10;                return;&#10;            }&#10;        }&#10;&#10;        if (e.ctrlKey &amp;&amp; e.key === &quot;a&quot;)&#10;        {&#10;            // Select all entries&#10;            e.preventDefault();&#10;            setSelectedEntries(data?.entries || []);&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Delete&quot; || e.key === &quot;Backspace&quot;)&#10;        {&#10;            await deleteSelected(selectedEntries);&#10;        }&#10;    }, [renamingEntry, refresh, renameSelectedEntry, selectedEntries]);&#10;&#10;    const deleteSelected = useCallback(async (entries: FilesystemEntry[]) =&gt;&#10;    {&#10;        // Handle delete action for selected entries&#10;        if (entries.length &gt; 0)&#10;        {&#10;            let response = await open({&#10;                title: &quot;Delete Files&quot;,&#10;                body: `Are you sure you want to delete ${entries.length &gt; 1 ? `${entries.length} files` : entries[0].filename}? This action cannot be undone.`,&#10;                responseType: MessageResponseType.OkayCancel,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            if (response)&#10;            {&#10;                // Implement delete logic here&#10;                await deleteEntry(entries.map(entry =&gt; entry.path));&#10;                await refresh();&#10;            }&#10;        }&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        refresh().then();&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        $(document).on(&quot;click&quot;, e =&gt;&#10;        {&#10;            // Close context menu when clicking outside&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        }).on(&quot;blur&quot;, e =&gt;&#10;        {&#10;            // Close context menu when focus is lost&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        });&#10;        $(&quot;#server-files-table&quot;).parent().on(&quot;scroll&quot;, () =&gt;&#10;        {&#10;            // Close context menu when scrolling&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        });&#10;        return () =&gt;&#10;        {&#10;            $(document).off(&quot;click&quot;);&#10;            $(document).off(&quot;blur&quot;);&#10;            $(&quot;#server-files-table&quot;).parent().off(&quot;scroll&quot;);&#10;        };&#10;    }, []);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; isEditingFile)&#10;        {&#10;            if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;            setSelectedFileContents(&quot;&quot;);&#10;            setNeedsToSave(false);&#10;&#10;            // Load file contents for single text file selection&#10;            getFileContents(selectedEntries[0].path).then(async contents =&gt;&#10;            {&#10;                setSelectedFileContents(contents);&#10;                setIsEditingFile(true);&#10;            }).catch(error =&gt;&#10;            {&#10;                console.error(&quot;Failed to load file contents:&quot;, error);&#10;                open({&#10;                    title: &quot;Load File Failed&quot;,&#10;                    body: &quot;An error occurred while loading the file contents. Please try again.&quot;,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;            });&#10;        } else&#10;        {&#10;            // Reset file contents when selection changes or multiple files are selected&#10;            setSelectedFileContents(&quot;&quot;);&#10;            // setIsEditingFile(false);&#10;        }&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    const handleEditorMount = useCallback((editor: any, monaco: any) =&gt;&#10;    {&#10;        editorRef.current = editor;&#10;        monacoRef.current = monaco;&#10;&#10;        // Define theme first&#10;        defineObsidianTheme(monaco);&#10;&#10;        // Register the Minecraft properties language&#10;        registerMinecraftPropertiesLanguage(monaco);&#10;&#10;        // Set the theme after it's defined&#10;        monaco.editor.setTheme(&quot;obsidian-editor-theme&quot;);&#10;&#10;        // Override the toggle line comment keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyC,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.commentLine&quot;, {});&#10;            }&#10;        );&#10;&#10;        // Optional: Disable the original Ctrl+/ keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.Slash,&#10;            () =&gt;&#10;            {&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyF,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.formatDocument&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,&#10;            async () =&gt;&#10;            {&#10;                console.log(&quot;Saving content from editor&quot;);&#10;                await saveContent();&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.deleteLines&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.duplicateSelection&quot;, {});&#10;            }&#10;        );&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    return (&#10;        &lt;div className={&#10;            cn(&#10;                &quot;flex flex-row gap-2 bg-default-50 overflow-x-hidden border-2 border-default-500/10&quot;&#10;            )&#10;        }&gt;&#10;            &lt;div&#10;                id={&quot;server-file-browser&quot;}&#10;                className={&#10;                    cn(&#10;                        &quot;flex flex-col gap-2 p-4 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative grow min-w-[300px]&quot;&#10;                    )&#10;                }&#10;                onDragStart={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnd={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnter={() =&gt; setIsDraggingOver(true)}&#10;                onDragExit={() =&gt; setIsDraggingOver(false)}&#10;                onDragOver={e =&gt; e.preventDefault()}&#10;                onDrop={async e =&gt;&#10;                {&#10;                    e.preventDefault();&#10;                    console.log(&quot;Files dropped:&quot;, e.dataTransfer.files);&#10;                    setIsDraggingOver(false);&#10;                    await upload([...e.dataTransfer.files]);&#10;                }}&#10;                data-dragging-over={isDraggingOver}&#10;            &gt;&#10;                {isDraggingOver &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 z-30 border-dotted border-4 border-primary bg-background/90 flex items-center justify-center&quot;&gt;&#10;                        &lt;span className=&quot;font-minecraft-body text-4xl&quot;&gt;Drop Files to Upload&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div className={&quot;flex flex-row justify-between items-center&quot;}&gt;&#10;                    &lt;FileTableBreadcrumbs onNavigate={setPath} paths={path.split(&quot;/&quot;).filter(p =&gt; p.trim() !== &quot;&quot;)}/&gt;&#10;                    &lt;ButtonGroup radius={&quot;none&quot;} variant={&quot;flat&quot;}&gt;&#10;                        &lt;Tooltip content={&quot;New File&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(false)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:file-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;New Directory&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(true)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:folder-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Toggle File Editor&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; setIsEditingFile(prev =&gt; !prev)} color={isEditingFile ? &quot;primary&quot; : &quot;default&quot;}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:notes&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Refresh Files&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} isDisabled={isLoading} onPress={refresh}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:repeat&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                    &lt;/ButtonGroup&gt;&#10;                &lt;/div&gt;&#10;                &lt;ErrorBoundary&gt;&#10;                    &lt;Table&#10;                        id={&quot;server-files-table&quot;}&#10;                        removeWrapper&#10;                        radius={&quot;none&quot;}&#10;                        className={cn(&quot;font-minecraft-body overflow-y-auto&quot;)}&#10;                        fullWidth&#10;                        color={&quot;primary&quot;}&#10;                        aria-label={&quot;Server Files&quot;}&#10;                        selectionMode={&quot;multiple&quot;}&#10;                        selectionBehavior={&quot;replace&quot;}&#10;                        showSelectionCheckboxes={false}&#10;                        isHeaderSticky&#10;                        classNames={{&#10;                            tr: &quot;!rounded-none&quot;,&#10;                            th: &quot;backdrop-blur-md bg-default-50/50 !rounded-none&quot;&#10;                        }}&#10;                        selectedKeys={selectedEntries.map(entry =&gt; entry.filename)}&#10;                        onSelectionChange={keys =&gt;&#10;                        {&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                            const selected = [...keys].map(key =&gt; data?.entries.find(entry =&gt; entry.filename === key)).filter(Boolean) as FilesystemEntry[];&#10;                            setSelectedEntries(selected);&#10;                        }}&#10;                        isKeyboardNavigationDisabled={true}&#10;                        onKeyDown={handleKeyDown}&#10;                    &gt;&#10;                        &lt;TableHeader&gt;&#10;                            &lt;TableColumn&gt;Name&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Type&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Size&lt;/TableColumn&gt;&#10;                            &lt;TableColumn width={48} hideHeader hidden={isEditingFile}&gt;Action&lt;/TableColumn&gt;&#10;                        &lt;/TableHeader&gt;&#10;                        &lt;TableBody&gt;&#10;                            {isLoading ? Array.from({length: 5}, (_, i) =&gt; (&#10;                                &lt;TableRow key={`skeleton-${i}`}&gt;&#10;                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-8&quot;}/&gt;&#10;                                        &lt;Skeleton className={&quot;w-32 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-24 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-16 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                &lt;/TableRow&gt;&#10;                            )) : (&#10;                                &lt;&gt;&#10;                                    {data?.entries?.length === 0 &amp;&amp; fileUploadEntries.length === 0 ? (&#10;                                        &lt;TableRow&gt;&#10;                                            &lt;TableCell colSpan={4} className=&quot;text-center text-gray-500&quot;&gt;&#10;                                                This directory is empty&#10;                                            &lt;/TableCell&gt;&#10;                                        &lt;/TableRow&gt;&#10;                                    ) : (&#10;                                        &lt;&gt;&#10;                                            {fileUploadEntries.map(upload =&gt; (&#10;                                                &lt;TableRow key={`upload-${upload.entry.filename}`}&gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        &lt;FileEntryIcon entry={upload.entry}/&gt; {upload.entry.filename}&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;{upload.entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;&#10;                                                        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;&#10;                                                            &lt;Progress&#10;                                                                minValue={0}&#10;                                                                maxValue={upload.operationType === 'upload' ? 1 : 100}&#10;                                                                value={upload.progress}&#10;                                                                size={&quot;sm&quot;}&#10;                                                            /&gt;&#10;                                                            {upload.operationType === 'extract' &amp;&amp; upload.totalFiles &amp;&amp; upload.totalFiles &gt; 0 &amp;&amp; (&#10;                                                                &lt;span className=&quot;text-xs text-gray-400&quot;&gt;&#10;                                                                    {upload.filesProcessed || 0}/{upload.totalFiles} files&#10;                                                                &lt;/span&gt;&#10;                                                            )}&#10;                                                        &lt;/div&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell&gt;&#10;                                                        &lt;&gt;&lt;/&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            ))}&#10;                                            {data?.entries.map(entry =&gt;&#10;                                                &lt;TableRow&#10;                                                    key={entry.filename}&#10;                                                    onContextMenu={e =&gt;&#10;                                                    {&#10;                                                        e.preventDefault();&#10;                                                        setContextMenuOptions({&#10;                                                            entry: selectedEntries.length &gt; 1 ? selectedEntries : entry,&#10;                                                            x: e.clientX - 30,&#10;                                                            y: e.clientY - 50,&#10;                                                            isOpen: true&#10;                                                        });&#10;                                                    }}&#10;                                                    data-selected={contextMenuOptions.entry === entry &amp;&amp; contextMenuOptions.isOpen}&#10;                                                    className={&quot;data-[selected=true]:opacity-50 data-[selected=true]:bg-white/10&quot;}&#10;                                                    onDoubleClick={() =&gt;&#10;                                                    {&#10;                                                        if (entry.is_dir &amp;&amp; !renamingEntry &amp;&amp; !newItemCreationEntry)&#10;                                                        {&#10;                                                            setPath(prev =&gt; prev ? `${prev}/${entry.filename}` : entry.filename);&#10;                                                        }&#10;                                                    }}&#10;                                                &gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        {renamingEntry === entry ?&#10;                                                            &lt;Input&#10;                                                                startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                defaultValue={entry.filename}&#10;                                                                autoFocus&#10;                                                                onBlur={e =&gt; renameSelectedEntry(e.currentTarget.value)}&#10;                                                                onKeyDown={async e =&gt;&#10;                                                                {&#10;                                                                    if (e.key === &quot;Enter&quot;) await renameSelectedEntry(e.currentTarget.value);&#10;                                                                }}&#10;                                                                radius={&quot;none&quot;}&#10;                                                                className={&quot;font-minecraft-body&quot;}&#10;                                                            /&gt; :&#10;                                                            newItemCreationEntry === entry ?&#10;                                                                &lt;Input&#10;                                                                    startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                    defaultValue={entry.filename}&#10;                                                                    autoFocus&#10;                                                                    onBlur={e =&gt; completeEntryCreation(e.currentTarget.value)}&#10;                                                                    onKeyDown={async e =&gt;&#10;                                                                    {&#10;                                                                        if (e.key === &quot;Enter&quot;) await completeEntryCreation(e.currentTarget.value);&#10;                                                                    }}&#10;                                                                    radius={&quot;none&quot;}&#10;                                                                    className={&quot;font-minecraft-body&quot;}&#10;                                                                /&gt;&#10;                                                                : (newArchiveEntry?.entry === entry &amp;&amp; !newArchiveEntry.isUploading) ?&#10;                                                                    &lt;Input&#10;                                                                        startContent={&lt;FileEntryIcon entry={{filename: &quot;.zip&quot;} as FilesystemEntry}/&gt;}&#10;                                                                        defaultValue={entry.filename}&#10;                                                                        autoFocus&#10;                                                                        onBlur={e =&gt; completeArchiveCreation(e.currentTarget.value)}&#10;                                                                        onKeyDown={async e =&gt;&#10;                                                                        {&#10;                                                                            if (e.key === &quot;Enter&quot;) await completeArchiveCreation(e.currentTarget.value);&#10;                                                                        }}&#10;                                                                        radius={&quot;none&quot;}&#10;                                                                        className={&quot;font-minecraft-body&quot;}&#10;                                                                        endContent={&lt;Chip&gt;.zip&lt;/Chip&gt;}&#10;                                                                    /&gt;&#10;                                                                    :&#10;                                                                    &lt;&gt;&lt;FileEntryIcon entry={entry}/&gt; {entry.filename}&lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;{entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        {entry === newArchiveEntry?.entry ?&#10;                                                            &lt;&gt;&#10;                                                                &lt;Progress&#10;                                                                    minValue={0}&#10;                                                                    maxValue={100}&#10;                                                                    value={newArchiveEntry.progress}&#10;                                                                    size={&quot;sm&quot;}&#10;                                                                /&gt;&#10;                                                            &lt;/&gt;&#10;                                                            :&#10;                                                            &lt;&gt;&#10;                                                                {entry.is_dir ? &quot;-&quot; : Math.convertToByteString(entry.size)}&#10;                                                            &lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        &lt;Button&#10;                                                            isIconOnly&#10;                                                            radius={&quot;none&quot;}&#10;                                                            variant={&quot;light&quot;}&#10;                                                            onPress={e =&gt;&#10;                                                            {&#10;                                                                let position = $(e.target).offset();&#10;                                                                if (!position) return;&#10;                                                                setContextMenuOptions({&#10;                                                                    entry,&#10;                                                                    x: position.left - 264,&#10;                                                                    y: position.top,&#10;                                                                    isOpen: true&#10;                                                                });&#10;                                                            }}&#10;                                                        &gt;&#10;                                                            &lt;Icon icon={&quot;pixelarticons:more-horizontal&quot;}/&gt;&#10;                                                        &lt;/Button&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            )}&#10;                                        &lt;/&gt;&#10;                                    )}&#10;                                &lt;/&gt;&#10;                            )}&#10;                        &lt;/TableBody&gt;&#10;                    &lt;/Table&gt;&#10;                &lt;/ErrorBoundary&gt;&#10;                {(!isEditingFile || selectedEntries.length !== 1) ? (&#10;                    &lt;RowContextMenu&#10;                        {...contextMenuOptions}&#10;                        onRename={setRenamingEntry}&#10;                        onDelete={deleteSelected}&#10;                        onArchive={startArchiveCreation}&#10;                        onExtract={handleExtract}&#10;                        onEdit={() =&gt;&#10;                        {&#10;                            setIsEditingFile(true);&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                        }}&#10;                        onClose={() =&gt; setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}))}&#10;                    /&gt;&#10;                ) : null}&#10;            &lt;/div&gt;&#10;            &lt;motion.div&#10;                id={&quot;server-file-editor&quot;}&#10;                ref={editorWrapperRef}&#10;                className={&quot;max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative&quot;}&#10;                initial={{opacity: 0, width: 0}}&#10;                animate={{&#10;                    opacity: isEditingFile &amp;&amp; selectedEntries.length === 1 ? 1 : 0,&#10;                    width: isEditingFile &amp;&amp; selectedEntries.length === 1 ? `${editorWidth}px` : &quot;0&quot;&#10;                }}&#10;                exit={{opacity: 0, width: 0}}&#10;                transition={{duration: isDragging ? 0 : 0.3, ease: &quot;easeInOut&quot;}}&#10;                data-editing-file={isEditingFile &amp;&amp; selectedEntries.length === 1}&#10;            &gt;&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;Editor&#10;                        className={&quot;w-full h-full&quot;}&#10;                        theme={&quot;obsidian-editor-theme&quot;}&#10;                        value={isEditingFile ? selectedFileContents : &quot;&quot;}&#10;                        language={getMonacoLanguage(selectedEntries[0]?.path ?? &quot;&quot;) ?? &quot;auto&quot;}&#10;                        onMount={handleEditorMount}&#10;                        width={`${editorWidth}px`}&#10;                        onChange={async content =&gt;&#10;                        {&#10;                            console.log(&quot;Editor content changed:&quot;, content);&#10;                            newContentRef.current = content ?? &quot;&quot;;&#10;                            setNeedsToSave(true);&#10;                            await reboundSaveContent();&#10;                        }}&#10;                        options={{&#10;                            fontSize: 14,&#10;                            minimap: {enabled: false},&#10;                            lineNumbers: &quot;on&quot;,&#10;                            scrollBeyondLastLine: false,&#10;                            automaticLayout: true,&#10;                            wordWrap: &quot;on&quot;,&#10;                            tabSize: 2,&#10;                            contextmenu: false,&#10;                            autoClosingBrackets: &quot;always&quot;,&#10;                            autoClosingOvertype: &quot;always&quot;,&#10;                            autoClosingQuotes: &quot;always&quot;,&#10;                            quickSuggestions: {&#10;                                other: true,&#10;                                comments: false,&#10;                                strings: true&#10;                            },&#10;                            suggestOnTriggerCharacters: true,&#10;                            acceptSuggestionOnEnter: &quot;on&quot;,&#10;                            tabCompletion: &quot;on&quot;,&#10;                            wordBasedSuggestions: &quot;matchingDocuments&quot;,&#10;                            parameterHints: {&#10;                                enabled: true,&#10;                                cycle: true&#10;                            },&#10;                            formatOnPaste: true,&#10;                            formatOnType: true,&#10;                            matchBrackets: &quot;always&quot;,&#10;                            autoIndent: &quot;full&quot;,&#10;                            folding: true,&#10;                            foldingStrategy: &quot;indentation&quot;,&#10;                            suggest: {&#10;                                showKeywords: true,&#10;                                showSnippets: true,&#10;                                showFunctions: true,&#10;                                showConstructors: true,&#10;                                showFields: true,&#10;                                showVariables: true,&#10;                                showClasses: true,&#10;                                showStructs: true,&#10;                                showInterfaces: true,&#10;                                showModules: true,&#10;                                showProperties: true,&#10;                                showEvents: true,&#10;                                showOperators: true,&#10;                                showUnits: true,&#10;                                showValues: true,&#10;                                showConstants: true,&#10;                                showEnums: true,&#10;                                showEnumMembers: true,&#10;                                showColors: true,&#10;                                showFiles: true,&#10;                                showReferences: true,&#10;                                showFolders: true,&#10;                                showTypeParameters: true,&#10;                                showUsers: true,&#10;                                showIssues: true&#10;                            }&#10;                        }}&#10;                    /&gt;&#10;                ) : selectedEntries.length === 1 &amp;&amp; !isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;div className=&quot;flex items-center justify-center h-full&quot;&gt;&#10;                        &lt;span className=&quot;text-gray-500 font-minecraft-body&quot;&gt;Select a text file to edit&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                ) : null}&#10;&#10;                {/* Resize Handle */}&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; (&#10;                    &lt;div&#10;                        className={&#10;                            cn(&#10;                                &quot;w-[8px] h-full bg-transparent transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none hover:bg-primary hover:opacity-50&quot;&#10;                            )&#10;                        }&#10;                        data-dragging={isDragging}&#10;                        onMouseDown={(e) =&gt;&#10;                        {&#10;                            e.preventDefault();&#10;                            setIsDragging(true);&#10;&#10;                            const startX = e.clientX;&#10;                            const startWidth = editorWidth;&#10;                            const parentWidth = editorWrapperRef.current?.parentElement?.clientWidth;&#10;&#10;                            const onMouseMove = (moveEvent: MouseEvent) =&gt;&#10;                            {&#10;                                moveEvent.preventDefault();&#10;                                const newWidth = startWidth - (moveEvent.clientX - startX);&#10;                                if (!parentWidth) return;&#10;                                setEditorWidth(Math.min(parentWidth - 300, Math.max(300, newWidth)));&#10;                            };&#10;&#10;                            const onMouseUp = (mouseEvent: MouseEvent) =&gt;&#10;                            {&#10;                                mouseEvent.preventDefault();&#10;                                setIsDragging(false);&#10;&#10;                                const newWidth = Math.max(300, startWidth - (mouseEvent.clientX - startX));&#10;                                localStorage.setItem(&quot;editor-width&quot;, newWidth.toString());&#10;                                document.removeEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                                document.removeEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                            };&#10;&#10;                            document.addEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                            document.addEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                        }}&#10;                    &gt;&#10;                        &lt;span&#10;                            className={&#10;                                cn(&#10;                                    &quot;w-px h-full bg-white opacity-20 transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none&quot;,&#10;                                    &quot;hover:opacity-50 hover:bg-primary&quot;,&#10;                                    &quot;data-[dragging=true]:opacity-50 data-[dragging=true]:bg-primary&quot;&#10;                                )&#10;                            }&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/motion.div&gt;&#10;&#10;            {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; (&#10;                &lt;div className={&quot;absolute bottom-8 right-8 z-50&quot;}&gt;&#10;                    &lt;Tooltip content={&quot;Save Content&quot;}&gt;&#10;                        &lt;Button radius={&quot;none&quot;} onPress={saveContent} isIconOnly isDisabled={!needsToSave} color={needsToSave ? &quot;primary&quot; : &quot;default&quot;} size={&quot;lg&quot;}&gt;&#10;                            &lt;Icon icon={&quot;pixelarticons:save&quot;}/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Overlay to prevent clicks during dragging */}&#10;            &lt;AnimatePresence&gt;&#10;                {isDragging &amp;&amp; (&#10;                    &lt;motion.div&#10;                        className=&quot;fixed inset-0 z-50 cursor-ew-resize select-none pointer-events-auto bg-primary/10&quot;&#10;                        initial={{opacity: 0}}&#10;                        animate={{opacity: 1}}&#10;                        exit={{opacity: 0}}&#10;                        transition={{duration: 0.2}}&#10;                        onClick={(e) =&gt; e.stopPropagation()}&#10;                    /&gt;&#10;                )}&#10;            &lt;/AnimatePresence&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import {Button, ButtonGroup, Chip, cn, Input, Progress, Skeleton, Table, TableBody, TableCell, TableColumn, TableHeader, TableRow} from &quot;@heroui/react&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import {KeyboardEvent, useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {FilesystemData, FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import &quot;../../../../ts/math-ext.ts&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {ContextMenuOptions, RowContextMenu} from &quot;./RowContextMenu.tsx&quot;;&#10;import {useMessage} from &quot;../../../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../../../MessageModal.tsx&quot;;&#10;import {FileTableBreadcrumbs} from &quot;./FileTableBreadcrumbs.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {ErrorBoundary} from &quot;../../../ErrorBoundry.tsx&quot;;&#10;import {FileEntryIcon} from &quot;./FileEntryIcon.tsx&quot;;&#10;import {Editor} from &quot;@monaco-editor/react&quot;;&#10;import {getMonacoLanguage, isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {registerMinecraftPropertiesLanguage} from &quot;../../../../ts/minecraft-properties-language.ts&quot;;&#10;import {motion, AnimatePresence} from &quot;framer-motion&quot;;&#10;&#10;// Define the theme outside of the component&#10;const defineObsidianTheme = (monaco: any) =&gt;&#10;{&#10;    monaco.editor.defineTheme(&quot;obsidian-editor-theme&quot;, {&#10;        base: &quot;vs-dark&quot;,&#10;        inherit: true,&#10;        rules: [&#10;            {token: &quot;key&quot;, foreground: &quot;#47ebb4&quot;},&#10;            {token: &quot;value&quot;, foreground: &quot;#CE9178&quot;},&#10;            {token: &quot;comment&quot;, foreground: &quot;#57718e&quot;, fontStyle: &quot;italic&quot;},&#10;            {token: &quot;operator&quot;, foreground: &quot;#0aa370&quot;}&#10;        ],&#10;        colors: {&#10;            &quot;editor.background&quot;: &quot;#0b0b0e&quot;&#10;        }&#10;    });&#10;};&#10;&#10;type UploadProgress = {&#10;    entry: FilesystemEntry;&#10;    progress: number;&#10;    files: string[]&#10;    isUploading: boolean;&#10;    uploadGroup?: string;&#10;    filesProcessed?: number;&#10;    totalFiles?: number;&#10;    operationType: 'upload' | 'archive' | 'extract';&#10;}&#10;&#10;export function ServerFiles()&#10;{&#10;    const {getEntries, renameEntry, createEntry, deleteEntry, uploadFile, archiveFiles, extractArchive, getFileContents, setFileContents} = useServer();&#10;    const {open} = useMessage();&#10;    const [path, setPath] = useState(&quot;&quot;);&#10;    const [data, setData] = useState&lt;FilesystemData&gt;();&#10;    const [selectedEntries, setSelectedEntries] = useState&lt;FilesystemEntry[]&gt;([]);&#10;    const [contextMenuOptions, setContextMenuOptions] = useState&lt;ContextMenuOptions&gt;({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [renamingEntry, setRenamingEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newItemCreationEntry, setNewItemCreationEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newArchiveEntry, setNewArchiveEntry] = useState&lt;UploadProgress | undefined&gt;(undefined);&#10;    const [fileUploadEntries, setFileUploadEntries] = useState&lt;UploadProgress[]&gt;([]);&#10;    const [isDraggingOver, setIsDraggingOver] = useState(false);&#10;    const [isEditingFile, setIsEditingFile] = useState(false);&#10;    const [selectedFileContents, setSelectedFileContents] = useState(&quot;&quot;);&#10;    const [isDragging, setIsDragging] = useState(false);&#10;    const [editorWidth, setEditorWidth] = useState(() =&gt;&#10;    {&#10;        // Load saved width from localStorage or use default&#10;        const savedWidth = localStorage.getItem(&quot;editor-width&quot;);&#10;        return savedWidth ? parseInt(savedWidth, 10) : 400;&#10;    });&#10;    const editorRef = useRef&lt;any&gt;(null);&#10;    const monacoRef = useRef&lt;any&gt;(null);&#10;    const editorWrapperRef = useRef&lt;HTMLDivElement&gt;(null);&#10;    const editorSaveTimerRef = useRef&lt;number | undefined&gt;(undefined);&#10;    const [needsToSave, setNeedsToSave] = useState(false);&#10;    const newContentRef = useRef&lt;string&gt;(&quot;&quot;);&#10;&#10;    const selectedEntriesRef = useRef&lt;FilesystemEntry[]&gt;([]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        selectedEntriesRef.current = selectedEntries;&#10;    }, [selectedEntries]);&#10;&#10;    const scrollToTop = useCallback(() =&gt;&#10;    {&#10;        $(&quot;#server-files-table&quot;).parent().scrollTop(0);&#10;    }, [path]);&#10;&#10;    const saveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        const file = currentSelectedEntries[0]?.path;&#10;&#10;        console.log(&quot;Attempting to save content:&quot;, newContentRef, &quot;Needs to save:&quot;, needsToSave, &quot;File:&quot;, currentSelectedEntries);&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        setNeedsToSave(false);&#10;&#10;        try&#10;        {&#10;            if (!file || !newContentRef.current)&#10;            {&#10;                console.warn(&quot;No file selected or content is empty, skipping save.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Save the content to the file&#10;            console.log(&quot;Saving file:&quot;, file, newContentRef.current);&#10;            await setFileContents(file, newContentRef.current);&#10;            newContentRef.current = &quot;&quot;;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save file:&quot;, error);&#10;            await open({&#10;                title: &quot;Save File Failed&quot;,&#10;                body: &quot;An error occurred while saving the file. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [newContentRef, editorSaveTimerRef, needsToSave, open]);&#10;&#10;    const reboundSaveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        if (!currentSelectedEntries || currentSelectedEntries.length !== 1 || !isTextFile(currentSelectedEntries[0].path)) return;&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        editorSaveTimerRef.current = setTimeout(async () =&gt;&#10;        {&#10;            await saveContent();&#10;        }, 5000);&#10;    }, [saveContent]);&#10;&#10;    const upload = useCallback(async (files: File[]) =&gt;&#10;    {&#10;        let uploadGroup = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);&#10;        let promises = [];&#10;        for (let file of files)&#10;        {&#10;            let entry = {filename: file.name, path, is_dir: false, size: file.size, file_type: file.type, operationType: 'upload'} as FilesystemEntry;&#10;            setFileUploadEntries(prev =&gt; [...prev, {entry, progress: 0, files: [file.name], isUploading: true, uploadGroup, operationType: 'upload'}]);&#10;            let totalSize = file.size;&#10;            const {promise} = await uploadFile(file, entry.path, async bytes =&gt;&#10;                {&#10;                    let progress = bytes / totalSize;&#10;                    setFileUploadEntries(prev =&gt; prev.map(upload =&gt; upload.entry === entry ? {...upload, progress} : upload));&#10;                    console.log(&quot;Upload progress:&quot;, progress);&#10;                }, async () =&gt;&#10;                {&#10;                    // On Canceled&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.entry !== entry));&#10;                    await refresh();&#10;                }&#10;            );&#10;            promises.push(promise);&#10;        }&#10;        await Promise.all(promises);&#10;        await refresh();&#10;        setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== uploadGroup));&#10;    }, [setFileUploadEntries, fileUploadEntries, path]);&#10;&#10;    const refresh = useCallback(async () =&gt;&#10;    {&#10;        scrollToTop();&#10;        setIsLoading(true);&#10;        const data = await getEntries(path);&#10;        data.entries = data.entries.sort((a, b) =&gt;&#10;        {&#10;            if (a.is_dir &amp;&amp; !b.is_dir) return -1; // Directories first&#10;            if (!a.is_dir &amp;&amp; b.is_dir) return 1; // Files after directories&#10;            return a.filename.localeCompare(b.filename); // Sort alphabetically&#10;        });&#10;        setData(data);&#10;        setIsLoading(false);&#10;        setSelectedEntries([]);&#10;        setContextMenuOptions({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    }, [path, data]);&#10;&#10;    const renameSelectedEntry = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!renamingEntry || newName.trim() === &quot;&quot; || newName === renamingEntry.filename)&#10;        {&#10;            setRenamingEntry(undefined);&#10;            return;&#10;        }&#10;&#10;        let newPath = `${path}/${newName}`;&#10;        try&#10;        {&#10;            await renameEntry(renamingEntry.path, newPath);&#10;            setRenamingEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Rename Failed&quot;,&#10;                body: &quot;An error occurred while renaming the entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [renamingEntry, path]);&#10;&#10;    const startEntryCreation = useCallback(async (directory: boolean) =&gt;&#10;    {&#10;        scrollToTop();&#10;        let filename = `New ${directory ? &quot;Directory&quot; : &quot;File.txt&quot;}`;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === filename))&#10;        {&#10;            index++;&#10;            filename = `New ${directory ? &quot;Directory&quot; : &quot;File&quot;} (${index}).txt`;&#10;        }&#10;        let entry = {filename, path, is_dir: directory, size: 0, file_type: directory ? &quot;Directory&quot; : &quot;File&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewItemCreationEntry(entry);&#10;    }, [data, path]);&#10;&#10;    const completeEntryCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!newItemCreationEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            await createEntry(newName, path, newItemCreationEntry.is_dir);&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Creation Failed&quot;,&#10;                body: &quot;An error occurred while create new entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [data, path]);&#10;&#10;    const startArchiveCreation = useCallback(async () =&gt;&#10;    {&#10;        setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        scrollToTop();&#10;        let filename = &quot;New Archive&quot;;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === `${filename}.zip`))&#10;        {&#10;            index++;&#10;            filename = `New Archive (${index})`;&#10;        }&#10;        let entry = {filename, path, is_dir: false, size: 0, file_type: &quot;Archive&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewArchiveEntry({entry, progress: 0, files: selectedEntries.map(entry =&gt; entry.path), isUploading: false, operationType: 'archive'});&#10;    }, [path, data, selectedEntries]);&#10;&#10;    const completeArchiveCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        setNewArchiveEntry(prev =&gt; prev ? {...prev, isUploading: true, operationType: 'archive'} : undefined);&#10;        if (!newArchiveEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewArchiveEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            archiveFiles(`${newName}.zip`, newArchiveEntry.files, path, progress =&gt;&#10;            {&#10;                setNewArchiveEntry(prev =&gt; prev ? {...prev, progress} : undefined);&#10;                console.log(&quot;Archive progress:&quot;, progress);&#10;            }, async () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;                await refresh();&#10;            }, error =&gt;&#10;            {&#10;                open({&#10;                    title: &quot;Archive Creation Failed&quot;,&#10;                    body: `An error occurred while creating the archive: ${error}`,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;                console.error(&quot;Failed to create archive:&quot;, error);&#10;                setNewArchiveEntry(undefined);&#10;            }, () =&gt; {&#10;                setNewArchiveEntry(undefined);&#10;            });&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to create archive:&quot;, error);&#10;            await open({&#10;                title: &quot;Archive Creation Failed&quot;,&#10;                body: &quot;An error occurred while creating the archive. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            setNewArchiveEntry(undefined);&#10;        }&#10;    }, [data, path, newArchiveEntry]);&#10;&#10;    const handleExtract = useCallback(async (entry: FilesystemEntry, outputPath?: string) =&gt; {&#10;        scrollToTop();&#10;        &#10;        // Determine output path - either provided or current directory&#10;        const extractPath = outputPath || path;&#10;        &#10;        // Create a unique ID for this extraction operation&#10;        const extractId = `extract-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;&#10;        &#10;        // Create a temporary entry to show progress&#10;        const extractEntry: FilesystemEntry = {&#10;            filename: `Extracting ${entry.filename}...`,&#10;            path: `${path}/extracting-${entry.filename}`,&#10;            is_dir: false,&#10;            size: 0,&#10;            file_type: &quot;Extracting&quot;&#10;        };&#10;        &#10;        const progressEntry: UploadProgress = {&#10;            entry: extractEntry,&#10;            progress: 0,&#10;            files: [entry.path],&#10;            isUploading: true,&#10;            operationType: 'extract',&#10;            filesProcessed: 0,&#10;            totalFiles: 0,&#10;            uploadGroup: extractId // Use the unique ID to track this specific extraction&#10;        };&#10;        &#10;        setFileUploadEntries(prev =&gt; [...prev, progressEntry]);&#10;        &#10;        // Helper function to remove the progress entry&#10;        const removeProgressEntry = () =&gt; {&#10;            setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== extractId));&#10;        };&#10;        &#10;        try {&#10;            const {cancel, trackerId} = extractArchive(&#10;                entry.path, &#10;                extractPath,&#10;                (progress, filesProcessed, totalFiles) =&gt; {&#10;                    setFileUploadEntries(prev =&gt; &#10;                        prev.map(upload =&gt; &#10;                            upload.uploadGroup === extractId &#10;                                ? {...upload, progress, filesProcessed, totalFiles} &#10;                                : upload&#10;                        )&#10;                    );&#10;                    console.log(&quot;Extract progress:&quot;, progress, &quot;Files:&quot;, filesProcessed, &quot;/&quot;, totalFiles);&#10;                },&#10;                async () =&gt; {&#10;                    // Success - remove progress entry and refresh&#10;                    console.log(&quot;Extract completed successfully, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                    await refresh();&#10;                },&#10;                (error) =&gt; {&#10;                    // Error - remove progress entry and show error&#10;                    console.error(&quot;Failed to extract archive:&quot;, error);&#10;                    removeProgressEntry();&#10;                    open({&#10;                        title: &quot;Extract Failed&quot;,&#10;                        body: `An error occurred while extracting the archive: ${error}`,&#10;                        responseType: MessageResponseType.Close,&#10;                        severity: &quot;danger&quot;&#10;                    });&#10;                },&#10;                () =&gt; {&#10;                    // Cancelled - remove progress entry&#10;                    console.log(&quot;Extract cancelled, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                }&#10;            );&#10;            &#10;            // Store the cancel function and track ID for potential future use&#10;            console.log(&quot;Extract operation started with track ID:&quot;, trackerId);&#10;            &#10;        } catch (error) {&#10;            console.error(&quot;Failed to start extract:&quot;, error);&#10;            removeProgressEntry();&#10;            await open({&#10;                title: &quot;Extract Failed&quot;,&#10;                body: &quot;An error occurred while starting the extraction. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [path, extractArchive, open, refresh]);&#10;&#10;    const handleKeyDown = useCallback(async (e: KeyboardEvent&lt;HTMLTableElement&gt;) =&gt;&#10;    {&#10;        if (renamingEntry !== undefined)&#10;        {&#10;            e.preventDefault();&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Escape&quot;)&#10;        {&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        }&#10;        if (e.key === &quot;F2&quot;)&#10;        {&#10;            // Start renaming the first selected entry&#10;            if (selectedEntries.length &gt; 0)&#10;            {&#10;                e.preventDefault();&#10;                setRenamingEntry(selectedEntries[0]);&#10;                return;&#10;            }&#10;        }&#10;&#10;        if (e.ctrlKey &amp;&amp; e.key === &quot;a&quot;)&#10;        {&#10;            // Select all entries&#10;            e.preventDefault();&#10;            setSelectedEntries(data?.entries || []);&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Delete&quot; || e.key === &quot;Backspace&quot;)&#10;        {&#10;            await deleteSelected(selectedEntries);&#10;        }&#10;    }, [renamingEntry, refresh, renameSelectedEntry, selectedEntries]);&#10;&#10;    const deleteSelected = useCallback(async (entries: FilesystemEntry[]) =&gt;&#10;    {&#10;        // Handle delete action for selected entries&#10;        if (entries.length &gt; 0)&#10;        {&#10;            let response = await open({&#10;                title: &quot;Delete Files&quot;,&#10;                body: `Are you sure you want to delete ${entries.length &gt; 1 ? `${entries.length} files` : entries[0].filename}? This action cannot be undone.`,&#10;                responseType: MessageResponseType.OkayCancel,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            if (response)&#10;            {&#10;                // Implement delete logic here&#10;                await deleteEntry(entries.map(entry =&gt; entry.path));&#10;                await refresh();&#10;            }&#10;        }&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        refresh().then();&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        $(document).on(&quot;click&quot;, e =&gt;&#10;        {&#10;            // Close context menu when clicking outside&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        }).on(&quot;blur&quot;, e =&gt;&#10;        {&#10;            // Close context menu when focus is lost&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        });&#10;        $(&quot;#server-files-table&quot;).parent().on(&quot;scroll&quot;, () =&gt;&#10;        {&#10;            // Close context menu when scrolling&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        });&#10;        return () =&gt;&#10;        {&#10;            $(document).off(&quot;click&quot;);&#10;            $(document).off(&quot;blur&quot;);&#10;            $(&quot;#server-files-table&quot;).parent().off(&quot;scroll&quot;);&#10;        };&#10;    }, []);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; isEditingFile)&#10;        {&#10;            if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;            setSelectedFileContents(&quot;&quot;);&#10;            setNeedsToSave(false);&#10;&#10;            // Load file contents for single text file selection&#10;            getFileContents(selectedEntries[0].path).then(async contents =&gt;&#10;            {&#10;                setSelectedFileContents(contents);&#10;                setIsEditingFile(true);&#10;            }).catch(error =&gt;&#10;            {&#10;                console.error(&quot;Failed to load file contents:&quot;, error);&#10;                open({&#10;                    title: &quot;Load File Failed&quot;,&#10;                    body: &quot;An error occurred while loading the file contents. Please try again.&quot;,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;            });&#10;        } else&#10;        {&#10;            // Reset file contents when selection changes or multiple files are selected&#10;            setSelectedFileContents(&quot;&quot;);&#10;            // setIsEditingFile(false);&#10;        }&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    const handleEditorMount = useCallback((editor: any, monaco: any) =&gt;&#10;    {&#10;        editorRef.current = editor;&#10;        monacoRef.current = monaco;&#10;&#10;        // Define theme first&#10;        defineObsidianTheme(monaco);&#10;&#10;        // Register the Minecraft properties language&#10;        registerMinecraftPropertiesLanguage(monaco);&#10;&#10;        // Set the theme after it's defined&#10;        monaco.editor.setTheme(&quot;obsidian-editor-theme&quot;);&#10;&#10;        // Override the toggle line comment keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyC,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.commentLine&quot;, {});&#10;            }&#10;        );&#10;&#10;        // Optional: Disable the original Ctrl+/ keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.Slash,&#10;            () =&gt;&#10;            {&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyF,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.formatDocument&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,&#10;            async () =&gt;&#10;            {&#10;                console.log(&quot;Saving content from editor&quot;);&#10;                await saveContent();&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.deleteLines&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.duplicateSelection&quot;, {});&#10;            }&#10;        );&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    return (&#10;        &lt;div className={&#10;            cn(&#10;                &quot;flex flex-row gap-2 bg-default-50 overflow-x-hidden border-2 border-default-500/10&quot;&#10;            )&#10;        }&gt;&#10;            &lt;div&#10;                id={&quot;server-file-browser&quot;}&#10;                className={&#10;                    cn(&#10;                        &quot;flex flex-col gap-2 p-4 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative grow min-w-[300px]&quot;&#10;                    )&#10;                }&#10;                onDragStart={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnd={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnter={() =&gt; setIsDraggingOver(true)}&#10;                onDragExit={() =&gt; setIsDraggingOver(false)}&#10;                onDragOver={e =&gt; e.preventDefault()}&#10;                onDrop={async e =&gt;&#10;                {&#10;                    e.preventDefault();&#10;                    console.log(&quot;Files dropped:&quot;, e.dataTransfer.files);&#10;                    setIsDraggingOver(false);&#10;                    await upload([...e.dataTransfer.files]);&#10;                }}&#10;                data-dragging-over={isDraggingOver}&#10;            &gt;&#10;                {isDraggingOver &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 z-30 border-dotted border-4 border-primary bg-background/90 flex items-center justify-center&quot;&gt;&#10;                        &lt;span className=&quot;font-minecraft-body text-4xl&quot;&gt;Drop Files to Upload&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div className={&quot;flex flex-row justify-between items-center&quot;}&gt;&#10;                    &lt;FileTableBreadcrumbs onNavigate={setPath} paths={path.split(&quot;/&quot;).filter(p =&gt; p.trim() !== &quot;&quot;)}/&gt;&#10;                    &lt;ButtonGroup radius={&quot;none&quot;} variant={&quot;flat&quot;}&gt;&#10;                        &lt;Tooltip content={&quot;New File&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(false)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:file-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;New Directory&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(true)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:folder-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Toggle File Editor&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; setIsEditingFile(prev =&gt; !prev)} color={isEditingFile ? &quot;primary&quot; : &quot;default&quot;}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:notes&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Refresh Files&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} isDisabled={isLoading} onPress={refresh}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:repeat&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                    &lt;/ButtonGroup&gt;&#10;                &lt;/div&gt;&#10;                &lt;ErrorBoundary&gt;&#10;                    &lt;Table&#10;                        id={&quot;server-files-table&quot;}&#10;                        removeWrapper&#10;                        radius={&quot;none&quot;}&#10;                        className={cn(&quot;font-minecraft-body overflow-y-auto&quot;)}&#10;                        fullWidth&#10;                        color={&quot;primary&quot;}&#10;                        aria-label={&quot;Server Files&quot;}&#10;                        selectionMode={&quot;multiple&quot;}&#10;                        selectionBehavior={&quot;replace&quot;}&#10;                        showSelectionCheckboxes={false}&#10;                        isHeaderSticky&#10;                        classNames={{&#10;                            tr: &quot;!rounded-none&quot;,&#10;                            th: &quot;backdrop-blur-md bg-default-50/50 !rounded-none&quot;&#10;                        }}&#10;                        selectedKeys={selectedEntries.map(entry =&gt; entry.filename)}&#10;                        onSelectionChange={keys =&gt;&#10;                        {&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                            const selected = [...keys].map(key =&gt; data?.entries.find(entry =&gt; entry.filename === key)).filter(Boolean) as FilesystemEntry[];&#10;                            setSelectedEntries(selected);&#10;                        }}&#10;                        isKeyboardNavigationDisabled={true}&#10;                        onKeyDown={handleKeyDown}&#10;                    &gt;&#10;                        &lt;TableHeader&gt;&#10;                            &lt;TableColumn&gt;Name&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Type&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Size&lt;/TableColumn&gt;&#10;                            &lt;TableColumn width={48} hideHeader hidden={isEditingFile}&gt;Action&lt;/TableColumn&gt;&#10;                        &lt;/TableHeader&gt;&#10;                        &lt;TableBody&gt;&#10;                            {isLoading ? Array.from({length: 5}, (_, i) =&gt; (&#10;                                &lt;TableRow key={`skeleton-${i}`}&gt;&#10;                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-8&quot;}/&gt;&#10;                                        &lt;Skeleton className={&quot;w-32 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-24 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-16 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                &lt;/TableRow&gt;&#10;                            )) : (&#10;                                &lt;&gt;&#10;                                    {data?.entries?.length === 0 &amp;&amp; fileUploadEntries.length === 0 ? (&#10;                                        &lt;TableRow&gt;&#10;                                            &lt;TableCell colSpan={4} className=&quot;text-center text-gray-500&quot;&gt;&#10;                                                This directory is empty&#10;                                            &lt;/TableCell&gt;&#10;                                        &lt;/TableRow&gt;&#10;                                    ) : (&#10;                                        &lt;&gt;&#10;                                            {fileUploadEntries.map(upload =&gt; (&#10;                                                &lt;TableRow key={`upload-${upload.entry.filename}`}&gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        &lt;FileEntryIcon entry={upload.entry}/&gt; {upload.entry.filename}&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;{upload.entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;&#10;                                                        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;&#10;                                                            &lt;Progress&#10;                                                                minValue={0}&#10;                                                                maxValue={upload.operationType === 'upload' ? 1 : 100}&#10;                                                                value={upload.progress}&#10;                                                                size={&quot;sm&quot;}&#10;                                                            /&gt;&#10;                                                            {upload.operationType === 'extract' &amp;&amp; upload.totalFiles &amp;&amp; upload.totalFiles &gt; 0 &amp;&amp; (&#10;                                                                &lt;span className=&quot;text-xs text-gray-400&quot;&gt;&#10;                                                                    {upload.filesProcessed || 0}/{upload.totalFiles} files&#10;                                                                &lt;/span&gt;&#10;                                                            )}&#10;                                                        &lt;/div&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell&gt;&#10;                                                        &lt;&gt;&lt;/&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            ))}&#10;                                            {data?.entries.map(entry =&gt;&#10;                                                &lt;TableRow&#10;                                                    key={entry.filename}&#10;                                                    onContextMenu={e =&gt;&#10;                                                    {&#10;                                                        e.preventDefault();&#10;                                                        setContextMenuOptions({&#10;                                                            entry: selectedEntries.length &gt; 1 ? selectedEntries : entry,&#10;                                                            x: e.clientX - 30,&#10;                                                            y: e.clientY - 50,&#10;                                                            isOpen: true&#10;                                                        });&#10;                                                    }}&#10;                                                    data-selected={contextMenuOptions.entry === entry &amp;&amp; contextMenuOptions.isOpen}&#10;                                                    className={&quot;data-[selected=true]:opacity-50 data-[selected=true]:bg-white/10&quot;}&#10;                                                    onDoubleClick={() =&gt;&#10;                                                    {&#10;                                                        if (entry.is_dir &amp;&amp; !renamingEntry &amp;&amp; !newItemCreationEntry)&#10;                                                        {&#10;                                                            setPath(prev =&gt; prev ? `${prev}/${entry.filename}` : entry.filename);&#10;                                                        }&#10;                                                    }}&#10;                                                &gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        {renamingEntry === entry ?&#10;                                                            &lt;Input&#10;                                                                startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                defaultValue={entry.filename}&#10;                                                                autoFocus&#10;                                                                onBlur={e =&gt; renameSelectedEntry(e.currentTarget.value)}&#10;                                                                onKeyDown={async e =&gt;&#10;                                                                {&#10;                                                                    if (e.key === &quot;Enter&quot;) await renameSelectedEntry(e.currentTarget.value);&#10;                                                                }}&#10;                                                                radius={&quot;none&quot;}&#10;                                                                className={&quot;font-minecraft-body&quot;}&#10;                                                            /&gt; :&#10;                                                            newItemCreationEntry === entry ?&#10;                                                                &lt;Input&#10;                                                                    startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                    defaultValue={entry.filename}&#10;                                                                    autoFocus&#10;                                                                    onBlur={e =&gt; completeEntryCreation(e.currentTarget.value)}&#10;                                                                    onKeyDown={async e =&gt;&#10;                                                                    {&#10;                                                                        if (e.key === &quot;Enter&quot;) await completeEntryCreation(e.currentTarget.value);&#10;                                                                    }}&#10;                                                                    radius={&quot;none&quot;}&#10;                                                                    className={&quot;font-minecraft-body&quot;}&#10;                                                                /&gt;&#10;                                                                : (newArchiveEntry?.entry === entry &amp;&amp; !newArchiveEntry.isUploading) ?&#10;                                                                    &lt;Input&#10;                                                                        startContent={&lt;FileEntryIcon entry={{filename: &quot;.zip&quot;} as FilesystemEntry}/&gt;}&#10;                                                                        defaultValue={entry.filename}&#10;                                                                        autoFocus&#10;                                                                        onBlur={e =&gt; completeArchiveCreation(e.currentTarget.value)}&#10;                                                                        onKeyDown={async e =&gt;&#10;                                                                        {&#10;                                                                            if (e.key === &quot;Enter&quot;) await completeArchiveCreation(e.currentTarget.value);&#10;                                                                        }}&#10;                                                                        radius={&quot;none&quot;}&#10;                                                                        className={&quot;font-minecraft-body&quot;}&#10;                                                                        endContent={&lt;Chip&gt;.zip&lt;/Chip&gt;}&#10;                                                                    /&gt;&#10;                                                                    :&#10;                                                                    &lt;&gt;&lt;FileEntryIcon entry={entry}/&gt; {entry.filename}&lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;{entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        {entry === newArchiveEntry?.entry ?&#10;                                                            &lt;&gt;&#10;                                                                &lt;Progress&#10;                                                                    minValue={0}&#10;                                                                    maxValue={100}&#10;                                                                    value={newArchiveEntry.progress}&#10;                                                                    size={&quot;sm&quot;}&#10;                                                                /&gt;&#10;                                                            &lt;/&gt;&#10;                                                            :&#10;                                                            &lt;&gt;&#10;                                                                {entry.is_dir ? &quot;-&quot; : Math.convertToByteString(entry.size)}&#10;                                                            &lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        &lt;Button&#10;                                                            isIconOnly&#10;                                                            radius={&quot;none&quot;}&#10;                                                            variant={&quot;light&quot;}&#10;                                                            onPress={e =&gt;&#10;                                                            {&#10;                                                                let position = $(e.target).offset();&#10;                                                                if (!position) return;&#10;                                                                setContextMenuOptions({&#10;                                                                    entry,&#10;                                                                    x: position.left - 264,&#10;                                                                    y: position.top,&#10;                                                                    isOpen: true&#10;                                                                });&#10;                                                            }}&#10;                                                        &gt;&#10;                                                            &lt;Icon icon={&quot;pixelarticons:more-horizontal&quot;}/&gt;&#10;                                                        &lt;/Button&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            )}&#10;                                        &lt;/&gt;&#10;                                    )}&#10;                                &lt;/&gt;&#10;                            )}&#10;                        &lt;/TableBody&gt;&#10;                    &lt;/Table&gt;&#10;                &lt;/ErrorBoundary&gt;&#10;                {(!isEditingFile || selectedEntries.length !== 1) ? (&#10;                    &lt;RowContextMenu&#10;                        {...contextMenuOptions}&#10;                        onRename={setRenamingEntry}&#10;                        onDelete={deleteSelected}&#10;                        onArchive={startArchiveCreation}&#10;                        onExtract={handleExtract}&#10;                        onEdit={() =&gt;&#10;                        {&#10;                            setIsEditingFile(true);&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                        }}&#10;                        onClose={() =&gt; setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}))}&#10;                    /&gt;&#10;                ) : null}&#10;            &lt;/div&gt;&#10;            &lt;motion.div&#10;                id={&quot;server-file-editor&quot;}&#10;                ref={editorWrapperRef}&#10;                className={&quot;max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative&quot;}&#10;                initial={{opacity: 0, width: 0}}&#10;                animate={{&#10;                    opacity: isEditingFile &amp;&amp; selectedEntries.length === 1 ? 1 : 0,&#10;                    width: isEditingFile &amp;&amp; selectedEntries.length === 1 ? `${editorWidth}px` : &quot;0&quot;&#10;                }}&#10;                exit={{opacity: 0, width: 0}}&#10;                transition={{duration: isDragging ? 0 : 0.3, ease: &quot;easeInOut&quot;}}&#10;                data-editing-file={isEditingFile &amp;&amp; selectedEntries.length === 1}&#10;            &gt;&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;Editor&#10;                        className={&quot;w-full h-full&quot;}&#10;                        theme={&quot;obsidian-editor-theme&quot;}&#10;                        value={isEditingFile ? selectedFileContents : &quot;&quot;}&#10;                        language={getMonacoLanguage(selectedEntries[0]?.path ?? &quot;&quot;) ?? &quot;auto&quot;}&#10;                        onMount={handleEditorMount}&#10;                        width={`${editorWidth}px`}&#10;                        onChange={async content =&gt;&#10;                        {&#10;                            console.log(&quot;Editor content changed:&quot;, content);&#10;                            newContentRef.current = content ?? &quot;&quot;;&#10;                            setNeedsToSave(true);&#10;                            await reboundSaveContent();&#10;                        }}&#10;                        options={{&#10;                            fontSize: 14,&#10;                            minimap: {enabled: false},&#10;                            lineNumbers: &quot;on&quot;,&#10;                            scrollBeyondLastLine: false,&#10;                            automaticLayout: true,&#10;                            wordWrap: &quot;on&quot;,&#10;                            tabSize: 2,&#10;                            contextmenu: false,&#10;                            autoClosingBrackets: &quot;always&quot;,&#10;                            autoClosingOvertype: &quot;always&quot;,&#10;                            autoClosingQuotes: &quot;always&quot;,&#10;                            quickSuggestions: {&#10;                                other: true,&#10;                                comments: false,&#10;                                strings: true&#10;                            },&#10;                            suggestOnTriggerCharacters: true,&#10;                            acceptSuggestionOnEnter: &quot;on&quot;,&#10;                            tabCompletion: &quot;on&quot;,&#10;                            wordBasedSuggestions: &quot;matchingDocuments&quot;,&#10;                            parameterHints: {&#10;                                enabled: true,&#10;                                cycle: true&#10;                            },&#10;                            formatOnPaste: true,&#10;                            formatOnType: true,&#10;                            matchBrackets: &quot;always&quot;,&#10;                            autoIndent: &quot;full&quot;,&#10;                            folding: true,&#10;                            foldingStrategy: &quot;indentation&quot;,&#10;                            suggest: {&#10;                                showKeywords: true,&#10;                                showSnippets: true,&#10;                                showFunctions: true,&#10;                                showConstructors: true,&#10;                                showFields: true,&#10;                                showVariables: true,&#10;                                showClasses: true,&#10;                                showStructs: true,&#10;                                showInterfaces: true,&#10;                                showModules: true,&#10;                                showProperties: true,&#10;                                showEvents: true,&#10;                                showOperators: true,&#10;                                showUnits: true,&#10;                                showValues: true,&#10;                                showConstants: true,&#10;                                showEnums: true,&#10;                                showEnumMembers: true,&#10;                                showColors: true,&#10;                                showFiles: true,&#10;                                showReferences: true,&#10;                                showFolders: true,&#10;                                showTypeParameters: true,&#10;                                showUsers: true,&#10;                                showIssues: true&#10;                            }&#10;                        }}&#10;                    /&gt;&#10;                ) : selectedEntries.length === 1 &amp;&amp; !isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;div className=&quot;flex items-center justify-center h-full&quot;&gt;&#10;                        &lt;span className=&quot;text-gray-500 font-minecraft-body&quot;&gt;Select a text file to edit&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                ) : null}&#10;&#10;                {/* Resize Handle */}&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; (&#10;                    &lt;div&#10;                        className={&#10;                            cn(&#10;                                &quot;w-[8px] h-full bg-transparent transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none hover:bg-primary hover:opacity-50&quot;&#10;                            )&#10;                        }&#10;                        data-dragging={isDragging}&#10;                        onMouseDown={(e) =&gt;&#10;                        {&#10;                            e.preventDefault();&#10;                            setIsDragging(true);&#10;&#10;                            const startX = e.clientX;&#10;                            const startWidth = editorWidth;&#10;                            const parentWidth = editorWrapperRef.current?.parentElement?.clientWidth;&#10;&#10;                            const onMouseMove = (moveEvent: MouseEvent) =&gt;&#10;                            {&#10;                                moveEvent.preventDefault();&#10;                                const newWidth = startWidth - (moveEvent.clientX - startX);&#10;                                if (!parentWidth) return;&#10;                                setEditorWidth(Math.min(parentWidth - 300, Math.max(300, newWidth)));&#10;                            };&#10;&#10;                            const onMouseUp = (mouseEvent: MouseEvent) =&gt;&#10;                            {&#10;                                mouseEvent.preventDefault();&#10;                                setIsDragging(false);&#10;&#10;                                const newWidth = Math.max(300, startWidth - (mouseEvent.clientX - startX));&#10;                                localStorage.setItem(&quot;editor-width&quot;, newWidth.toString());&#10;                                document.removeEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                                document.removeEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                            };&#10;&#10;                            document.addEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                            document.addEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                        }}&#10;                    &gt;&#10;                        &lt;span&#10;                            className={&#10;                                cn(&#10;                                    &quot;w-px h-full bg-white opacity-20 transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none&quot;,&#10;                                    &quot;hover:opacity-50 hover:bg-primary&quot;,&#10;                                    &quot;data-[dragging=true]:opacity-50 data-[dragging=true]:bg-primary&quot;&#10;                                )&#10;                            }&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/motion.div&gt;&#10;&#10;            {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; (&#10;                &lt;div className={&quot;absolute bottom-8 right-8 z-50&quot;}&gt;&#10;                    &lt;Tooltip content={&quot;Save Content&quot;}&gt;&#10;                        &lt;Button radius={&quot;none&quot;} onPress={saveContent} isIconOnly isDisabled={!needsToSave} color={needsToSave ? &quot;primary&quot; : &quot;default&quot;} size={&quot;lg&quot;}&gt;&#10;                            &lt;Icon icon={&quot;pixelarticons:save&quot;}/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Overlay to prevent clicks during dragging */}&#10;            &lt;AnimatePresence&gt;&#10;                {isDragging &amp;&amp; (&#10;                    &lt;motion.div&#10;                        className=&quot;fixed inset-0 z-50 cursor-ew-resize select-none pointer-events-auto bg-primary/10&quot;&#10;                        initial={{opacity: 0}}&#10;                        animate={{opacity: 1}}&#10;                        exit={{opacity: 0}}&#10;                        transition={{duration: 0.2}}&#10;                        onClick={(e) =&gt; e.stopPropagation()}&#10;                    /&gt;&#10;                )}&#10;            &lt;/AnimatePresence&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/providers/ServerProvider.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/providers/ServerProvider.tsx" />
              <option name="originalContent" value="import {createContext, ReactNode, useCallback, useContext, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {FileSystem, FilesystemData, FilesystemEntry} from &quot;../ts/filesystem.ts&quot;;&#10;&#10;export type Server =&#10;    {&#10;        /** Unique identifier for the server */&#10;        id: string;&#10;        /** Directory name where server files are stored, e.g. 'my_minecraft_server' */&#10;        directory: string;&#10;        /** Additional JVM arguments excluding -Xmx and -Xms */&#10;        java_args: string;&#10;        /** Maximum memory in GB for JVM -Xmx argument */&#10;        max_memory: number;&#10;        /** Minimum memory in GB for JVM -Xms argument */&#10;        min_memory: number;&#10;        /** Additional Minecraft server arguments */&#10;        minecraft_args: string;&#10;        /** Name/path of the server JAR file */&#10;        server_jar: string;&#10;        /** Whether UPnP port forwarding is enabled */&#10;        upnp: boolean;&#10;        /** Server status: 'stopped', 'starting', 'running', 'stopping', 'error' */&#10;        status: ServerStatus;&#10;        /** Whether the server should start automatically on boot */&#10;        auto_start: boolean;&#10;        /** Whether the server should restart automatically if it crashes */&#10;        auto_restart: boolean;&#10;        /** Whether automatic backups are enabled */&#10;        backup_enabled: boolean;&#10;        /** Backup interval in minutes */&#10;        backup_interval: number;&#10;        /** Optional server description */&#10;        description: string | null;&#10;        /** ID of the user who owns this server */&#10;        owner_id: number;&#10;        /** Timestamp of when the server was created (seconds since epoch) */&#10;        created_at: number;&#10;        /** Timestamp of when the server was last updated (seconds since epoch) */&#10;        updated_at: number;&#10;        /** Timestamp of when the server was last started (seconds since epoch) */&#10;        last_started: number | null;&#10;    } &amp; CreateServerData&#10;&#10;export type CreateServerData = {&#10;    /** Name of the server, e.g. 'My Minecraft Server' */&#10;    name: string;&#10;    /** Server type: 'vanilla', 'fabric', 'forge', 'neoforge', 'quilt', or 'custom' */&#10;    server_type: LoaderType;&#10;    /** Minecraft version, e.g. '1.20.1', '1.19.4', or 'custom' */&#10;    minecraft_version: string;&#10;    /** Loader version e.g. '0.14.0', '1.20.1-44.1.23', or 'custom' */&#10;    loader_version: string;&#10;    /** Path to Java executable, e.g. '/usr/bin/java' or 'java' for system PATH */&#10;    java_executable: string;&#10;}&#10;&#10;export type LoaderType = &quot;vanilla&quot; | &quot;fabric&quot; | &quot;forge&quot; | &quot;neoforge&quot; | &quot;quilt&quot; | &quot;custom&quot;;&#10;export type ServerStatus = &quot;idle&quot; | &quot;running&quot; | &quot;stopped&quot; | &quot;error&quot; | &quot;starting&quot; | &quot;stopping&quot; | &quot;crashed&quot; | &quot;hanging&quot;;&#10;&#10;interface ServerContextType&#10;{&#10;    server: Server | null;&#10;    servers: Server[];&#10;    loadServer: (id: string) =&gt; Promise&lt;void&gt;;&#10;    unloadServer: () =&gt; void;&#10;    loadServers: () =&gt; Promise&lt;void&gt;;&#10;    createServer: (server: CreateServerData) =&gt; Promise&lt;string&gt;;&#10;    updateServer: (server: Partial&lt;Server&gt;, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    startServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    stopServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    restartServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    killServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    sendCommand: (command: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    subscribeToConsole: (callback: (data: string) =&gt; void, serverId?: string) =&gt; () =&gt; void;&#10;    cleanupConsoleConnection: (serverId?: string) =&gt; void;&#10;    hasActiveConsoleConnection: (serverId?: string) =&gt; boolean;&#10;    backupServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getServerStatus: (serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    isServerRunning: (serverId?: string) =&gt; boolean;&#10;    // Filesystem functions&#10;    getEntries: (path: string, serverId?: string) =&gt; Promise&lt;FilesystemData&gt;;&#10;    downloadEntry: (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    copyEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    moveEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    renameEntry: (source: string, destination: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteEntry: (path: string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFile: (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string) =&gt; Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;;&#10;    createEntry: (filename: string, cwd: string, isDirectory: boolean, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    searchFiles: (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string) =&gt; Promise&lt;FilesystemEntry[]&gt;;&#10;    archiveFiles: (filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelArchive: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFromUrl: (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getFileContents: (path: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    setFileContents: (path: string, contents: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    // Logging and console functions&#10;    getLogs: (serverId?: string) =&gt; Promise&lt;string[]&gt;;&#10;    getLog: (filename: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;}&#10;&#10;const ServerContext = createContext&lt;ServerContextType | undefined&gt;(undefined);&#10;&#10;export function ServerProvider({children}: { children: ReactNode })&#10;{&#10;    const [server, setServer] = useState&lt;Server | null&gt;(null);&#10;    const [servers, setServers] = useState&lt;Server[]&gt;([]);&#10;&#10;    // Connection tracking for console subscriptions&#10;    const consoleConnections = useRef&lt;Map&lt;string, () =&gt; void&gt;&gt;(new Map());&#10;&#10;    const loadServer = async (id: string) =&gt;&#10;    {&#10;        let server: Server = await $.get(`/api/server/${id}`);&#10;        server.status = server.status.toLowerCase() as ServerStatus; // Ensure server_type is lowercase&#10;        setServer(server);&#10;    };&#10;&#10;    const unloadServer = () =&gt;&#10;    {&#10;        setServer(null);&#10;    };&#10;&#10;    const loadServers = async () =&gt;&#10;    {&#10;        let servers: Server[] = await $.get(&quot;/api/server&quot;);&#10;        servers = servers.map(s =&gt; ({...s, status: s.status.toLowerCase()} as Server));&#10;        setServers(servers);&#10;    };&#10;&#10;    const createServer = async (server: CreateServerData): Promise&lt;string&gt; =&gt;&#10;    {&#10;        // Example response: { &quot;message&quot;: &quot;Server created successfully&quot;,&quot;server_id&quot;: &quot;lW97O03zR32QygKY&quot; }&#10;        let response = await $.ajax({&#10;            url: &quot;/api/server&quot;,&#10;            type: &quot;PUT&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(server)&#10;        });&#10;        if (!response || !response.server_id)&#10;        {&#10;            throw new Error(&quot;Server creation failed&quot;);&#10;        }&#10;&#10;        // Refresh servers list&#10;        await loadServers();&#10;        return response.server_id;&#10;    };&#10;&#10;    const isServerRunning = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        if (!targetServer) return false;&#10;        return targetServer.status === &quot;running&quot; || targetServer.status === &quot;starting&quot; || targetServer.status === &quot;stopping&quot; || targetServer.status === &quot;hanging&quot;;&#10;    }, [server, servers]);&#10;&#10;    const updateServer = useCallback(async (updates: Partial&lt;Server&gt;, serverId?: string) =&gt;&#10;    {&#10;        let targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        let targetServer: Server | null | undefined = serverId != undefined ? servers.find(s =&gt; s.id === targetServerId) : server;&#10;        if (targetServer == null)&#10;        {&#10;            targetServer = await $.get(`/api/server/${targetServerId}`);&#10;            if (!targetServer) throw new Error(&quot;No server loaded&quot;);&#10;        }&#10;&#10;        console.log(&quot;Updating server&quot;, targetServerId, updates, &quot;Original server:&quot;, targetServer);&#10;        const updatedServer = {...targetServer, ...updates};&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(updatedServer)&#10;        });&#10;        await loadServers();&#10;    }, [server, servers]);&#10;&#10;    const deleteServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;DELETE&quot;&#10;        });&#10;&#10;        // If deleting the currently loaded server, clear it&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(null);&#10;        }&#10;&#10;        // Remove from servers list&#10;        setServers(prev =&gt; prev.filter(s =&gt; s.id !== targetServerId));&#10;    }, [server]);&#10;&#10;    const startServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/start`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;starting&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const stopServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/stop`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const restartServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/restart`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const killServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/kill`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const sendCommand = useCallback(async (command: string, serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}/send-command`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;text/plain&quot;,&#10;            data: command&#10;        });&#10;    }, [server]);&#10;&#10;    const cleanupConsoleConnection = useCallback((serverId?: string) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = serverId || targetServer?.id;&#10;        if (!targetServerId) return;&#10;&#10;        const existingCleanup = consoleConnections.current.get(targetServerId);&#10;        if (existingCleanup)&#10;        {&#10;            existingCleanup();&#10;            consoleConnections.current.delete(targetServerId);&#10;        }&#10;    }, [server]);&#10;&#10;    const hasActiveConsoleConnection = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) return false;&#10;&#10;        return consoleConnections.current.has(targetServerId);&#10;    }, [server]);&#10;&#10;    const subscribeToConsole = useCallback((callback: (data: string) =&gt; void, serverId?: string): (() =&gt; void) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        cleanupConsoleConnection(targetServerId);&#10;&#10;        try&#10;        {&#10;            const eventSource = new EventSource(`/api/server/${targetServerId}/console`);&#10;            const eventName = `console`;&#10;&#10;            const handleMessage = (event: MessageEvent) =&gt;&#10;            {&#10;                console.log(`Received console message for server ${targetServerId}:`, event.data);&#10;                callback(event.data);&#10;            };&#10;&#10;            const handleError = (event: Event) =&gt;&#10;            {&#10;                console.error(`EventSource error for server ${targetServerId}:`, event);&#10;            };&#10;&#10;            const handleOpen = () =&gt;&#10;            {&#10;                console.log(`Console EventSource for server ${targetServerId} opened successfully.`);&#10;            };&#10;&#10;            eventSource.addEventListener(&quot;open&quot;, handleOpen);&#10;            eventSource.addEventListener(eventName, handleMessage);&#10;            eventSource.addEventListener(&quot;message&quot;, handleMessage);&#10;            eventSource.addEventListener(&quot;error&quot;, handleError);&#10;&#10;            const cleanup = () =&gt;&#10;            {&#10;                eventSource.removeEventListener(eventName, handleMessage);&#10;                eventSource.removeEventListener(&quot;message&quot;, handleMessage);&#10;                eventSource.removeEventListener(&quot;error&quot;, handleError);&#10;                eventSource.close();&#10;                consoleConnections.current.delete(targetServerId);&#10;                console.log(`EventSource for server ${targetServerId} closed and cleaned up.`);&#10;            };&#10;&#10;            // Store cleanup function in connection map&#10;            consoleConnections.current.set(targetServerId, cleanup);&#10;&#10;&#10;            // Return cleanup function&#10;            return cleanup;&#10;        } catch (error)&#10;        {&#10;            console.error(`Failed to create EventSource for server ${targetServerId}:`, error);&#10;            throw error;&#10;        }&#10;    }, [server, cleanupConsoleConnection]);&#10;&#10;    const backupServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        // Note: There's no backup endpoint in the server_endpoint.rs file&#10;        // You may need to implement this endpoint on the backend&#10;        throw new Error(&quot;Backup endpoint not implemented&quot;);&#10;    }, [server]);&#10;&#10;    const getServerStatus = useCallback(async (serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        const serverData: Server = await $.get(`/api/server/${targetServerId}`);&#10;        return serverData.status;&#10;    }, [server]);&#10;&#10;    // Filesystem functions&#10;    const getEntries = useCallback(async (path: string, serverId?: string): Promise&lt;FilesystemData&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getEntries(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const downloadEntry = useCallback(async (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        // if the entry is FileSystemEntry or FilesystemEntry[], convert it to string[]&#10;        if (Array.isArray(entry))&#10;        {&#10;            if (entry[0] &amp;&amp; typeof entry[0] === &quot;object&quot;)&#10;            {&#10;                entry = (entry as FilesystemEntry[]).map(e =&gt; e.path);&#10;            }&#10;        } else if (typeof entry === &quot;object&quot;)&#10;        {&#10;            entry = [(entry as FilesystemEntry).path];&#10;        }&#10;&#10;        return await FileSystem.download(entry as string[], targetServerId);&#10;    }, [server]);&#10;&#10;    const copyEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.copyEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const moveEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.moveEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const renameEntry = useCallback(async (source: string, destination: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.renameEntry(source, destination, targetServerId);&#10;    }, [server]);&#10;&#10;    const deleteEntry = useCallback(async (path: string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.deleteEntry(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFile = useCallback(async (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.upload(file, path, targetServerId, updateProgress, onCancelled);&#10;    }, [server]);&#10;&#10;    const createEntry = useCallback(async (filename: string, cwd: string, isDirectory: boolean, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.createEntry(filename, cwd, isDirectory, targetServerId);&#10;    }, [server]);&#10;&#10;    const searchFiles = useCallback(async (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string): Promise&lt;FilesystemEntry[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.search(query, filename_only, targetServerId, abortSignal);&#10;    }, [server]);&#10;&#10;    const archiveFiles = useCallback((filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.archive(filename, filenames, cwd, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelArchive = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelArchive(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFromUrl = useCallback(async (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.uploadFromUrl(url, filepath, targetServerId, onProgress, onSuccess, onError);&#10;    }, [server]);&#10;&#10;    const getLogs = useCallback(async (serverId?: string): Promise&lt;string[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs`);&#10;    }, [server]);&#10;&#10;    const getLog = useCallback(async (filename: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs/${filename}`);&#10;    }, [server]);&#10;    &#10;    const getFileContents = useCallback(async (path: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getFileContents(path, targetServerId);&#10;    }, [server]);&#10;    &#10;    const setFileContents = useCallback(async (path: string, contents: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.setFileContents(path, contents, targetServerId);&#10;    }, [server]);&#10;&#10;&#10;    return (&#10;        &lt;ServerContext.Provider value={{&#10;            server,&#10;            servers,&#10;            loadServer,&#10;            unloadServer,&#10;            loadServers,&#10;            createServer,&#10;            updateServer,&#10;            deleteServer,&#10;            startServer,&#10;            stopServer,&#10;            restartServer,&#10;            killServer,&#10;            sendCommand,&#10;            subscribeToConsole,&#10;            cleanupConsoleConnection,&#10;            hasActiveConsoleConnection,&#10;            backupServer,&#10;            getServerStatus,&#10;            isServerRunning,&#10;            // Filesystem functions&#10;            getEntries,&#10;            downloadEntry,&#10;            copyEntry,&#10;            moveEntry,&#10;            renameEntry,&#10;            deleteEntry,&#10;            uploadFile,&#10;            createEntry,&#10;            searchFiles,&#10;            archiveFiles,&#10;            cancelArchive,&#10;            uploadFromUrl,&#10;            getFileContents,&#10;            setFileContents,&#10;            getLogs,&#10;            getLog&#10;        }}&gt;&#10;            {children}&#10;        &lt;/ServerContext.Provider&gt;&#10;    );&#10;}&#10;&#10;export function useServer(): ServerContextType&#10;{&#10;    const context = useContext(ServerContext);&#10;    if (!context)&#10;    {&#10;        throw new Error(&quot;useServer must be used within a ServerProvider&quot;);&#10;    }&#10;    return context;&#10;}" />
              <option name="updatedContent" value="import {createContext, ReactNode, useCallback, useContext, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {FileSystem, FilesystemData, FilesystemEntry} from &quot;../ts/filesystem.ts&quot;;&#10;&#10;export type Server =&#10;    {&#10;        /** Unique identifier for the server */&#10;        id: string;&#10;        /** Directory name where server files are stored, e.g. 'my_minecraft_server' */&#10;        directory: string;&#10;        /** Additional JVM arguments excluding -Xmx and -Xms */&#10;        java_args: string;&#10;        /** Maximum memory in GB for JVM -Xmx argument */&#10;        max_memory: number;&#10;        /** Minimum memory in GB for JVM -Xms argument */&#10;        min_memory: number;&#10;        /** Additional Minecraft server arguments */&#10;        minecraft_args: string;&#10;        /** Name/path of the server JAR file */&#10;        server_jar: string;&#10;        /** Whether UPnP port forwarding is enabled */&#10;        upnp: boolean;&#10;        /** Server status: 'stopped', 'starting', 'running', 'stopping', 'error' */&#10;        status: ServerStatus;&#10;        /** Whether the server should start automatically on boot */&#10;        auto_start: boolean;&#10;        /** Whether the server should restart automatically if it crashes */&#10;        auto_restart: boolean;&#10;        /** Whether automatic backups are enabled */&#10;        backup_enabled: boolean;&#10;        /** Backup interval in minutes */&#10;        backup_interval: number;&#10;        /** Optional server description */&#10;        description: string | null;&#10;        /** ID of the user who owns this server */&#10;        owner_id: number;&#10;        /** Timestamp of when the server was created (seconds since epoch) */&#10;        created_at: number;&#10;        /** Timestamp of when the server was last updated (seconds since epoch) */&#10;        updated_at: number;&#10;        /** Timestamp of when the server was last started (seconds since epoch) */&#10;        last_started: number | null;&#10;    } &amp; CreateServerData&#10;&#10;export type CreateServerData = {&#10;    /** Name of the server, e.g. 'My Minecraft Server' */&#10;    name: string;&#10;    /** Server type: 'vanilla', 'fabric', 'forge', 'neoforge', 'quilt' , or 'custom' */&#10;    server_type: LoaderType;&#10;    /** Minecraft version, e.g. '1.20.1', '1.19.4', or 'custom' */&#10;    minecraft_version: string;&#10;    /** Loader version e.g. '0.14.0', '1.20.1-44.1.23', or 'custom' */&#10;    loader_version: string;&#10;    /** Path to Java executable, e.g. '/usr/bin/java' or 'java' for system PATH */&#10;    java_executable: string;&#10;}&#10;&#10;export type LoaderType = &quot;vanilla&quot; | &quot;fabric&quot; | &quot;forge&quot; | &quot;neoforge&quot; | &quot;quilt&quot; | &quot;custom&quot;;&#10;export type ServerStatus = &quot;idle&quot; | &quot;running&quot; | &quot;stopped&quot; | &quot;error&quot; | &quot;starting&quot; | &quot;stopping&quot; | &quot;crashed&quot; | &quot;hanging&quot;;&#10;&#10;interface ServerContextType&#10;{&#10;    server: Server | null;&#10;    servers: Server[];&#10;    loadServer: (id: string) =&gt; Promise&lt;void&gt;;&#10;    unloadServer: () =&gt; void;&#10;    loadServers: () =&gt; Promise&lt;void&gt;;&#10;    createServer: (server: CreateServerData) =&gt; Promise&lt;string&gt;;&#10;    updateServer: (server: Partial&lt;Server&gt;, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    startServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    stopServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    restartServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    killServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    sendCommand: (command: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    subscribeToConsole: (callback: (data: string) =&gt; void, serverId?: string) =&gt; () =&gt; void;&#10;    cleanupConsoleConnection: (serverId?: string) =&gt; void;&#10;    hasActiveConsoleConnection: (serverId?: string) =&gt; boolean;&#10;    backupServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getServerStatus: (serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    isServerRunning: (serverId?: string) =&gt; boolean;&#10;    // Filesystem functions&#10;    getEntries: (path: string, serverId?: string) =&gt; Promise&lt;FilesystemData&gt;;&#10;    downloadEntry: (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    copyEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    moveEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    renameEntry: (source: string, destination: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteEntry: (path: string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFile: (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string) =&gt; Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;;&#10;    createEntry: (filename: string, cwd: string, isDirectory: boolean, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    searchFiles: (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string) =&gt; Promise&lt;FilesystemEntry[]&gt;;&#10;    archiveFiles: (filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelArchive: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    extractArchive: (archivePath: string, outputPath: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelExtract: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFromUrl: (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getFileContents: (path: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    setFileContents: (path: string, contents: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    // Logging and console functions&#10;    getLogs: (serverId?: string) =&gt; Promise&lt;string[]&gt;;&#10;    getLog: (filename: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;}&#10;&#10;const ServerContext = createContext&lt;ServerContextType | undefined&gt;(undefined);&#10;&#10;export function ServerProvider({children}: { children: ReactNode })&#10;{&#10;    const [server, setServer] = useState&lt;Server | null&gt;(null);&#10;    const [servers, setServers] = useState&lt;Server[]&gt;([]);&#10;&#10;    // Connection tracking for console subscriptions&#10;    const consoleConnections = useRef&lt;Map&lt;string, () =&gt; void&gt;&gt;(new Map());&#10;&#10;    const loadServer = async (id: string) =&gt;&#10;    {&#10;        let server: Server = await $.get(`/api/server/${id}`);&#10;        server.status = server.status.toLowerCase() as ServerStatus; // Ensure server_type is lowercase&#10;        setServer(server);&#10;    };&#10;&#10;    const unloadServer = () =&gt;&#10;    {&#10;        setServer(null);&#10;    };&#10;&#10;    const loadServers = async () =&gt;&#10;    {&#10;        let servers: Server[] = await $.get(&quot;/api/server&quot;);&#10;        servers = servers.map(s =&gt; ({...s, status: s.status.toLowerCase()} as Server));&#10;        setServers(servers);&#10;    };&#10;&#10;    const createServer = async (server: CreateServerData): Promise&lt;string&gt; =&gt;&#10;    {&#10;        // Example response: { &quot;message&quot;: &quot;Server created successfully&quot;,&quot;server_id&quot;: &quot;lW97O03zR32QygKY&quot; }&#10;        let response = await $.ajax({&#10;            url: &quot;/api/server&quot;,&#10;            type: &quot;PUT&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(server)&#10;        });&#10;        if (!response || !response.server_id)&#10;        {&#10;            throw new Error(&quot;Server creation failed&quot;);&#10;        }&#10;&#10;        // Refresh servers list&#10;        await loadServers();&#10;        return response.server_id;&#10;    };&#10;&#10;    const isServerRunning = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        if (!targetServer) return false;&#10;        return targetServer.status === &quot;running&quot; || targetServer.status === &quot;starting&quot; || targetServer.status === &quot;stopping&quot; || targetServer.status === &quot;hanging&quot;;&#10;    }, [server, servers]);&#10;&#10;    const updateServer = useCallback(async (updates: Partial&lt;Server&gt;, serverId?: string) =&gt;&#10;    {&#10;        let targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        let targetServer: Server | null | undefined = serverId != undefined ? servers.find(s =&gt; s.id === targetServerId) : server;&#10;        if (targetServer == null)&#10;        {&#10;            targetServer = await $.get(`/api/server/${targetServerId}`);&#10;            if (!targetServer) throw new Error(&quot;No server loaded&quot;);&#10;        }&#10;&#10;        console.log(&quot;Updating server&quot;, targetServerId, updates, &quot;Original server:&quot;, targetServer);&#10;        const updatedServer = {...targetServer, ...updates};&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(updatedServer)&#10;        });&#10;        await loadServers();&#10;    }, [server, servers]);&#10;&#10;    const deleteServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;DELETE&quot;&#10;        });&#10;&#10;        // If deleting the currently loaded server, clear it&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(null);&#10;        }&#10;&#10;        // Remove from servers list&#10;        setServers(prev =&gt; prev.filter(s =&gt; s.id !== targetServerId));&#10;    }, [server]);&#10;&#10;    const startServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/start`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;starting&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const stopServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/stop`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const restartServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/restart`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const killServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/kill`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const sendCommand = useCallback(async (command: string, serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}/send-command`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;text/plain&quot;,&#10;            data: command&#10;        });&#10;    }, [server]);&#10;&#10;    const cleanupConsoleConnection = useCallback((serverId?: string) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = serverId || targetServer?.id;&#10;        if (!targetServerId) return;&#10;&#10;        const existingCleanup = consoleConnections.current.get(targetServerId);&#10;        if (existingCleanup)&#10;        {&#10;            existingCleanup();&#10;            consoleConnections.current.delete(targetServerId);&#10;        }&#10;    }, [server]);&#10;&#10;    const hasActiveConsoleConnection = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) return false;&#10;&#10;        return consoleConnections.current.has(targetServerId);&#10;    }, [server]);&#10;&#10;    const subscribeToConsole = useCallback((callback: (data: string) =&gt; void, serverId?: string): (() =&gt; void) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        cleanupConsoleConnection(targetServerId);&#10;&#10;        try&#10;        {&#10;            const eventSource = new EventSource(`/api/server/${targetServerId}/console`);&#10;            const eventName = `console`;&#10;&#10;            const handleMessage = (event: MessageEvent) =&gt;&#10;            {&#10;                console.log(`Received console message for server ${targetServerId}:`, event.data);&#10;                callback(event.data);&#10;            };&#10;&#10;            const handleError = (event: Event) =&gt;&#10;            {&#10;                console.error(`EventSource error for server ${targetServerId}:`, event);&#10;            };&#10;&#10;            const handleOpen = () =&gt;&#10;            {&#10;                console.log(`Console EventSource for server ${targetServerId} opened successfully.`);&#10;            };&#10;&#10;            eventSource.addEventListener(&quot;open&quot;, handleOpen);&#10;            eventSource.addEventListener(eventName, handleMessage);&#10;            eventSource.addEventListener(&quot;message&quot;, handleMessage);&#10;            eventSource.addEventListener(&quot;error&quot;, handleError);&#10;&#10;            const cleanup = () =&gt;&#10;            {&#10;                eventSource.removeEventListener(eventName, handleMessage);&#10;                eventSource.removeEventListener(&quot;message&quot;, handleMessage);&#10;                eventSource.removeEventListener(&quot;error&quot;, handleError);&#10;                eventSource.close();&#10;                consoleConnections.current.delete(targetServerId);&#10;                console.log(`EventSource for server ${targetServerId} closed and cleaned up.`);&#10;            };&#10;&#10;            // Store cleanup function in connection map&#10;            consoleConnections.current.set(targetServerId, cleanup);&#10;&#10;&#10;            // Return cleanup function&#10;            return cleanup;&#10;        } catch (error)&#10;        {&#10;            console.error(`Failed to create EventSource for server ${targetServerId}:`, error);&#10;            throw error;&#10;        }&#10;    }, [server, cleanupConsoleConnection]);&#10;&#10;    const backupServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        // Note: There's no backup endpoint in the server_endpoint.rs file&#10;        // You may need to implement this endpoint on the backend&#10;        throw new Error(&quot;Backup endpoint not implemented&quot;);&#10;    }, [server]);&#10;&#10;    const getServerStatus = useCallback(async (serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        const serverData: Server = await $.get(`/api/server/${targetServerId}`);&#10;        return serverData.status;&#10;    }, [server]);&#10;&#10;    // Filesystem functions&#10;    const getEntries = useCallback(async (path: string, serverId?: string): Promise&lt;FilesystemData&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getEntries(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const downloadEntry = useCallback(async (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        // if the entry is FileSystemEntry or FilesystemEntry[], convert it to string[]&#10;        if (Array.isArray(entry))&#10;        {&#10;            if (entry[0] &amp;&amp; typeof entry[0] === &quot;object&quot;)&#10;            {&#10;                entry = (entry as FilesystemEntry[]).map(e =&gt; e.path);&#10;            }&#10;        } else if (typeof entry === &quot;object&quot;)&#10;        {&#10;            entry = [(entry as FilesystemEntry).path];&#10;        }&#10;&#10;        return await FileSystem.download(entry as string[], targetServerId);&#10;    }, [server]);&#10;&#10;    const copyEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.copyEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const moveEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.moveEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const renameEntry = useCallback(async (source: string, destination: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.renameEntry(source, destination, targetServerId);&#10;    }, [server]);&#10;&#10;    const deleteEntry = useCallback(async (path: string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.deleteEntry(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFile = useCallback(async (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.upload(file, path, targetServerId, updateProgress, onCancelled);&#10;    }, [server]);&#10;&#10;    const createEntry = useCallback(async (filename: string, cwd: string, isDirectory: boolean, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.createEntry(filename, cwd, isDirectory, targetServerId);&#10;    }, [server]);&#10;&#10;    const searchFiles = useCallback(async (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string): Promise&lt;FilesystemEntry[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.search(query, filename_only, targetServerId, abortSignal);&#10;    }, [server]);&#10;&#10;    const archiveFiles = useCallback((filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.archive(filename, filenames, cwd, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelArchive = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelArchive(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const extractArchive = useCallback((archivePath: string, outputPath: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.extract(archivePath, outputPath, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelExtract = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelExtract(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFromUrl = useCallback(async (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.uploadFromUrl(url, filepath, targetServerId, onProgress, onSuccess, onError);&#10;    }, [server]);&#10;&#10;    const getLogs = useCallback(async (serverId?: string): Promise&lt;string[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs`);&#10;    }, [server]);&#10;&#10;    const getLog = useCallback(async (filename: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs/${filename}`);&#10;    }, [server]);&#10;    &#10;    const getFileContents = useCallback(async (path: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getFileContents(path, targetServerId);&#10;    }, [server]);&#10;    &#10;    const setFileContents = useCallback(async (path: string, contents: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.setFileContents(path, contents, targetServerId);&#10;    }, [server]);&#10;&#10;&#10;    return (&#10;        &lt;ServerContext.Provider value={{&#10;            server,&#10;            servers,&#10;            loadServer,&#10;            unloadServer,&#10;            loadServers,&#10;            createServer,&#10;            updateServer,&#10;            deleteServer,&#10;            startServer,&#10;            stopServer,&#10;            restartServer,&#10;            killServer,&#10;            sendCommand,&#10;            subscribeToConsole,&#10;            cleanupConsoleConnection,&#10;            hasActiveConsoleConnection,&#10;            backupServer,&#10;            getServerStatus,&#10;            isServerRunning,&#10;            // Filesystem functions&#10;            getEntries,&#10;            downloadEntry,&#10;            copyEntry,&#10;            moveEntry,&#10;            renameEntry,&#10;            deleteEntry,&#10;            uploadFile,&#10;            createEntry,&#10;            searchFiles,&#10;            archiveFiles,&#10;            cancelArchive,&#10;            extractArchive,&#10;            cancelExtract,&#10;            uploadFromUrl,&#10;            getFileContents,&#10;            setFileContents,&#10;            getLogs,&#10;            getLog&#10;        }}&gt;&#10;            {children}&#10;        &lt;/ServerContext.Provider&gt;&#10;    );&#10;}&#10;&#10;export function useServer(): ServerContextType&#10;{&#10;    const context = useContext(ServerContext);&#10;    if (!context)&#10;    {&#10;        throw new Error(&quot;useServer must be used within a ServerProvider&quot;);&#10;    }&#10;    return context;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/ts/filesystem.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/ts/filesystem.ts" />
              <option name="originalContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    resolve(); // Resolve immediately when connection opens&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    onSuccess();&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    static extract(archivePath: string, outputPath: string, serverId: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `extract-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/extract/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        &#10;        // Trim leading slashes from paths&#10;        archivePath = archivePath.startsWith(&quot;/&quot;) ? archivePath.substring(1) : archivePath;&#10;        outputPath = outputPath.startsWith(&quot;/&quot;) ? outputPath.substring(1) : outputPath;&#10;        &#10;        // Function to cancel the extract operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel extract:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling extract:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0, 0, 0);&#10;            try&#10;            {&#10;                const url = new URL(`/api/server/${serverId}/fs/extract`, window.location.origin);&#10;                url.searchParams.set(&quot;archive&quot;, archivePath);&#10;                url.searchParams.set(&quot;directory&quot;, outputPath);&#10;                url.searchParams.set(&quot;tracker&quot;, id);&#10;                &#10;                const response = await fetch(url.toString(), {&#10;                    method: &quot;POST&quot;&#10;                });&#10;                &#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to extract the archive.&quot;}`);&#10;            }&#10;        });&#10;        &#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;            &#10;            // Check if the operation completed successfully&#10;            if (data.status === &quot;complete&quot;)&#10;            {&#10;                on_success();&#10;                return;&#10;            }&#10;            &#10;            // Check if there was an error&#10;            if (data.status === &quot;error&quot;)&#10;            {&#10;                on_error(data.error || &quot;Unknown error occurred during extraction&quot;);&#10;                return;&#10;            }&#10;&#10;            // Update progress&#10;            on_progress(data.progress || 0, data.filesProcessed || 0, data.totalFiles || 0);&#10;        };&#10;        &#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelExtract(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel extract operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    resolve(); // Resolve immediately when connection opens&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    onSuccess();&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>