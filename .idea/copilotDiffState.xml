<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Archive&#10;  type: http&#10;  seq: 15&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/archive/cancel/:tracker-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  tracker-id: archive123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Upload&#10;  type: http&#10;  seq: 6&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/cancel/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Copy Files&#10;  type: http&#10;  seq: 7&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/copy&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Create New Entry&#10;  type: http&#10;  seq: 11&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/new&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;path&quot;: &quot;new-folder&quot;,&#10;    &quot;is_directory&quot;: true&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Delete Files&#10;  type: http&#10;  seq: 10&#10;}&#10;&#10;delete {&#10;  url: {{baseurl}}/server/:server-id/fs/&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;paths&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;, &quot;file2.txt&quot;]&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id:&#10;}" />
              <option name="updatedContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?filepath&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath:&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?path=&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  path: &#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Move Files&#10;  type: http&#10;  seq: 8&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/move&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Rename File&#10;  type: http&#10;  seq: 9&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/rename&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;source&quot;: &quot;oldfile.txt&quot;,&#10;    &quot;destination&quot;: &quot;newfile.txt&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Search Files&#10;  type: http&#10;  seq: 12&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/search?q=config&amp;filename_only=false&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  q: config&#10;  filename_only: false&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru" />
              <option name="originalContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?filepath=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath: example.txt&#10;params:path {&#10;  server-id: &#10;  server-id:&#10;  server-id:&#10;body:text {&#10;  This is the content of the uploaded file.&#10;}&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?upload_id=upload123&amp;path=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  upload_id: upload123&#10;  path: example.txt&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:text {&#10;  This is the content of the uploaded file.&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Upload Progress&#10;  type: http&#10;  seq: 5&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/progress/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Cargo.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Cargo.toml" />
              <option name="originalContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;obsidian-upnp = { git = &quot;https://github.com/Obsidian-Minecraft-Server-Portal/upnp.git&quot; }&#10;&#10;[build-dependencies]&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;" />
              <option name="updatedContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;tar = &quot;0.4.44&quot;&#10;obsidian-upnp = { git = &quot;https://github.com/Obsidian-Minecraft-Server-Portal/upnp.git&quot; }&#10;&#10;[build-dependencies]&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs" />
              <option name="originalContent" value="mod filesystem_data;&#10;mod filesystem_endpoint;&#10;mod download_parameters;&#10;mod archive_wrapper;&#10;mod normalize_path;&#10;&#10;pub use filesystem_endpoint::configure;&#10;" />
              <option name="updatedContent" value="mod filesystem_data;&#13;&#10;mod filesystem_endpoint;&#13;&#10;mod download_parameters;&#13;&#10;mod archive_wrapper;&#13;&#10;mod extract_wrapper;&#13;&#10;mod normalize_path;&#13;&#10;&#13;&#10;pub use filesystem_endpoint::configure;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/MessageModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/MessageModal.tsx" />
              <option name="originalContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={isOpen}&#10;            onClose={() =&gt; onClose(responseType === MessageResponseType.Close ? null : false)}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{&#10;                closeButton: &quot;rounded-none&quot;,&#10;                backdrop: severity === &quot;danger&quot; ? &quot;bg-danger/10&quot; : &quot;&quot;&#10;            }}&#10;            data-severity={severity}&#10;            isDismissable={false}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {() =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;flex flex-row items-center gap-2 text-2xl&quot;}&gt;&#10;                            &lt;span className={&quot;text-3xl h-[30px]&quot;}&gt;{typeof icon === &quot;string&quot; ? &lt;Icon icon={icon}/&gt; : icon == null ? &lt;MessageIcon severity={severity}/&gt; : icon}&lt;/span&gt;&#10;                            &lt;span&#10;                                className={&quot;data-[severity=danger]:text-danger data-[severity=warning]:text-warning data-[severity=info]:text-blue-500 data-[severity=success]:text-success&quot;}&#10;                                data-severity={severity}&#10;                            &gt;&#10;                                {title}&#10;                            &lt;/span&gt;&#10;                        &lt;/ModalHeader&gt;&#10;                        &lt;ModalBody&gt;&#10;                            {body}&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            {({&#10;                                [MessageResponseType.YesNo]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Yes&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;No&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.OkayCancel]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Okay&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;Cancel&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.Close]: (&#10;                                    &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} autoFocus&gt;Close&lt;/Button&gt;&#10;                                )&#10;                            })[responseType]}&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;const MessageIcon = ({severity}: { severity: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot; | undefined }) =&gt;&#10;{&#10;    switch (severity)&#10;    {&#10;        case &quot;info&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:info-box&quot;} className={&quot;text-blue-500&quot;}/&gt;;&#10;        case &quot;warning&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:warning-box&quot;} className={&quot;text-warning&quot;}/&gt;;&#10;        case &quot;danger&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:alert&quot;} className={&quot;text-danger&quot;}/&gt;;&#10;        case &quot;success&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:radio-on&quot;} className={&quot;text-success&quot;}/&gt;;&#10;        default:&#10;            return null;&#10;    }&#10;};" />
              <option name="updatedContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode, useEffect} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;&#10;    // Handle keyboard events for Enter and Space&#10;    useEffect(() =&gt; {&#10;        if (!isOpen) return;&#10;&#10;        const handleKeyDown = (event: KeyboardEvent) =&gt; {&#10;            if (event.key === 'Enter' || event.key === ' ') {&#10;                event.preventDefault();&#10;                event.stopPropagation();&#10;                // Trigger the primary action (Yes/Okay/Close)&#10;                onClose(true);&#10;            }&#10;        };&#10;&#10;        // Add event listener when modal is open&#10;        document.addEventListener('keydown', handleKeyDown);&#10;&#10;        // Cleanup event listener when modal closes or component unmounts&#10;        return () =&gt; {&#10;            document.removeEventListener('keydown', handleKeyDown);&#10;        };&#10;    }, [isOpen, onClose]);&#10;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={isOpen}&#10;            onClose={() =&gt; onClose(responseType === MessageResponseType.Close ? null : false)}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{&#10;                closeButton: &quot;rounded-none&quot;,&#10;                backdrop: severity === &quot;danger&quot; ? &quot;bg-danger/10&quot; : &quot;&quot;&#10;            }}&#10;            data-severity={severity}&#10;            isDismissable={false}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {() =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;flex flex-row items-center gap-2 text-2xl&quot;}&gt;&#10;                            &lt;span className={&quot;text-3xl h-[30px]&quot;}&gt;{typeof icon === &quot;string&quot; ? &lt;Icon icon={icon}/&gt; : icon == null ? &lt;MessageIcon severity={severity}/&gt; : icon}&lt;/span&gt;&#10;                            &lt;span&#10;                                className={&quot;data-[severity=danger]:text-danger data-[severity=warning]:text-warning data-[severity=info]:text-blue-500 data-[severity=success]:text-success&quot;}&#10;                                data-severity={severity}&#10;                            &gt;&#10;                                {title}&#10;                            &lt;/span&gt;&#10;                        &lt;/ModalHeader&gt;&#10;                        &lt;ModalBody&gt;&#10;                            {body}&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            {({&#10;                                [MessageResponseType.YesNo]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Yes&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;No&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.OkayCancel]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Okay&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;Cancel&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.Close]: (&#10;                                    &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} autoFocus&gt;Close&lt;/Button&gt;&#10;                                )&#10;                            })[responseType]}&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;const MessageIcon = ({severity}: { severity: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot; | undefined }) =&gt;&#10;{&#10;    switch (severity)&#10;    {&#10;        case &quot;info&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:info-box&quot;} className={&quot;text-blue-500&quot;}/&gt;;&#10;        case &quot;warning&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:warning-box&quot;} className={&quot;text-warning&quot;}/&gt;;&#10;        case &quot;danger&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:alert&quot;} className={&quot;text-danger&quot;}/&gt;;&#10;        case &quot;success&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:radio-on&quot;} className={&quot;text-success&quot;}/&gt;;&#10;        default:&#10;            return null;&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx" />
              <option name="originalContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;export type ContextMenuOptions = {&#10;    entry?: FilesystemEntry | FilesystemEntry[];&#10;    x: number;&#10;    y: number;&#10;    isOpen: boolean;&#10;}&#10;type RowContextMenuProps = {&#10;    onRename: (entry: FilesystemEntry) =&gt; void;&#10;    onDelete: (entry: FilesystemEntry[]) =&gt; void;&#10;    onArchive: (entry: FilesystemEntry[]) =&gt; void;&#10;    onEdit: (entry: FilesystemEntry) =&gt; void;&#10;    onClose: () =&gt; void;&#10;} &amp; ContextMenuOptions;&#10;&#10;export function RowContextMenu({entry, y, x, isOpen, onClose, onRename, onDelete, onArchive, onEdit}: RowContextMenuProps)&#10;{&#10;    const {downloadEntry} = useServer();&#10;    const [position, setPosition] = useState({x, y});&#10;    const menuRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;&#10;    const downloadSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;        onClose();&#10;        await downloadEntry(entry);&#10;    }, [entry, downloadEntry, isOpen]);&#10;&#10;    const deleteSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;&#10;        onClose();&#10;        if (Array.isArray(entry)) onDelete(entry);&#10;        else onDelete([entry]);&#10;    }, [entry, isOpen]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let parent = $(&quot;#server-file-browser&quot;);&#10;        let menu = menuRef.current;&#10;        if (parent.length === 0 || !menu) return;&#10;        let menuElement = $(menu);&#10;&#10;        let offset = parent.offset();&#10;        let parentWidth = parent.width();&#10;        let parentHeight = parent.height();&#10;        let menuWidth = menuElement.outerWidth();&#10;        let menuHeight = menuElement.outerHeight();&#10;        if (!offset || !menuWidth || !menuHeight || !parentWidth || !parentHeight) return;&#10;&#10;&#10;        let newX = x;&#10;        let newY = y;&#10;        if (newX + menuWidth &gt; offset.left + parentWidth)&#10;        {&#10;            newX = (offset.left + parentWidth) - menuWidth - 10; // 10px padding&#10;        }&#10;        if (newY + menuHeight &gt; offset.top + parentHeight)&#10;        {&#10;            newY = (offset.top + parentHeight) - menuHeight - 10; // 10px padding&#10;        }&#10;&#10;        setPosition({x: newX - 50, y: newY - 340});&#10;    }, [x, y, isOpen, onClose]);&#10;    return (&#10;        &lt;Listbox&#10;            id={&quot;server-files-context-menu&quot;}&#10;            ref={menuRef}&#10;            className={&quot;absolute z-50 w-64 bg-background/50 backdrop-blur-sm border border-primary/50 shadow-lg data-[open=true]:opacity-100 data-[open=false]:opacity-0 transition-opacity duration-200 data-[open=false]:pointer-events-none font-minecraft-body&quot;}&#10;            style={{top: position.y, left: position.x}}&#10;            itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&#10;            data-open={isOpen}&#10;            onSelectionChange={() =&gt; onClose()}&#10;            tabIndex={1}&#10;        &gt;&#10;            &lt;ListboxSection title={Array.isArray(entry) ? `${entry.length} Items Selected` : entry?.filename ?? &quot;&quot;} itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&gt;&#10;                {!Array.isArray(entry) &amp;&amp; entry ? (() =&gt;&#10;                {&#10;                    let singleItemOptions = [];&#10;                    if (!entry?.is_dir &amp;&amp; isTextFile(entry?.path))&#10;                    {&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;edit&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:edit-box&quot;}/&gt;} onPress={() =&gt; onEdit(entry)}&gt;Edit&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;&#10;                    return (&#10;                        &lt;&gt;&#10;                            {...singleItemOptions}&#10;                            &lt;ListboxItem key={&quot;rename&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:unlink&quot;}/&gt;} onPress={() =&gt;&#10;                            {&#10;                                onRename(entry);&#10;                                onClose();&#10;                            }}&gt;Rename&lt;/ListboxItem&gt;&#10;                        &lt;/&gt;&#10;                    );&#10;                })() : null}&#10;                &lt;ListboxItem key={&quot;archive&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;} onPress={() =&gt; onArchive(Array.isArray(entry) ? entry : [entry] as FilesystemEntry[])}&gt;Archive&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;download&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:flatten&quot;}/&gt;} onPress={downloadSelectedEntries}&gt;Download&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;delete&quot;} color={&quot;danger&quot;} className={&quot;text-danger&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;} onPress={deleteSelectedEntries}&gt;Delete&lt;/ListboxItem&gt;&#10;            &lt;/ListboxSection&gt;&#10;        &lt;/Listbox&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;// Helper function to check if a file is an archive&#10;const isArchiveFile = (filename: string): boolean =&gt; {&#10;    const archiveExtensions = ['.zip', '.tar.gz', '.tgz', '.tar', '.rar', '.7z'];&#10;    const lowerFilename = filename.toLowerCase();&#10;    return archiveExtensions.some(ext =&gt; lowerFilename.endsWith(ext));&#10;};&#10;&#10;// Helper function to get archive name without extension&#10;const getArchiveBaseName = (filename: string): string =&gt; {&#10;    if (filename.toLowerCase().endsWith('.tar.gz')) {&#10;        return filename.slice(0, -7); // Remove .tar.gz&#10;    } else if (filename.toLowerCase().endsWith('.tgz')) {&#10;        return filename.slice(0, -4); // Remove .tgz&#10;    } else {&#10;        // Remove last extension for other formats&#10;        const lastDotIndex = filename.lastIndexOf('.');&#10;        return lastDotIndex &gt; 0 ? filename.slice(0, lastDotIndex) : filename;&#10;    }&#10;};&#10;&#10;export type ContextMenuOptions = {&#10;    entry?: FilesystemEntry | FilesystemEntry[];&#10;    x: number;&#10;    y: number;&#10;    isOpen: boolean;&#10;}&#10;type RowContextMenuProps = {&#10;    onRename: (entry: FilesystemEntry) =&gt; void;&#10;    onDelete: (entry: FilesystemEntry[]) =&gt; void;&#10;    onArchive: (entry: FilesystemEntry[]) =&gt; void;&#10;    onExtract: (entry: FilesystemEntry, outputPath?: string) =&gt; void;&#10;    onEdit: (entry: FilesystemEntry) =&gt; void;&#10;    onClose: () =&gt; void;&#10;} &amp; ContextMenuOptions;&#10;&#10;export function RowContextMenu({entry, y, x, isOpen, onClose, onRename, onDelete, onArchive, onEdit, onExtract}: RowContextMenuProps)&#10;{&#10;    const {downloadEntry} = useServer();&#10;    const [position, setPosition] = useState({x, y});&#10;    const menuRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;&#10;    const downloadSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;        onClose();&#10;        await downloadEntry(entry);&#10;    }, [entry, downloadEntry, isOpen]);&#10;&#10;    const deleteSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;&#10;        onClose();&#10;        if (Array.isArray(entry)) onDelete(entry);&#10;        else onDelete([entry]);&#10;    }, [entry, isOpen]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let parent = $(&quot;#server-file-browser&quot;);&#10;        let menu = menuRef.current;&#10;        if (parent.length === 0 || !menu) return;&#10;        let menuElement = $(menu);&#10;&#10;        let offset = parent.offset();&#10;        let parentWidth = parent.width();&#10;        let parentHeight = parent.height();&#10;        let menuWidth = menuElement.outerWidth();&#10;        let menuHeight = menuElement.outerHeight();&#10;        if (!offset || !menuWidth || !menuHeight || !parentWidth || !parentHeight) return;&#10;&#10;&#10;        let newX = x;&#10;        let newY = y;&#10;        if (newX + menuWidth &gt; offset.left + parentWidth)&#10;        {&#10;            newX = (offset.left + parentWidth) - menuWidth - 10; // 10px padding&#10;        }&#10;        if (newY + menuHeight &gt; offset.top + parentHeight)&#10;        {&#10;            newY = (offset.top + parentHeight) - menuHeight - 10; // 10px padding&#10;        }&#10;&#10;        setPosition({x: newX - 50, y: newY - 340});&#10;    }, [x, y, isOpen, onClose]);&#10;    return (&#10;        &lt;Listbox&#10;            id={&quot;server-files-context-menu&quot;}&#10;            ref={menuRef}&#10;            className={&quot;absolute z-50 w-64 bg-background/50 backdrop-blur-sm border border-primary/50 shadow-lg data-[open=true]:opacity-100 data-[open=false]:opacity-0 transition-opacity duration-200 data-[open=false]:pointer-events-none font-minecraft-body&quot;}&#10;            style={{top: position.y, left: position.x}}&#10;            itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&#10;            data-open={isOpen}&#10;            onSelectionChange={() =&gt; onClose()}&#10;            tabIndex={1}&#10;        &gt;&#10;            &lt;ListboxSection title={Array.isArray(entry) ? `${entry.length} Items Selected` : entry?.filename ?? &quot;&quot;} itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&gt;&#10;                {!Array.isArray(entry) &amp;&amp; entry ? (() =&gt;&#10;                {&#10;                    let singleItemOptions = [];&#10;                    if (!entry?.is_dir &amp;&amp; isTextFile(entry?.path))&#10;                    {&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;edit&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:edit-box&quot;}/&gt;} onPress={() =&gt; onEdit(entry)}&gt;Edit&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    // Add extract options for archive files&#10;                    if (!entry?.is_dir &amp;&amp; isArchiveFile(entry?.filename))&#10;                    {&#10;                        const archiveBaseName = getArchiveBaseName(entry.filename);&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-here&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:extract&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry);&#10;                                onClose();&#10;                            }}&gt;Extract Here&lt;/ListboxItem&gt;&#10;                        );&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-to-folder&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:folder-open&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry, archiveBaseName);&#10;                                onClose();&#10;                            }}&gt;Extract to {archiveBaseName}&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    return (&#10;                        &lt;&gt;&#10;                            {...singleItemOptions}&#10;                            &lt;ListboxItem key={&quot;rename&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:unlink&quot;}/&gt;} onPress={() =&gt;&#10;                            {&#10;                                onRename(entry);&#10;                                onClose();&#10;                            }}&gt;Rename&lt;/ListboxItem&gt;&#10;                        &lt;/&gt;&#10;                    );&#10;                })() : null}&#10;                &lt;ListboxItem key={&quot;archive&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;} onPress={() =&gt; onArchive(Array.isArray(entry) ? entry : [entry] as FilesystemEntry[])}&gt;Archive&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;download&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:flatten&quot;}/&gt;} onPress={downloadSelectedEntries}&gt;Download&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;delete&quot;} color={&quot;danger&quot;} className={&quot;text-danger&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;} onPress={deleteSelectedEntries}&gt;Delete&lt;/ListboxItem&gt;&#10;            &lt;/ListboxSection&gt;&#10;        &lt;/Listbox&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/ServerFiles.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/ServerFiles.tsx" />
              <option name="originalContent" value="import {Button, ButtonGroup, Chip, cn, Input, Progress, Skeleton, Table, TableBody, TableCell, TableColumn, TableHeader, TableRow} from &quot;@heroui/react&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import {KeyboardEvent, useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {FilesystemData, FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import &quot;../../../../ts/math-ext.ts&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {ContextMenuOptions, RowContextMenu} from &quot;./RowContextMenu.tsx&quot;;&#10;import {useMessage} from &quot;../../../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../../../MessageModal.tsx&quot;;&#10;import {FileTableBreadcrumbs} from &quot;./FileTableBreadcrumbs.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {ErrorBoundary} from &quot;../../../ErrorBoundry.tsx&quot;;&#10;import {FileEntryIcon} from &quot;./FileEntryIcon.tsx&quot;;&#10;import {Editor} from &quot;@monaco-editor/react&quot;;&#10;import {getMonacoLanguage, isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {registerMinecraftPropertiesLanguage} from &quot;../../../../ts/minecraft-properties-language.ts&quot;;&#10;import {AnimatePresence, motion} from &quot;framer-motion&quot;;&#10;&#10;// Define the theme outside the component&#10;const defineObsidianTheme = (monaco: any) =&gt;&#10;{&#10;    monaco.editor.defineTheme(&quot;obsidian-editor-theme&quot;, {&#10;        base: &quot;vs-dark&quot;,&#10;        inherit: true,&#10;        rules: [&#10;            {token: &quot;key&quot;, foreground: &quot;#47ebb4&quot;},&#10;            {token: &quot;value&quot;, foreground: &quot;#CE9178&quot;},&#10;            {token: &quot;comment&quot;, foreground: &quot;#57718e&quot;, fontStyle: &quot;italic&quot;},&#10;            {token: &quot;operator&quot;, foreground: &quot;#0aa370&quot;}&#10;        ],&#10;        colors: {&#10;            &quot;editor.background&quot;: &quot;#0b0b0e&quot;&#10;        }&#10;    });&#10;};&#10;&#10;type UploadProgress = {&#10;    entry: FilesystemEntry;&#10;    progress: number;&#10;    files: string[]&#10;    isUploading: boolean;&#10;    uploadGroup?: string;&#10;    filesProcessed?: number;&#10;    totalFiles?: number;&#10;    operationType: &quot;upload&quot; | &quot;archive&quot; | &quot;extract&quot;;&#10;}&#10;&#10;export function ServerFiles()&#10;{&#10;    const {getEntries, renameEntry, createEntry, deleteEntry, uploadFile, archiveFiles, extractArchive, getFileContents, setFileContents} = useServer();&#10;    const {open} = useMessage();&#10;    const [path, setPath] = useState(&quot;&quot;);&#10;    const [data, setData] = useState&lt;FilesystemData&gt;();&#10;    const [selectedEntries, setSelectedEntries] = useState&lt;FilesystemEntry[]&gt;([]);&#10;    const [contextMenuOptions, setContextMenuOptions] = useState&lt;ContextMenuOptions&gt;({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [renamingEntry, setRenamingEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newItemCreationEntry, setNewItemCreationEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newArchiveEntry, setNewArchiveEntry] = useState&lt;UploadProgress | undefined&gt;(undefined);&#10;    const [fileUploadEntries, setFileUploadEntries] = useState&lt;UploadProgress[]&gt;([]);&#10;    const [isDraggingOver, setIsDraggingOver] = useState(false);&#10;    const [isEditingFile, setIsEditingFile] = useState(false);&#10;    const [selectedFileContents, setSelectedFileContents] = useState(&quot;&quot;);&#10;    const [isDragging, setIsDragging] = useState(false);&#10;    const [editorWidth, setEditorWidth] = useState(() =&gt;&#10;    {&#10;        // Load saved width from localStorage or use default&#10;        const savedWidth = localStorage.getItem(&quot;editor-width&quot;);&#10;        return savedWidth ? parseInt(savedWidth, 10) : 400;&#10;    });&#10;    const editorRef = useRef&lt;any&gt;(null);&#10;    const monacoRef = useRef&lt;any&gt;(null);&#10;    const editorWrapperRef = useRef&lt;HTMLDivElement&gt;(null);&#10;    const editorSaveTimerRef = useRef&lt;number | undefined&gt;(undefined);&#10;    const [needsToSave, setNeedsToSave] = useState(false);&#10;    const newContentRef = useRef&lt;string&gt;(&quot;&quot;);&#10;&#10;    const selectedEntriesRef = useRef&lt;FilesystemEntry[]&gt;([]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        selectedEntriesRef.current = selectedEntries;&#10;    }, [selectedEntries]);&#10;&#10;    const scrollToTop = useCallback(() =&gt;&#10;    {&#10;        $(&quot;#server-files-table&quot;).parent().scrollTop(0);&#10;    }, [path]);&#10;&#10;    const saveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        const file = currentSelectedEntries[0]?.path;&#10;&#10;        console.log(&quot;Attempting to save content:&quot;, newContentRef, &quot;Needs to save:&quot;, needsToSave, &quot;File:&quot;, currentSelectedEntries);&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        setNeedsToSave(false);&#10;&#10;        try&#10;        {&#10;            if (!file || !newContentRef.current)&#10;            {&#10;                console.warn(&quot;No file selected or content is empty, skipping save.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Save the content to the file&#10;            console.log(&quot;Saving file:&quot;, file, newContentRef.current);&#10;            await setFileContents(file, newContentRef.current);&#10;            newContentRef.current = &quot;&quot;;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save file:&quot;, error);&#10;            await open({&#10;                title: &quot;Save File Failed&quot;,&#10;                body: &quot;An error occurred while saving the file. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [newContentRef, editorSaveTimerRef, needsToSave, open]);&#10;&#10;    const reboundSaveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        if (!currentSelectedEntries || currentSelectedEntries.length !== 1 || !isTextFile(currentSelectedEntries[0].path)) return;&#10;&#10;        if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;        editorSaveTimerRef.current = setTimeout(async () =&gt;&#10;        {&#10;            await saveContent();&#10;        }, 5000);&#10;    }, [saveContent]);&#10;&#10;    const upload = useCallback(async (files: File[]) =&gt;&#10;    {&#10;        let uploadGroup = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);&#10;        let promises = [];&#10;        for (let file of files)&#10;        {&#10;            let entry = {filename: file.name, path, is_dir: false, size: file.size, file_type: file.type, operationType: &quot;upload&quot;} as FilesystemEntry;&#10;            setFileUploadEntries(prev =&gt; [...prev, {entry, progress: 0, files: [file.name], isUploading: true, uploadGroup, operationType: &quot;upload&quot;}]);&#10;            let totalSize = file.size;&#10;            const {promise} = await uploadFile(file, entry.path, async bytes =&gt;&#10;                {&#10;                    let progress = bytes / totalSize;&#10;                    setFileUploadEntries(prev =&gt; prev.map(upload =&gt; upload.entry === entry ? {...upload, progress} : upload));&#10;                    console.log(&quot;Upload progress:&quot;, progress);&#10;                }, async () =&gt;&#10;                {&#10;                    // On Canceled&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.entry !== entry));&#10;                    await refresh();&#10;                }&#10;            );&#10;            promises.push(promise);&#10;        }&#10;        await Promise.all(promises);&#10;        await refresh();&#10;        setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== uploadGroup));&#10;    }, [setFileUploadEntries, fileUploadEntries, path]);&#10;&#10;    const refresh = useCallback(async () =&gt;&#10;    {&#10;        scrollToTop();&#10;        setIsLoading(true);&#10;        const data = await getEntries(path);&#10;        data.entries = data.entries.sort((a, b) =&gt;&#10;        {&#10;            if (a.is_dir &amp;&amp; !b.is_dir) return -1; // Directories first&#10;            if (!a.is_dir &amp;&amp; b.is_dir) return 1; // Files after directories&#10;            return a.filename.localeCompare(b.filename); // Sort alphabetically&#10;        });&#10;        setData(data);&#10;        setIsLoading(false);&#10;        setSelectedEntries([]);&#10;        setContextMenuOptions({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    }, [path, data]);&#10;&#10;    const renameSelectedEntry = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!renamingEntry || newName.trim() === &quot;&quot; || newName === renamingEntry.filename)&#10;        {&#10;            setRenamingEntry(undefined);&#10;            return;&#10;        }&#10;&#10;        let newPath = `${path}/${newName}`;&#10;        try&#10;        {&#10;            await renameEntry(renamingEntry.path, newPath);&#10;            setRenamingEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Rename Failed&quot;,&#10;                body: &quot;An error occurred while renaming the entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [renamingEntry, path]);&#10;&#10;    const startEntryCreation = useCallback(async (directory: boolean) =&gt;&#10;    {&#10;        scrollToTop();&#10;        let filename = `New ${directory ? &quot;Directory&quot; : &quot;File.txt&quot;}`;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === filename))&#10;        {&#10;            index++;&#10;            filename = `New ${directory ? &quot;Directory&quot; : &quot;File&quot;} (${index}).txt`;&#10;        }&#10;        let entry = {filename, path, is_dir: directory, size: 0, file_type: directory ? &quot;Directory&quot; : &quot;File&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewItemCreationEntry(entry);&#10;    }, [data, path]);&#10;&#10;    const completeEntryCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!newItemCreationEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            await createEntry(newName, path, newItemCreationEntry.is_dir);&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Creation Failed&quot;,&#10;                body: &quot;An error occurred while create new entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [data, path]);&#10;&#10;    const startArchiveCreation = useCallback(async () =&gt;&#10;    {&#10;        setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        scrollToTop();&#10;        let filename = &quot;New Archive&quot;;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === `${filename}.zip`))&#10;        {&#10;            index++;&#10;            filename = `New Archive (${index})`;&#10;        }&#10;        let entry = {filename, path, is_dir: false, size: 0, file_type: &quot;Archive&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewArchiveEntry({entry, progress: 0, files: selectedEntries.map(entry =&gt; entry.path), isUploading: false, operationType: &quot;archive&quot;});&#10;    }, [path, data, selectedEntries]);&#10;&#10;    const completeArchiveCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        setNewArchiveEntry(prev =&gt; prev ? {...prev, isUploading: true, operationType: &quot;archive&quot;} : undefined);&#10;        if (!newArchiveEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewArchiveEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            archiveFiles(`${newName}.zip`, newArchiveEntry.files, path, progress =&gt;&#10;            {&#10;                setNewArchiveEntry(prev =&gt; prev ? {...prev, progress} : undefined);&#10;                console.log(&quot;Archive progress:&quot;, progress);&#10;            }, async () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;                await refresh();&#10;            }, error =&gt;&#10;            {&#10;                open({&#10;                    title: &quot;Archive Creation Failed&quot;,&#10;                    body: `An error occurred while creating the archive: ${error}`,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;                console.error(&quot;Failed to create archive:&quot;, error);&#10;                setNewArchiveEntry(undefined);&#10;            }, () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;            });&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to create archive:&quot;, error);&#10;            await open({&#10;                title: &quot;Archive Creation Failed&quot;,&#10;                body: &quot;An error occurred while creating the archive. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            setNewArchiveEntry(undefined);&#10;        }&#10;    }, [data, path, newArchiveEntry]);&#10;&#10;    const handleExtract = useCallback(async (entry: FilesystemEntry, outputPath?: string) =&gt;&#10;    {&#10;        scrollToTop();&#10;&#10;        // Determine the output path - either provided or current directory&#10;        const extractPath = outputPath || path;&#10;&#10;        // Create a unique ID for this extraction operation&#10;        const extractId = `extract-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;&#10;&#10;        // Create a temporary entry to show progress&#10;        const extractEntry: FilesystemEntry = {&#10;            filename: `Extracting ${entry.filename}...`,&#10;            path: `${path}/extracting-${entry.filename}`,&#10;            is_dir: false,&#10;            size: 0,&#10;            file_type: &quot;Extracting&quot;&#10;        };&#10;&#10;        const progressEntry: UploadProgress = {&#10;            entry: extractEntry,&#10;            progress: 0,&#10;            files: [entry.path],&#10;            isUploading: true,&#10;            operationType: &quot;extract&quot;,&#10;            filesProcessed: 0,&#10;            totalFiles: 0,&#10;            uploadGroup: extractId // Use the unique ID to track this specific extraction&#10;        };&#10;&#10;        setFileUploadEntries(prev =&gt; [...prev, progressEntry]);&#10;&#10;        // Helper function to remove the progress entry&#10;        const removeProgressEntry = () =&gt;&#10;        {&#10;            setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== extractId));&#10;        };&#10;&#10;        try&#10;        {&#10;            const {trackerId} = extractArchive(&#10;                entry.path,&#10;                extractPath,&#10;                (progress, filesProcessed, totalFiles) =&gt;&#10;                {&#10;                    setFileUploadEntries(prev =&gt;&#10;                        prev.map(upload =&gt;&#10;                            upload.uploadGroup === extractId&#10;                                ? {...upload, progress, filesProcessed, totalFiles}&#10;                                : upload&#10;                        )&#10;                    );&#10;                    console.log(&quot;Extract progress:&quot;, progress, &quot;Files:&quot;, filesProcessed, &quot;/&quot;, totalFiles);&#10;                },&#10;                async () =&gt;&#10;                {&#10;                    // Success - remove progress entry and refresh&#10;                    console.log(&quot;Extract completed successfully, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                    await refresh();&#10;                },&#10;                (error) =&gt;&#10;                {&#10;                    // Error - remove progress entry and show an error&#10;                    console.error(&quot;Failed to extract archive:&quot;, error);&#10;                    removeProgressEntry();&#10;                    open({&#10;                        title: &quot;Extract Failed&quot;,&#10;                        body: `An error occurred while extracting the archive: ${error}`,&#10;                        responseType: MessageResponseType.Close,&#10;                        severity: &quot;danger&quot;&#10;                    });&#10;                },&#10;                () =&gt;&#10;                {&#10;                    // Cancelled - remove progress entry&#10;                    console.log(&quot;Extract cancelled, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                }&#10;            );&#10;&#10;            // Store the cancel function and track ID for potential future use&#10;            console.log(&quot;Extract operation started with track ID:&quot;, trackerId);&#10;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to start extract:&quot;, error);&#10;            removeProgressEntry();&#10;            await open({&#10;                title: &quot;Extract Failed&quot;,&#10;                body: &quot;An error occurred while starting the extraction. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [path, extractArchive, open, refresh]);&#10;&#10;    const handleKeyDown = useCallback(async (e: KeyboardEvent&lt;HTMLTableElement&gt;) =&gt;&#10;    {&#10;        if (renamingEntry !== undefined)&#10;        {&#10;            e.preventDefault();&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Escape&quot;)&#10;        {&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        }&#10;        if (e.key === &quot;F2&quot;)&#10;        {&#10;            // Start renaming the first selected entry&#10;            if (selectedEntries.length &gt; 0)&#10;            {&#10;                e.preventDefault();&#10;                setRenamingEntry(selectedEntries[0]);&#10;                return;&#10;            }&#10;        }&#10;&#10;        if (e.ctrlKey &amp;&amp; e.key === &quot;a&quot;)&#10;        {&#10;            // Select all entries&#10;            e.preventDefault();&#10;            setSelectedEntries(data?.entries || []);&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Delete&quot; || e.key === &quot;Backspace&quot;)&#10;        {&#10;            await deleteSelected(selectedEntries);&#10;        }&#10;    }, [renamingEntry, refresh, renameSelectedEntry, selectedEntries]);&#10;&#10;    const deleteSelected = useCallback(async (entries: FilesystemEntry[]) =&gt;&#10;    {&#10;        // Handle the delete action for selected entries&#10;        if (entries.length &gt; 0)&#10;        {&#10;            let response = await open({&#10;                title: &quot;Delete Files&quot;,&#10;                body: `Are you sure you want to delete ${entries.length &gt; 1 ? `${entries.length} files` : entries[0].filename}? This action cannot be undone.`,&#10;                responseType: MessageResponseType.OkayCancel,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            if (response)&#10;            {&#10;                // Implement delete logic here&#10;                await deleteEntry(entries.map(entry =&gt; entry.path));&#10;                await refresh();&#10;            }&#10;        }&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        refresh().then();&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        $(document).on(&quot;click&quot;, e =&gt;&#10;        {&#10;            // Close the context menu when clicking outside&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        }).on(&quot;blur&quot;, e =&gt;&#10;        {&#10;            // Close the context menu when focus is lost&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        });&#10;        $(&quot;#server-files-table&quot;).parent().on(&quot;scroll&quot;, () =&gt;&#10;        {&#10;            // Close the context menu when scrolling&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        });&#10;        return () =&gt;&#10;        {&#10;            $(document).off(&quot;click&quot;);&#10;            $(document).off(&quot;blur&quot;);&#10;            $(&quot;#server-files-table&quot;).parent().off(&quot;scroll&quot;);&#10;        };&#10;    }, []);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; isEditingFile)&#10;        {&#10;            if (editorSaveTimerRef.current) clearTimeout(editorSaveTimerRef.current);&#10;            setSelectedFileContents(&quot;&quot;);&#10;            setNeedsToSave(false);&#10;&#10;            // Load file contents for a single text file selection&#10;            getFileContents(selectedEntries[0].path).then(async contents =&gt;&#10;            {&#10;                setSelectedFileContents(contents);&#10;                setIsEditingFile(true);&#10;            }).catch(async error =&gt;&#10;            {&#10;                console.error(&quot;Failed to load file contents:&quot;, error);&#10;                await open({&#10;                    title: &quot;Load File Failed&quot;,&#10;                    body: &quot;An error occurred while loading the file contents. Please try again.&quot;,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;            });&#10;        } else&#10;        {&#10;            // Reset file contents when selection changes or multiple files are selected&#10;            setSelectedFileContents(&quot;&quot;);&#10;            // setIsEditingFile(false);&#10;        }&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    const handleEditorMount = useCallback((editor: any, monaco: any) =&gt;&#10;    {&#10;        editorRef.current = editor;&#10;        monacoRef.current = monaco;&#10;&#10;        // Define the theme first&#10;        defineObsidianTheme(monaco);&#10;&#10;        // Register the Minecraft properties language&#10;        registerMinecraftPropertiesLanguage(monaco);&#10;&#10;        // Set the theme after it's defined&#10;        monaco.editor.setTheme(&quot;obsidian-editor-theme&quot;);&#10;&#10;        // Override the toggle line comment keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyC,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.commentLine&quot;, {});&#10;            }&#10;        );&#10;&#10;        // Optional: Disable the original Ctrl+/ keybinding&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.Slash,&#10;            () =&gt;&#10;            {&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyF,&#10;            () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.formatDocument&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,&#10;            async () =&gt;&#10;            {&#10;                console.log(&quot;Saving content from editor&quot;);&#10;                await saveContent();&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.deleteLines&quot;, {});&#10;            }&#10;        );&#10;&#10;        editor.addCommand(&#10;            monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KeyD,&#10;            async () =&gt;&#10;            {&#10;                editor.trigger(&quot;keyboard&quot;, &quot;editor.action.duplicateSelection&quot;, {});&#10;            }&#10;        );&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    return (&#10;        &lt;div className={&#10;            cn(&#10;                &quot;flex flex-row gap-2 bg-default-50 overflow-x-hidden border-2 border-default-500/10&quot;&#10;            )&#10;        }&gt;&#10;            &lt;div&#10;                id={&quot;server-file-browser&quot;}&#10;                className={&#10;                    cn(&#10;                        &quot;flex flex-col gap-2 p-4 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative grow min-w-[300px]&quot;&#10;                    )&#10;                }&#10;                onDragStart={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnd={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnter={() =&gt; setIsDraggingOver(true)}&#10;                onDragExit={() =&gt; setIsDraggingOver(false)}&#10;                onDragOver={e =&gt; e.preventDefault()}&#10;                onDrop={async e =&gt;&#10;                {&#10;                    e.preventDefault();&#10;                    console.log(&quot;Files dropped:&quot;, e.dataTransfer.files);&#10;                    setIsDraggingOver(false);&#10;                    await upload([...e.dataTransfer.files]);&#10;                }}&#10;                data-dragging-over={isDraggingOver}&#10;            &gt;&#10;                {isDraggingOver &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 z-30 border-dotted border-4 border-primary bg-background/90 flex items-center justify-center&quot;&gt;&#10;                        &lt;span className=&quot;font-minecraft-body text-4xl&quot;&gt;Drop Files to Upload&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div className={&quot;flex flex-row justify-between items-center&quot;}&gt;&#10;                    &lt;FileTableBreadcrumbs onNavigate={setPath} paths={path.split(&quot;/&quot;).filter(p =&gt; p.trim() !== &quot;&quot;)}/&gt;&#10;                    &lt;ButtonGroup radius={&quot;none&quot;} variant={&quot;flat&quot;}&gt;&#10;                        &lt;Tooltip content={&quot;New File&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(false)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:file-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;New Directory&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(true)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:folder-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Toggle File Editor&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; setIsEditingFile(prev =&gt; !prev)} color={isEditingFile ? &quot;primary&quot; : &quot;default&quot;}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:notes&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Refresh Files&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} isDisabled={isLoading} onPress={refresh}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:repeat&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                    &lt;/ButtonGroup&gt;&#10;                &lt;/div&gt;&#10;                &lt;ErrorBoundary&gt;&#10;                    &lt;Table&#10;                        id={&quot;server-files-table&quot;}&#10;                        removeWrapper&#10;                        radius={&quot;none&quot;}&#10;                        className={cn(&quot;font-minecraft-body overflow-y-auto&quot;)}&#10;                        fullWidth&#10;                        color={&quot;primary&quot;}&#10;                        aria-label={&quot;Server Files&quot;}&#10;                        selectionMode={&quot;multiple&quot;}&#10;                        selectionBehavior={&quot;replace&quot;}&#10;                        showSelectionCheckboxes={false}&#10;                        isHeaderSticky&#10;                        classNames={{&#10;                            tr: &quot;!rounded-none&quot;,&#10;                            th: &quot;backdrop-blur-md bg-default-50/50 !rounded-none&quot;&#10;                        }}&#10;                        selectedKeys={selectedEntries.map(entry =&gt; entry.filename)}&#10;                        onSelectionChange={keys =&gt;&#10;                        {&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                            const selected = [...keys].map(key =&gt; data?.entries.find(entry =&gt; entry.filename === key)).filter(Boolean) as FilesystemEntry[];&#10;                            setSelectedEntries(selected);&#10;                        }}&#10;                        isKeyboardNavigationDisabled={true}&#10;                        onKeyDown={handleKeyDown}&#10;                    &gt;&#10;                        &lt;TableHeader&gt;&#10;                            &lt;TableColumn&gt;Name&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Type&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Size&lt;/TableColumn&gt;&#10;                            &lt;TableColumn width={48} hideHeader hidden={isEditingFile}&gt;Action&lt;/TableColumn&gt;&#10;                        &lt;/TableHeader&gt;&#10;                        &lt;TableBody&gt;&#10;                            {isLoading ? Array.from({length: 5}, (_, i) =&gt; (&#10;                                &lt;TableRow key={`skeleton-${i}`}&gt;&#10;                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-8&quot;}/&gt;&#10;                                        &lt;Skeleton className={&quot;w-32 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-24 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-16 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                &lt;/TableRow&gt;&#10;                            )) : (&#10;                                &lt;&gt;&#10;                                    {data?.entries?.length === 0 &amp;&amp; fileUploadEntries.length === 0 ? (&#10;                                        &lt;TableRow&gt;&#10;                                            &lt;TableCell colSpan={4} className=&quot;text-center text-gray-500&quot;&gt;&#10;                                                This directory is empty&#10;                                            &lt;/TableCell&gt;&#10;                                        &lt;/TableRow&gt;&#10;                                    ) : (&#10;                                        &lt;&gt;&#10;                                            {fileUploadEntries.map(upload =&gt; (&#10;                                                &lt;TableRow key={`upload-${upload.entry.filename}`}&gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        &lt;FileEntryIcon entry={upload.entry}/&gt; {upload.entry.filename}&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;{upload.entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;&#10;                                                        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;&#10;                                                            &lt;Progress&#10;                                                                minValue={0}&#10;                                                                maxValue={upload.operationType === &quot;upload&quot; ? 1 : 100}&#10;                                                                value={upload.progress}&#10;                                                                size={&quot;sm&quot;}&#10;                                                            /&gt;&#10;                                                            {upload.operationType === &quot;extract&quot; &amp;&amp; upload.totalFiles &amp;&amp; upload.totalFiles &gt; 0 &amp;&amp; (&#10;                                                                &lt;span className=&quot;text-xs text-gray-400&quot;&gt;&#10;                                                                    {upload.filesProcessed || 0}/{upload.totalFiles} files&#10;                                                                &lt;/span&gt;&#10;                                                            )}&#10;                                                        &lt;/div&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell&gt;&#10;                                                        &lt;&gt;&lt;/&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            ))}&#10;                                            {data?.entries.map(entry =&gt;&#10;                                                &lt;TableRow&#10;                                                    key={entry.filename}&#10;                                                    onContextMenu={e =&gt;&#10;                                                    {&#10;                                                        e.preventDefault();&#10;                                                        setContextMenuOptions({&#10;                                                            entry: selectedEntries.length &gt; 1 ? selectedEntries : entry,&#10;                                                            x: e.clientX - 30,&#10;                                                            y: e.clientY - 50,&#10;                                                            isOpen: true&#10;                                                        });&#10;                                                    }}&#10;                                                    data-selected={contextMenuOptions.entry === entry &amp;&amp; contextMenuOptions.isOpen}&#10;                                                    className={&quot;data-[selected=true]:opacity-50 data-[selected=true]:bg-white/10&quot;}&#10;                                                    onDoubleClick={() =&gt;&#10;                                                    {&#10;                                                        if (entry.is_dir &amp;&amp; !renamingEntry &amp;&amp; !newItemCreationEntry)&#10;                                                        {&#10;                                                            setPath(prev =&gt; prev ? `${prev}/${entry.filename}` : entry.filename);&#10;                                                        }&#10;                                                    }}&#10;                                                &gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        {renamingEntry === entry ?&#10;                                                            &lt;Input&#10;                                                                startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                defaultValue={entry.filename}&#10;                                                                autoFocus&#10;                                                                onBlur={e =&gt; renameSelectedEntry(e.currentTarget.value)}&#10;                                                                onKeyDown={async e =&gt;&#10;                                                                {&#10;                                                                    if (e.key === &quot;Enter&quot;) await renameSelectedEntry(e.currentTarget.value);&#10;                                                                }}&#10;                                                                radius={&quot;none&quot;}&#10;                                                                className={&quot;font-minecraft-body&quot;}&#10;                                                            /&gt; :&#10;                                                            newItemCreationEntry === entry ?&#10;                                                                &lt;Input&#10;                                                                    startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                    defaultValue={entry.filename}&#10;                                                                    autoFocus&#10;                                                                    onBlur={e =&gt; completeEntryCreation(e.currentTarget.value)}&#10;                                                                    onKeyDown={async e =&gt;&#10;                                                                    {&#10;                                                                        if (e.key === &quot;Enter&quot;) await completeEntryCreation(e.currentTarget.value);&#10;                                                                    }}&#10;                                                                    radius={&quot;none&quot;}&#10;                                                                    className={&quot;font-minecraft-body&quot;}&#10;                                                                /&gt;&#10;                                                                : (newArchiveEntry?.entry === entry &amp;&amp; !newArchiveEntry.isUploading) ?&#10;                                                                    &lt;Input&#10;                                                                        startContent={&lt;FileEntryIcon entry={{filename: &quot;.zip&quot;} as FilesystemEntry}/&gt;}&#10;                                                                        defaultValue={entry.filename}&#10;                                                                        autoFocus&#10;                                                                        onBlur={e =&gt; completeArchiveCreation(e.currentTarget.value)}&#10;                                                                        onKeyDown={async e =&gt;&#10;                                                                        {&#10;                                                                            if (e.key === &quot;Enter&quot;) await completeArchiveCreation(e.currentTarget.value);&#10;                                                                        }}&#10;                                                                        radius={&quot;none&quot;}&#10;                                                                        className={&quot;font-minecraft-body&quot;}&#10;                                                                        endContent={&lt;Chip&gt;.zip&lt;/Chip&gt;}&#10;                                                                    /&gt;&#10;                                                                    :&#10;                                                                    &lt;&gt;&lt;FileEntryIcon entry={entry}/&gt; {entry.filename}&lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;{entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        {entry === newArchiveEntry?.entry ?&#10;                                                            &lt;&gt;&#10;                                                                &lt;Progress&#10;                                                                    minValue={0}&#10;                                                                    maxValue={100}&#10;                                                                    value={newArchiveEntry.progress}&#10;                                                                    size={&quot;sm&quot;}&#10;                                                                /&gt;&#10;                                                            &lt;/&gt;&#10;                                                            :&#10;                                                            &lt;&gt;&#10;                                                                {entry.is_dir ? &quot;-&quot; : Math.convertToByteString(entry.size)}&#10;                                                            &lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        &lt;Button&#10;                                                            isIconOnly&#10;                                                            radius={&quot;none&quot;}&#10;                                                            variant={&quot;light&quot;}&#10;                                                            onPress={e =&gt;&#10;                                                            {&#10;                                                                let position = $(e.target).offset();&#10;                                                                if (!position) return;&#10;                                                                setContextMenuOptions({&#10;                                                                    entry,&#10;                                                                    x: position.left - 264,&#10;                                                                    y: position.top,&#10;                                                                    isOpen: true&#10;                                                                });&#10;                                                            }}&#10;                                                        &gt;&#10;                                                            &lt;Icon icon={&quot;pixelarticons:more-horizontal&quot;}/&gt;&#10;                                                        &lt;/Button&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            )}&#10;                                        &lt;/&gt;&#10;                                    )}&#10;                                &lt;/&gt;&#10;                            )}&#10;                        &lt;/TableBody&gt;&#10;                    &lt;/Table&gt;&#10;                &lt;/ErrorBoundary&gt;&#10;                {(!isEditingFile || selectedEntries.length !== 1) ? (&#10;                    &lt;RowContextMenu&#10;                        {...contextMenuOptions}&#10;                        onRename={setRenamingEntry}&#10;                        onDelete={deleteSelected}&#10;                        onArchive={startArchiveCreation}&#10;                        onExtract={handleExtract}&#10;                        onEdit={() =&gt;&#10;                        {&#10;                            setIsEditingFile(true);&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                        }}&#10;                        onClose={() =&gt; setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}))}&#10;                    /&gt;&#10;                ) : null}&#10;            &lt;/div&gt;&#10;            &lt;motion.div&#10;                id={&quot;server-file-editor&quot;}&#10;                ref={editorWrapperRef}&#10;                className={&quot;max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative&quot;}&#10;                initial={{opacity: 0, width: 0}}&#10;                animate={{&#10;                    opacity: isEditingFile &amp;&amp; selectedEntries.length === 1 ? 1 : 0,&#10;                    width: isEditingFile &amp;&amp; selectedEntries.length === 1 ? `${editorWidth}px` : &quot;0&quot;&#10;                }}&#10;                exit={{opacity: 0, width: 0}}&#10;                transition={{duration: isDragging ? 0 : 0.3, ease: &quot;easeInOut&quot;}}&#10;                data-editing-file={isEditingFile &amp;&amp; selectedEntries.length === 1}&#10;            &gt;&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;Editor&#10;                        className={&quot;w-full h-full&quot;}&#10;                        theme={&quot;obsidian-editor-theme&quot;}&#10;                        value={isEditingFile ? selectedFileContents : &quot;&quot;}&#10;                        language={getMonacoLanguage(selectedEntries[0]?.path ?? &quot;&quot;) ?? &quot;auto&quot;}&#10;                        onMount={handleEditorMount}&#10;                        width={`${editorWidth}px`}&#10;                        onChange={async content =&gt;&#10;                        {&#10;                            console.log(&quot;Editor content changed:&quot;, content);&#10;                            newContentRef.current = content ?? &quot;&quot;;&#10;                            setNeedsToSave(true);&#10;                            await reboundSaveContent();&#10;                        }}&#10;                        options={{&#10;                            fontSize: 14,&#10;                            minimap: {enabled: false},&#10;                            lineNumbers: &quot;on&quot;,&#10;                            scrollBeyondLastLine: false,&#10;                            automaticLayout: true,&#10;                            wordWrap: &quot;on&quot;,&#10;                            tabSize: 2,&#10;                            contextmenu: false,&#10;                            autoClosingBrackets: &quot;always&quot;,&#10;                            autoClosingOvertype: &quot;always&quot;,&#10;                            autoClosingQuotes: &quot;always&quot;,&#10;                            quickSuggestions: {&#10;                                other: true,&#10;                                comments: false,&#10;                                strings: true&#10;                            },&#10;                            suggestOnTriggerCharacters: true,&#10;                            acceptSuggestionOnEnter: &quot;on&quot;,&#10;                            tabCompletion: &quot;on&quot;,&#10;                            wordBasedSuggestions: &quot;matchingDocuments&quot;,&#10;                            parameterHints: {&#10;                                enabled: true,&#10;                                cycle: true&#10;                            },&#10;                            formatOnPaste: true,&#10;                            formatOnType: true,&#10;                            matchBrackets: &quot;always&quot;,&#10;                            autoIndent: &quot;full&quot;,&#10;                            folding: true,&#10;                            foldingStrategy: &quot;indentation&quot;,&#10;                            suggest: {&#10;                                showKeywords: true,&#10;                                showSnippets: true,&#10;                                showFunctions: true,&#10;                                showConstructors: true,&#10;                                showFields: true,&#10;                                showVariables: true,&#10;                                showClasses: true,&#10;                                showStructs: true,&#10;                                showInterfaces: true,&#10;                                showModules: true,&#10;                                showProperties: true,&#10;                                showEvents: true,&#10;                                showOperators: true,&#10;                                showUnits: true,&#10;                                showValues: true,&#10;                                showConstants: true,&#10;                                showEnums: true,&#10;                                showEnumMembers: true,&#10;                                showColors: true,&#10;                                showFiles: true,&#10;                                showReferences: true,&#10;                                showFolders: true,&#10;                                showTypeParameters: true,&#10;                                showUsers: true,&#10;                                showIssues: true&#10;                            }&#10;                        }}&#10;                    /&gt;&#10;                ) : selectedEntries.length === 1 &amp;&amp; !isTextFile(selectedEntries[0].path) ? (&#10;                    &lt;div className=&quot;flex items-center justify-center h-full&quot;&gt;&#10;                        &lt;span className=&quot;text-gray-500 font-minecraft-body&quot;&gt;Select a text file to edit&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                ) : null}&#10;&#10;                {/* Resize Handle */}&#10;                {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; (&#10;                    &lt;div&#10;                        className={&#10;                            cn(&#10;                                &quot;w-[8px] h-full bg-transparent transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none hover:bg-primary hover:opacity-50&quot;&#10;                            )&#10;                        }&#10;                        data-dragging={isDragging}&#10;                        onMouseDown={(e) =&gt;&#10;                        {&#10;                            e.preventDefault();&#10;                            setIsDragging(true);&#10;&#10;                            const startX = e.clientX;&#10;                            const startWidth = editorWidth;&#10;                            const parentWidth = editorWrapperRef.current?.parentElement?.clientWidth;&#10;&#10;                            const onMouseMove = (moveEvent: MouseEvent) =&gt;&#10;                            {&#10;                                moveEvent.preventDefault();&#10;                                const newWidth = startWidth - (moveEvent.clientX - startX);&#10;                                if (!parentWidth) return;&#10;                                setEditorWidth(Math.min(parentWidth - 300, Math.max(300, newWidth)));&#10;                            };&#10;&#10;                            const onMouseUp = (mouseEvent: MouseEvent) =&gt;&#10;                            {&#10;                                mouseEvent.preventDefault();&#10;                                setIsDragging(false);&#10;&#10;                                const newWidth = Math.max(300, startWidth - (mouseEvent.clientX - startX));&#10;                                localStorage.setItem(&quot;editor-width&quot;, newWidth.toString());&#10;                                document.removeEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                                document.removeEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                            };&#10;&#10;                            document.addEventListener(&quot;mousemove&quot;, onMouseMove);&#10;                            document.addEventListener(&quot;mouseup&quot;, onMouseUp);&#10;                        }}&#10;                    &gt;&#10;                        &lt;span&#10;                            className={&#10;                                cn(&#10;                                    &quot;w-px h-full bg-white opacity-20 transition-all duration-200 absolute left-0 top-0 cursor-ew-resize select-none&quot;,&#10;                                    &quot;hover:opacity-50 hover:bg-primary&quot;,&#10;                                    &quot;data-[dragging=true]:opacity-50 data-[dragging=true]:bg-primary&quot;&#10;                                )&#10;                            }&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/motion.div&gt;&#10;&#10;            {isEditingFile &amp;&amp; selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; (&#10;                &lt;div className={&quot;absolute bottom-8 right-8 z-50&quot;}&gt;&#10;                    &lt;Tooltip content={&quot;Save Content&quot;}&gt;&#10;                        &lt;Button radius={&quot;none&quot;} onPress={saveContent} isIconOnly isDisabled={!needsToSave} color={needsToSave ? &quot;primary&quot; : &quot;default&quot;} size={&quot;lg&quot;}&gt;&#10;                            &lt;Icon icon={&quot;pixelarticons:save&quot;}/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Overlay to prevent clicks during dragging */}&#10;            &lt;AnimatePresence&gt;&#10;                {isDragging &amp;&amp; (&#10;                    &lt;motion.div&#10;                        className=&quot;fixed inset-0 z-50 cursor-ew-resize select-none pointer-events-auto bg-primary/10&quot;&#10;                        initial={{opacity: 0}}&#10;                        animate={{opacity: 1}}&#10;                        exit={{opacity: 0}}&#10;                        transition={{duration: 0.2}}&#10;                        onClick={(e) =&gt; e.stopPropagation()}&#10;                    /&gt;&#10;                )}&#10;            &lt;/AnimatePresence&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="import {Button, ButtonGroup, Chip, cn, Input, Progress, Skeleton, Table, TableBody, TableCell, TableColumn, TableHeader, TableRow} from &quot;@heroui/react&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import {KeyboardEvent, useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {FilesystemData, FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import &quot;../../../../ts/math-ext.ts&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {ContextMenuOptions, RowContextMenu} from &quot;./RowContextMenu.tsx&quot;;&#10;import {useMessage} from &quot;../../../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../../../MessageModal.tsx&quot;;&#10;import {FileTableBreadcrumbs} from &quot;./FileTableBreadcrumbs.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {ErrorBoundary} from &quot;../../../ErrorBoundry.tsx&quot;;&#10;import {FileEntryIcon} from &quot;./FileEntryIcon.tsx&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {ServerFileEditor, ServerFileEditorRef} from &quot;./ServerFileEditor.tsx&quot;;&#10;import {AnimatePresence, motion} from &quot;framer-motion&quot;;&#10;&#10;type UploadProgress = {&#10;    entry: FilesystemEntry;&#10;    progress: number;&#10;    files: string[]&#10;    isUploading: boolean;&#10;    uploadGroup?: string;&#10;    filesProcessed?: number;&#10;    totalFiles?: number;&#10;    operationType: &quot;upload&quot; | &quot;archive&quot; | &quot;extract&quot;;&#10;}&#10;&#10;export function ServerFiles()&#10;{&#10;    const {getEntries, renameEntry, createEntry, deleteEntry, uploadFile, archiveFiles, extractArchive, getFileContents, setFileContents} = useServer();&#10;    const {open} = useMessage();&#10;    const [path, setPath] = useState(&quot;&quot;);&#10;    const [data, setData] = useState&lt;FilesystemData&gt;();&#10;    const [selectedEntries, setSelectedEntries] = useState&lt;FilesystemEntry[]&gt;([]);&#10;    const [contextMenuOptions, setContextMenuOptions] = useState&lt;ContextMenuOptions&gt;({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [renamingEntry, setRenamingEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newItemCreationEntry, setNewItemCreationEntry] = useState&lt;FilesystemEntry | undefined&gt;(undefined);&#10;    const [newArchiveEntry, setNewArchiveEntry] = useState&lt;UploadProgress | undefined&gt;(undefined);&#10;    const [fileUploadEntries, setFileUploadEntries] = useState&lt;UploadProgress[]&gt;([]);&#10;    const [isDraggingOver, setIsDraggingOver] = useState(false);&#10;    const [isEditingFile, setIsEditingFile] = useState(false);&#10;    const [selectedFileContents, setSelectedFileContents] = useState(&quot;&quot;);&#10;    const [isDragging, setIsDragging] = useState(false);&#10;    const [editorWidth, setEditorWidth] = useState(() =&gt;&#10;    {&#10;        // Load saved width from localStorage or use default&#10;        const savedWidth = localStorage.getItem(&quot;editor-width&quot;);&#10;        return savedWidth ? parseInt(savedWidth, 10) : 400;&#10;    });&#10;    const [needsToSave, setNeedsToSave] = useState(false);&#10;    const newContentRef = useRef&lt;string&gt;(&quot;&quot;);&#10;    const serverFileEditorRef = useRef&lt;ServerFileEditorRef&gt;(null);&#10;&#10;    const selectedEntriesRef = useRef&lt;FilesystemEntry[]&gt;([]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        selectedEntriesRef.current = selectedEntries;&#10;    }, [selectedEntries]);&#10;&#10;    const scrollToTop = useCallback(() =&gt;&#10;    {&#10;        $(&quot;#server-files-table&quot;).parent().scrollTop(0);&#10;    }, [path]);&#10;&#10;    const saveContent = useCallback(async () =&gt;&#10;    {&#10;        const currentSelectedEntries = selectedEntriesRef.current;&#10;        const file = currentSelectedEntries[0]?.path;&#10;&#10;        console.log(&quot;Attempting to save content:&quot;, newContentRef, &quot;Needs to save:&quot;, needsToSave, &quot;File:&quot;, currentSelectedEntries);&#10;&#10;        setNeedsToSave(false);&#10;&#10;        try&#10;        {&#10;            if (!file || !newContentRef.current)&#10;            {&#10;                console.warn(&quot;No file selected or content is empty, skipping save.&quot;);&#10;                return;&#10;            }&#10;&#10;            // Save the content to the file&#10;            console.log(&quot;Saving file:&quot;, file, newContentRef.current);&#10;            await setFileContents(file, newContentRef.current);&#10;            newContentRef.current = &quot;&quot;;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save file:&quot;, error);&#10;            await open({&#10;                title: &quot;Save File Failed&quot;,&#10;                body: &quot;An error occurred while saving the file. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [newContentRef, needsToSave, open, setFileContents]);&#10;&#10;    const handleContentChange = useCallback((content: string) =&gt; {&#10;        console.log(&quot;Editor content changed:&quot;, content);&#10;        newContentRef.current = content;&#10;        setNeedsToSave(true);&#10;    }, []);&#10;&#10;    const handleDragStart = useCallback(() =&gt; {&#10;        setIsDragging(true);&#10;    }, []);&#10;&#10;    const handleDragEnd = useCallback(() =&gt; {&#10;        setIsDragging(false);&#10;    }, []);&#10;&#10;    const handleWidthChange = useCallback((width: number) =&gt; {&#10;        setEditorWidth(width);&#10;    }, []);&#10;&#10;    const upload = useCallback(async (files: File[]) =&gt;&#10;    {&#10;        let uploadGroup = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);&#10;        let promises = [];&#10;        for (let file of files)&#10;        {&#10;            let entry = {filename: file.name, path, is_dir: false, size: file.size, file_type: file.type, operationType: &quot;upload&quot;} as FilesystemEntry;&#10;            setFileUploadEntries(prev =&gt; [...prev, {entry, progress: 0, files: [file.name], isUploading: true, uploadGroup, operationType: &quot;upload&quot;}]);&#10;            let totalSize = file.size;&#10;            const {promise} = await uploadFile(file, entry.path, async bytes =&gt;&#10;                {&#10;                    let progress = bytes / totalSize;&#10;                    setFileUploadEntries(prev =&gt; prev.map(upload =&gt; upload.entry === entry ? {...upload, progress} : upload));&#10;                    console.log(&quot;Upload progress:&quot;, progress);&#10;                }, async () =&gt;&#10;                {&#10;                    // On Canceled&#10;                    setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.entry !== entry));&#10;                    await refresh();&#10;                }&#10;            );&#10;            promises.push(promise);&#10;        }&#10;        await Promise.all(promises);&#10;        await refresh();&#10;        setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== uploadGroup));&#10;    }, [setFileUploadEntries, fileUploadEntries, path]);&#10;&#10;    const refresh = useCallback(async () =&gt;&#10;    {&#10;        scrollToTop();&#10;        setIsLoading(true);&#10;        const data = await getEntries(path);&#10;        data.entries = data.entries.sort((a, b) =&gt;&#10;        {&#10;            if (a.is_dir &amp;&amp; !b.is_dir) return -1; // Directories first&#10;            if (!a.is_dir &amp;&amp; b.is_dir) return 1; // Files after directories&#10;            return a.filename.localeCompare(b.filename); // Sort alphabetically&#10;        });&#10;        setData(data);&#10;        setIsLoading(false);&#10;        setSelectedEntries([]);&#10;        setContextMenuOptions({entry: undefined, x: 0, y: 0, isOpen: false});&#10;    }, [path, data]);&#10;&#10;    const renameSelectedEntry = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!renamingEntry || newName.trim() === &quot;&quot; || newName === renamingEntry.filename)&#10;        {&#10;            setRenamingEntry(undefined);&#10;            return;&#10;        }&#10;&#10;        let newPath = `${path}/${newName}`;&#10;        try&#10;        {&#10;            await renameEntry(renamingEntry.path, newPath);&#10;            setRenamingEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Rename Failed&quot;,&#10;                body: &quot;An error occurred while renaming the entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [renamingEntry, path]);&#10;&#10;    const startEntryCreation = useCallback(async (directory: boolean) =&gt;&#10;    {&#10;        scrollToTop();&#10;        let filename = `New ${directory ? &quot;Directory&quot; : &quot;File.txt&quot;}`;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === filename))&#10;        {&#10;            index++;&#10;            filename = `New ${directory ? &quot;Directory&quot; : &quot;File&quot;} (${index}).txt`;&#10;        }&#10;        let entry = {filename, path, is_dir: directory, size: 0, file_type: directory ? &quot;Directory&quot; : &quot;File&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewItemCreationEntry(entry);&#10;    }, [data, path]);&#10;&#10;    const completeEntryCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        if (!newItemCreationEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            await createEntry(newName, path, newItemCreationEntry.is_dir);&#10;            setNewItemCreationEntry(undefined);&#10;            await refresh();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to rename entry:&quot;, error);&#10;            await open({&#10;                title: &quot;Creation Failed&quot;,&#10;                body: &quot;An error occurred while create new entry. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [data, path]);&#10;&#10;    const startArchiveCreation = useCallback(async () =&gt;&#10;    {&#10;        setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        scrollToTop();&#10;        let filename = &quot;New Archive&quot;;&#10;        let index = 0;&#10;        while (data?.entries.some(entry =&gt; entry.filename === `${filename}.zip`))&#10;        {&#10;            index++;&#10;            filename = `New Archive (${index})`;&#10;        }&#10;        let entry = {filename, path, is_dir: false, size: 0, file_type: &quot;Archive&quot;} as FilesystemEntry;&#10;        setData(prev =&gt; ({...prev, entries: [entry, ...(prev?.entries || [])]} as FilesystemData));&#10;        setNewArchiveEntry({entry, progress: 0, files: selectedEntries.map(entry =&gt; entry.path), isUploading: false, operationType: &quot;archive&quot;});&#10;    }, [path, data, selectedEntries]);&#10;&#10;    const completeArchiveCreation = useCallback(async (newName: string) =&gt;&#10;    {&#10;        setNewArchiveEntry(prev =&gt; prev ? {...prev, isUploading: true, operationType: &quot;archive&quot;} : undefined);&#10;        if (!newArchiveEntry || newName.trim() === &quot;&quot;)&#10;        {&#10;            setNewArchiveEntry(undefined);&#10;            await refresh();&#10;            return;&#10;        }&#10;&#10;        try&#10;        {&#10;            archiveFiles(`${newName}.zip`, newArchiveEntry.files, path, progress =&gt;&#10;            {&#10;                setNewArchiveEntry(prev =&gt; prev ? {...prev, progress} : undefined);&#10;                console.log(&quot;Archive progress:&quot;, progress);&#10;            }, async () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;                await refresh();&#10;            }, error =&gt;&#10;            {&#10;                open({&#10;                    title: &quot;Archive Creation Failed&quot;,&#10;                    body: `An error occurred while creating the archive: ${error}`,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;                console.error(&quot;Failed to create archive:&quot;, error);&#10;                setNewArchiveEntry(undefined);&#10;            }, () =&gt;&#10;            {&#10;                setNewArchiveEntry(undefined);&#10;            });&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to create archive:&quot;, error);&#10;            await open({&#10;                title: &quot;Archive Creation Failed&quot;,&#10;                body: &quot;An error occurred while creating the archive. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            setNewArchiveEntry(undefined);&#10;        }&#10;    }, [data, path, newArchiveEntry]);&#10;&#10;    const handleExtract = useCallback(async (entry: FilesystemEntry, outputPath?: string) =&gt;&#10;    {&#10;        scrollToTop();&#10;&#10;        // Determine the output path - either provided or current directory&#10;        const extractPath = outputPath || path;&#10;&#10;        // Create a unique ID for this extraction operation&#10;        const extractId = `extract-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;&#10;&#10;        // Create a temporary entry to show progress&#10;        const extractEntry: FilesystemEntry = {&#10;            filename: `Extracting ${entry.filename}...`,&#10;            path: `${path}/extracting-${entry.filename}`,&#10;            is_dir: false,&#10;            size: 0,&#10;            file_type: &quot;Extracting&quot;&#10;        };&#10;&#10;        const progressEntry: UploadProgress = {&#10;            entry: extractEntry,&#10;            progress: 0,&#10;            files: [entry.path],&#10;            isUploading: true,&#10;            operationType: &quot;extract&quot;,&#10;            filesProcessed: 0,&#10;            totalFiles: 0,&#10;            uploadGroup: extractId // Use the unique ID to track this specific extraction&#10;        };&#10;&#10;        setFileUploadEntries(prev =&gt; [...prev, progressEntry]);&#10;&#10;        // Helper function to remove the progress entry&#10;        const removeProgressEntry = () =&gt;&#10;        {&#10;            setFileUploadEntries(prev =&gt; prev.filter(upload =&gt; upload.uploadGroup !== extractId));&#10;        };&#10;&#10;        try&#10;        {&#10;            const {trackerId} = extractArchive(&#10;                entry.path,&#10;                extractPath,&#10;                (progress, filesProcessed, totalFiles) =&gt;&#10;                {&#10;                    setFileUploadEntries(prev =&gt;&#10;                        prev.map(upload =&gt;&#10;                            upload.uploadGroup === extractId&#10;                                ? {...upload, progress, filesProcessed, totalFiles}&#10;                                : upload&#10;                        )&#10;                    );&#10;                    console.log(&quot;Extract progress:&quot;, progress, &quot;Files:&quot;, filesProcessed, &quot;/&quot;, totalFiles);&#10;                },&#10;                async () =&gt;&#10;                {&#10;                    // Success - remove progress entry and refresh&#10;                    console.log(&quot;Extract completed successfully, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                    await refresh();&#10;                },&#10;                (error) =&gt;&#10;                {&#10;                    // Error - remove progress entry and show an error&#10;                    console.error(&quot;Failed to extract archive:&quot;, error);&#10;                    removeProgressEntry();&#10;                    open({&#10;                        title: &quot;Extract Failed&quot;,&#10;                        body: `An error occurred while extracting the archive: ${error}`,&#10;                        responseType: MessageResponseType.Close,&#10;                        severity: &quot;danger&quot;&#10;                    });&#10;                },&#10;                () =&gt;&#10;                {&#10;                    // Cancelled - remove progress entry&#10;                    console.log(&quot;Extract cancelled, removing progress entry&quot;);&#10;                    removeProgressEntry();&#10;                }&#10;            );&#10;&#10;            // Store the cancel function and track ID for potential future use&#10;            console.log(&quot;Extract operation started with track ID:&quot;, trackerId);&#10;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to start extract:&quot;, error);&#10;            removeProgressEntry();&#10;            await open({&#10;                title: &quot;Extract Failed&quot;,&#10;                body: &quot;An error occurred while starting the extraction. Please try again.&quot;,&#10;                responseType: MessageResponseType.Close,&#10;                severity: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [path, extractArchive, open, refresh]);&#10;&#10;    const handleKeyDown = useCallback(async (e: KeyboardEvent&lt;HTMLTableElement&gt;) =&gt;&#10;    {&#10;        if (renamingEntry !== undefined)&#10;        {&#10;            e.preventDefault();&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Escape&quot;)&#10;        {&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        }&#10;        if (e.key === &quot;F2&quot;)&#10;        {&#10;            // Start renaming the first selected entry&#10;            if (selectedEntries.length &gt; 0)&#10;            {&#10;                e.preventDefault();&#10;                setRenamingEntry(selectedEntries[0]);&#10;                return;&#10;            }&#10;        }&#10;&#10;        if (e.ctrlKey &amp;&amp; e.key === &quot;a&quot;)&#10;        {&#10;            // Select all entries&#10;            e.preventDefault();&#10;            setSelectedEntries(data?.entries || []);&#10;            return;&#10;        }&#10;&#10;        if (e.key === &quot;Delete&quot; || e.key === &quot;Backspace&quot;)&#10;        {&#10;            await deleteSelected(selectedEntries);&#10;        }&#10;    }, [renamingEntry, refresh, renameSelectedEntry, selectedEntries]);&#10;&#10;    const deleteSelected = useCallback(async (entries: FilesystemEntry[]) =&gt;&#10;    {&#10;        // Handle the delete action for selected entries&#10;        if (entries.length &gt; 0)&#10;        {&#10;            let response = await open({&#10;                title: &quot;Delete Files&quot;,&#10;                body: `Are you sure you want to delete ${entries.length &gt; 1 ? `${entries.length} files` : entries[0].filename}? This action cannot be undone.`,&#10;                responseType: MessageResponseType.OkayCancel,&#10;                severity: &quot;danger&quot;&#10;            });&#10;            if (response)&#10;            {&#10;                // Implement delete logic here&#10;                await deleteEntry(entries.map(entry =&gt; entry.path));&#10;                await refresh();&#10;            }&#10;        }&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        refresh().then();&#10;    }, [path]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        $(document).on(&quot;click&quot;, e =&gt;&#10;        {&#10;            // Close the context menu when clicking outside&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        }).on(&quot;blur&quot;, e =&gt;&#10;        {&#10;            // Close the context menu when focus is lost&#10;            if (!$(e.target).closest(&quot;#server-files-context-menu&quot;).length)&#10;            {&#10;                setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;            }&#10;        });&#10;        $(&quot;#server-files-table&quot;).parent().on(&quot;scroll&quot;, () =&gt;&#10;        {&#10;            // Close the context menu when scrolling&#10;            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;        });&#10;        return () =&gt;&#10;        {&#10;            $(document).off(&quot;click&quot;);&#10;            $(document).off(&quot;blur&quot;);&#10;            $(&quot;#server-files-table&quot;).parent().off(&quot;scroll&quot;);&#10;        };&#10;    }, []);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedEntries.length === 1 &amp;&amp; isTextFile(selectedEntries[0].path) &amp;&amp; isEditingFile)&#10;        {&#10;            setSelectedFileContents(&quot;&quot;);&#10;            setNeedsToSave(false);&#10;&#10;            // Load file contents for a single text file selection&#10;            getFileContents(selectedEntries[0].path).then(async contents =&gt;&#10;            {&#10;                setSelectedFileContents(contents);&#10;                setIsEditingFile(true);&#10;            }).catch(async error =&gt;&#10;            {&#10;                console.error(&quot;Failed to load file contents:&quot;, error);&#10;                await open({&#10;                    title: &quot;Load File Failed&quot;,&#10;                    body: &quot;An error occurred while loading the file contents. Please try again.&quot;,&#10;                    responseType: MessageResponseType.Close,&#10;                    severity: &quot;danger&quot;&#10;                });&#10;            });&#10;        } else&#10;        {&#10;            // Reset file contents when selection changes or multiple files are selected&#10;            setSelectedFileContents(&quot;&quot;);&#10;        }&#10;    }, [selectedEntries, isEditingFile]);&#10;&#10;    return (&#10;        &lt;div className={&#10;            cn(&#10;                &quot;flex flex-row gap-2 bg-default-50 overflow-x-hidden border-2 border-default-500/10&quot;&#10;            )&#10;        }&gt;&#10;            &lt;div&#10;                id={&quot;server-file-browser&quot;}&#10;                className={&#10;                    cn(&#10;                        &quot;flex flex-col gap-2 p-4 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] relative grow min-w-[300px]&quot;&#10;                    )&#10;                }&#10;                onDragStart={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnd={() =&gt; setIsDraggingOver(false)}&#10;                onDragEnter={() =&gt; setIsDraggingOver(true)}&#10;                onDragExit={() =&gt; setIsDraggingOver(false)}&#10;                onDragOver={e =&gt; e.preventDefault()}&#10;                onDrop={async e =&gt;&#10;                {&#10;                    e.preventDefault();&#10;                    console.log(&quot;Files dropped:&quot;, e.dataTransfer.files);&#10;                    setIsDraggingOver(false);&#10;                    await upload([...e.dataTransfer.files]);&#10;                }}&#10;                data-dragging-over={isDraggingOver}&#10;            &gt;&#10;                {isDraggingOver &amp;&amp; (&#10;                    &lt;div className=&quot;absolute inset-0 z-30 border-dotted border-4 border-primary bg-background/90 flex items-center justify-center&quot;&gt;&#10;                        &lt;span className=&quot;font-minecraft-body text-4xl&quot;&gt;Drop Files to Upload&lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                &lt;div className={&quot;flex flex-row justify-between items-center&quot;}&gt;&#10;                    &lt;FileTableBreadcrumbs onNavigate={setPath} paths={path.split(&quot;/&quot;).filter(p =&gt; p.trim() !== &quot;&quot;)}/&gt;&#10;                    &lt;ButtonGroup radius={&quot;none&quot;} variant={&quot;flat&quot;}&gt;&#10;                        &lt;Tooltip content={&quot;New File&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(false)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:file-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;New Directory&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; startEntryCreation(true)}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:folder-plus&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Toggle File Editor&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} onPress={() =&gt; setIsEditingFile(prev =&gt; !prev)} color={isEditingFile ? &quot;primary&quot; : &quot;default&quot;}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:notes&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                        &lt;Tooltip content={&quot;Refresh Files&quot;}&gt;&#10;                            &lt;Button radius={&quot;none&quot;} isIconOnly className={&quot;text-xl&quot;} isDisabled={isLoading} onPress={refresh}&gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:repeat&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt;&#10;                    &lt;/ButtonGroup&gt;&#10;                &lt;/div&gt;&#10;                &lt;ErrorBoundary&gt;&#10;                    &lt;Table&#10;                        id={&quot;server-files-table&quot;}&#10;                        removeWrapper&#10;                        radius={&quot;none&quot;}&#10;                        className={cn(&quot;font-minecraft-body overflow-y-auto&quot;)}&#10;                        fullWidth&#10;                        color={&quot;primary&quot;}&#10;                        aria-label={&quot;Server Files&quot;}&#10;                        selectionMode={&quot;multiple&quot;}&#10;                        selectionBehavior={&quot;replace&quot;}&#10;                        showSelectionCheckboxes={false}&#10;                        isHeaderSticky&#10;                        classNames={{&#10;                            tr: &quot;!rounded-none&quot;,&#10;                            th: &quot;backdrop-blur-md bg-default-50/50 !rounded-none&quot;&#10;                        }}&#10;                        selectedKeys={selectedEntries.map(entry =&gt; entry.filename)}&#10;                        onSelectionChange={keys =&gt;&#10;                        {&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                            const selected = [...keys].map(key =&gt; data?.entries.find(entry =&gt; entry.filename === key)).filter(Boolean) as FilesystemEntry[];&#10;                            setSelectedEntries(selected);&#10;                        }}&#10;                        isKeyboardNavigationDisabled={true}&#10;                        onKeyDown={handleKeyDown}&#10;                    &gt;&#10;                        &lt;TableHeader&gt;&#10;                            &lt;TableColumn&gt;Name&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Type&lt;/TableColumn&gt;&#10;                            &lt;TableColumn hidden={isEditingFile}&gt;Size&lt;/TableColumn&gt;&#10;                            &lt;TableColumn width={48} hideHeader hidden={isEditingFile}&gt;Action&lt;/TableColumn&gt;&#10;                        &lt;/TableHeader&gt;&#10;                        &lt;TableBody&gt;&#10;                            {isLoading ? Array.from({length: 5}, (_, i) =&gt; (&#10;                                &lt;TableRow key={`skeleton-${i}`}&gt;&#10;                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-8&quot;}/&gt;&#10;                                        &lt;Skeleton className={&quot;w-32 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-24 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-16 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                    &lt;TableCell&gt;&#10;                                        &lt;Skeleton className={&quot;w-8 h-6&quot;}/&gt;&#10;                                    &lt;/TableCell&gt;&#10;                                &lt;/TableRow&gt;&#10;                            )) : (&#10;                                &lt;&gt;&#10;                                    {data?.entries?.length === 0 &amp;&amp; fileUploadEntries.length === 0 ? (&#10;                                        &lt;TableRow&gt;&#10;                                            &lt;TableCell colSpan={4} className=&quot;text-center text-gray-500&quot;&gt;&#10;                                                This directory is empty&#10;                                            &lt;/TableCell&gt;&#10;                                        &lt;/TableRow&gt;&#10;                                    ) : (&#10;                                        &lt;&gt;&#10;                                            {fileUploadEntries.map(upload =&gt; (&#10;                                                &lt;TableRow key={`upload-${upload.entry.filename}`}&gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        &lt;FileEntryIcon entry={upload.entry}/&gt; {upload.entry.filename}&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;{upload.entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;}&gt;&#10;                                                        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;&#10;                                                            &lt;Progress&#10;                                                                minValue={0}&#10;                                                                maxValue={upload.operationType === &quot;upload&quot; ? 1 : 100}&#10;                                                                value={upload.progress}&#10;                                                                size={&quot;sm&quot;}&#10;                                                            /&gt;&#10;                                                            {upload.operationType === &quot;extract&quot; &amp;&amp; upload.totalFiles &amp;&amp; upload.totalFiles &gt; 0 &amp;&amp; (&#10;                                                                &lt;span className=&quot;text-xs text-gray-400&quot;&gt;&#10;                                                                    {upload.filesProcessed || 0}/{upload.totalFiles} files&#10;                                                                &lt;/span&gt;&#10;                                                            )}&#10;                                                        &lt;/div&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell&gt;&#10;                                                        &lt;&gt;&lt;/&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            ))}&#10;                                            {data?.entries.map(entry =&gt;&#10;                                                &lt;TableRow&#10;                                                    key={entry.filename}&#10;                                                    onContextMenu={e =&gt;&#10;                                                    {&#10;                                                        e.preventDefault();&#10;                                                        setContextMenuOptions({&#10;                                                            entry: selectedEntries.length &gt; 1 ? selectedEntries : entry,&#10;                                                            x: e.clientX - 30,&#10;                                                            y: e.clientY - 50,&#10;                                                            isOpen: true&#10;                                                        });&#10;                                                    }}&#10;                                                    data-selected={contextMenuOptions.entry === entry &amp;&amp; contextMenuOptions.isOpen}&#10;                                                    className={&quot;data-[selected=true]:opacity-50 data-[selected=true]:bg-white/10&quot;}&#10;                                                    onDoubleClick={() =&gt;&#10;                                                    {&#10;                                                        if (entry.is_dir &amp;&amp; !renamingEntry &amp;&amp; !newItemCreationEntry)&#10;                                                        {&#10;                                                            setPath(prev =&gt; prev ? `${prev}/${entry.filename}` : entry.filename);&#10;                                                        }&#10;                                                    }}&#10;                                                &gt;&#10;                                                    &lt;TableCell className={&quot;flex items-center h-14 gap-2&quot;}&gt;&#10;                                                        {renamingEntry === entry ?&#10;                                                            &lt;Input&#10;                                                                startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                defaultValue={entry.filename}&#10;                                                                autoFocus&#10;                                                                onBlur={e =&gt; renameSelectedEntry(e.currentTarget.value)}&#10;                                                                onKeyDown={async e =&gt;&#10;                                                                {&#10;                                                                    if (e.key === &quot;Enter&quot;) await renameSelectedEntry(e.currentTarget.value);&#10;                                                                }}&#10;                                                                radius={&quot;none&quot;}&#10;                                                                className={&quot;font-minecraft-body&quot;}&#10;                                                            /&gt; :&#10;                                                            newItemCreationEntry === entry ?&#10;                                                                &lt;Input&#10;                                                                    startContent={&lt;FileEntryIcon entry={entry}/&gt;}&#10;                                                                    defaultValue={entry.filename}&#10;                                                                    autoFocus&#10;                                                                    onBlur={e =&gt; completeEntryCreation(e.currentTarget.value)}&#10;                                                                    onKeyDown={async e =&gt;&#10;                                                                    {&#10;                                                                        if (e.key === &quot;Enter&quot;) await completeEntryCreation(e.currentTarget.value);&#10;                                                                    }}&#10;                                                                    radius={&quot;none&quot;}&#10;                                                                    className={&quot;font-minecraft-body&quot;}&#10;                                                                /&gt;&#10;                                                                : (newArchiveEntry?.entry === entry &amp;&amp; !newArchiveEntry.isUploading) ?&#10;                                                                    &lt;Input&#10;                                                                        startContent={&lt;FileEntryIcon entry={{filename: &quot;.zip&quot;} as FilesystemEntry}/&gt;}&#10;                                                                        defaultValue={entry.filename}&#10;                                                                        autoFocus&#10;                                                                        onBlur={e =&gt; completeArchiveCreation(e.currentTarget.value)}&#10;                                                                        onKeyDown={async e =&gt;&#10;                                                                        {&#10;                                                                            if (e.key === &quot;Enter&quot;) await completeArchiveCreation(e.currentTarget.value);&#10;                                                                        }}&#10;                                                                        radius={&quot;none&quot;}&#10;                                                                        className={&quot;font-minecraft-body&quot;}&#10;                                                                        endContent={&lt;Chip&gt;.zip&lt;/Chip&gt;}&#10;                                                                    /&gt;&#10;                                                                    :&#10;                                                                    &lt;&gt;&lt;FileEntryIcon entry={entry}/&gt; {entry.filename}&lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;{entry.file_type}&lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        {entry === newArchiveEntry?.entry ?&#10;                                                            &lt;&gt;&#10;                                                                &lt;Progress&#10;                                                                    minValue={0}&#10;                                                                    maxValue={100}&#10;                                                                    value={newArchiveEntry.progress}&#10;                                                                    size={&quot;sm&quot;}&#10;                                                                /&gt;&#10;                                                            &lt;/&gt;&#10;                                                            :&#10;                                                            &lt;&gt;&#10;                                                                {entry.is_dir ? &quot;-&quot; : Math.convertToByteString(entry.size)}&#10;                                                            &lt;/&gt;&#10;                                                        }&#10;                                                    &lt;/TableCell&gt;&#10;                                                    &lt;TableCell className={&quot;text-gray-500&quot;} hidden={isEditingFile &amp;&amp; selectedEntries.length === 1}&gt;&#10;                                                        &lt;Button&#10;                                                            isIconOnly&#10;                                                            radius={&quot;none&quot;}&#10;                                                            variant={&quot;light&quot;}&#10;                                                            onPress={e =&gt;&#10;                                                            {&#10;                                                                let position = $(e.target).offset();&#10;                                                                if (!position) return;&#10;                                                                setContextMenuOptions({&#10;                                                                    entry,&#10;                                                                    x: position.left - 264,&#10;                                                                    y: position.top,&#10;                                                                    isOpen: true&#10;                                                                });&#10;                                                            }}&#10;                                                        &gt;&#10;                                                            &lt;Icon icon={&quot;pixelarticons:more-horizontal&quot;}/&gt;&#10;                                                        &lt;/Button&gt;&#10;                                                    &lt;/TableCell&gt;&#10;                                                &lt;/TableRow&gt;&#10;                                            )}&#10;                                        &lt;/&gt;&#10;                                    )}&#10;                                &lt;/&gt;&#10;                            )}&#10;                        &lt;/TableBody&gt;&#10;                    &lt;/Table&gt;&#10;                &lt;/ErrorBoundary&gt;&#10;                {(!isEditingFile || selectedEntries.length !== 1) ? (&#10;                    &lt;RowContextMenu&#10;                        {...contextMenuOptions}&#10;                        onRename={setRenamingEntry}&#10;                        onDelete={deleteSelected}&#10;                        onArchive={startArchiveCreation}&#10;                        onExtract={handleExtract}&#10;                        onEdit={() =&gt;&#10;                        {&#10;                            setIsEditingFile(true);&#10;                            setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}));&#10;                        }}&#10;                        onClose={() =&gt; setContextMenuOptions(prev =&gt; ({...prev, isOpen: false}))}&#10;                    /&gt;&#10;                ) : null}&#10;            &lt;/div&gt;&#10;            &lt;ServerFileEditor&#10;                ref={serverFileEditorRef}&#10;                isEditingFile={isEditingFile}&#10;                selectedEntries={selectedEntries}&#10;                selectedFileContents={selectedFileContents}&#10;                editorWidth={editorWidth}&#10;                isDragging={isDragging}&#10;                needsToSave={needsToSave}&#10;                onContentChange={handleContentChange}&#10;                onSave={saveContent}&#10;                onWidthChange={handleWidthChange}&#10;                onDragStart={handleDragStart}&#10;                onDragEnd={handleDragEnd}&#10;            /&gt;&#10;&#10;            {/* Overlay to prevent clicks during dragging */}&#10;            &lt;AnimatePresence&gt;&#10;                {isDragging &amp;&amp; (&#10;                    &lt;motion.div&#10;                        className=&quot;fixed inset-0 z-50 cursor-ew-resize select-none pointer-events-auto bg-primary/10&quot;&#10;                        initial={{opacity: 0}}&#10;                        animate={{opacity: 1}}&#10;                        exit={{opacity: 0}}&#10;                        transition={{duration: 0.2}}&#10;                        onClick={(e) =&gt; e.stopPropagation()}&#10;                    /&gt;&#10;                )}&#10;            &lt;/AnimatePresence&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/providers/ServerProvider.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/providers/ServerProvider.tsx" />
              <option name="originalContent" value="import {createContext, ReactNode, useCallback, useContext, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {FileSystem, FilesystemData, FilesystemEntry} from &quot;../ts/filesystem.ts&quot;;&#10;&#10;export type Server =&#10;    {&#10;        /** Unique identifier for the server */&#10;        id: string;&#10;        /** Directory name where server files are stored, e.g. 'my_minecraft_server' */&#10;        directory: string;&#10;        /** Additional JVM arguments excluding -Xmx and -Xms */&#10;        java_args: string;&#10;        /** Maximum memory in GB for JVM -Xmx argument */&#10;        max_memory: number;&#10;        /** Minimum memory in GB for JVM -Xms argument */&#10;        min_memory: number;&#10;        /** Additional Minecraft server arguments */&#10;        minecraft_args: string;&#10;        /** Name/path of the server JAR file */&#10;        server_jar: string;&#10;        /** Whether UPnP port forwarding is enabled */&#10;        upnp: boolean;&#10;        /** Server status: 'stopped', 'starting', 'running', 'stopping', 'error' */&#10;        status: ServerStatus;&#10;        /** Whether the server should start automatically on boot */&#10;        auto_start: boolean;&#10;        /** Whether the server should restart automatically if it crashes */&#10;        auto_restart: boolean;&#10;        /** Whether automatic backups are enabled */&#10;        backup_enabled: boolean;&#10;        /** Backup interval in minutes */&#10;        backup_interval: number;&#10;        /** Optional server description */&#10;        description: string | null;&#10;        /** ID of the user who owns this server */&#10;        owner_id: number;&#10;        /** Timestamp of when the server was created (seconds since epoch) */&#10;        created_at: number;&#10;        /** Timestamp of when the server was last updated (seconds since epoch) */&#10;        updated_at: number;&#10;        /** Timestamp of when the server was last started (seconds since epoch) */&#10;        last_started: number | null;&#10;    } &amp; CreateServerData&#10;&#10;export type CreateServerData = {&#10;    /** Name of the server, e.g. 'My Minecraft Server' */&#10;    name: string;&#10;    /** Server type: 'vanilla', 'fabric', 'forge', 'neoforge', 'quilt', or 'custom' */&#10;    server_type: LoaderType;&#10;    /** Minecraft version, e.g. '1.20.1', '1.19.4', or 'custom' */&#10;    minecraft_version: string;&#10;    /** Loader version e.g. '0.14.0', '1.20.1-44.1.23', or 'custom' */&#10;    loader_version: string;&#10;    /** Path to Java executable, e.g. '/usr/bin/java' or 'java' for system PATH */&#10;    java_executable: string;&#10;}&#10;&#10;export type LoaderType = &quot;vanilla&quot; | &quot;fabric&quot; | &quot;forge&quot; | &quot;neoforge&quot; | &quot;quilt&quot; | &quot;custom&quot;;&#10;export type ServerStatus = &quot;idle&quot; | &quot;running&quot; | &quot;stopped&quot; | &quot;error&quot; | &quot;starting&quot; | &quot;stopping&quot; | &quot;crashed&quot; | &quot;hanging&quot;;&#10;&#10;interface ServerContextType&#10;{&#10;    server: Server | null;&#10;    servers: Server[];&#10;    loadServer: (id: string) =&gt; Promise&lt;void&gt;;&#10;    unloadServer: () =&gt; void;&#10;    loadServers: () =&gt; Promise&lt;void&gt;;&#10;    createServer: (server: CreateServerData) =&gt; Promise&lt;string&gt;;&#10;    updateServer: (server: Partial&lt;Server&gt;, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    startServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    stopServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    restartServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    killServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    sendCommand: (command: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    subscribeToConsole: (callback: (data: string) =&gt; void, serverId?: string) =&gt; () =&gt; void;&#10;    cleanupConsoleConnection: (serverId?: string) =&gt; void;&#10;    hasActiveConsoleConnection: (serverId?: string) =&gt; boolean;&#10;    backupServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getServerStatus: (serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    isServerRunning: (serverId?: string) =&gt; boolean;&#10;    // Filesystem functions&#10;    getEntries: (path: string, serverId?: string) =&gt; Promise&lt;FilesystemData&gt;;&#10;    downloadEntry: (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    copyEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    moveEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    renameEntry: (source: string, destination: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteEntry: (path: string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFile: (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string) =&gt; Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;;&#10;    createEntry: (filename: string, cwd: string, isDirectory: boolean, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    searchFiles: (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string) =&gt; Promise&lt;FilesystemEntry[]&gt;;&#10;    archiveFiles: (filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelArchive: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFromUrl: (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getFileContents: (path: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    setFileContents: (path: string, contents: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    // Logging and console functions&#10;    getLogs: (serverId?: string) =&gt; Promise&lt;string[]&gt;;&#10;    getLog: (filename: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;}&#10;&#10;const ServerContext = createContext&lt;ServerContextType | undefined&gt;(undefined);&#10;&#10;export function ServerProvider({children}: { children: ReactNode })&#10;{&#10;    const [server, setServer] = useState&lt;Server | null&gt;(null);&#10;    const [servers, setServers] = useState&lt;Server[]&gt;([]);&#10;&#10;    // Connection tracking for console subscriptions&#10;    const consoleConnections = useRef&lt;Map&lt;string, () =&gt; void&gt;&gt;(new Map());&#10;&#10;    const loadServer = async (id: string) =&gt;&#10;    {&#10;        let server: Server = await $.get(`/api/server/${id}`);&#10;        server.status = server.status.toLowerCase() as ServerStatus; // Ensure server_type is lowercase&#10;        setServer(server);&#10;    };&#10;&#10;    const unloadServer = () =&gt;&#10;    {&#10;        setServer(null);&#10;    };&#10;&#10;    const loadServers = async () =&gt;&#10;    {&#10;        let servers: Server[] = await $.get(&quot;/api/server&quot;);&#10;        servers = servers.map(s =&gt; ({...s, status: s.status.toLowerCase()} as Server));&#10;        setServers(servers);&#10;    };&#10;&#10;    const createServer = async (server: CreateServerData): Promise&lt;string&gt; =&gt;&#10;    {&#10;        // Example response: { &quot;message&quot;: &quot;Server created successfully&quot;,&quot;server_id&quot;: &quot;lW97O03zR32QygKY&quot; }&#10;        let response = await $.ajax({&#10;            url: &quot;/api/server&quot;,&#10;            type: &quot;PUT&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(server)&#10;        });&#10;        if (!response || !response.server_id)&#10;        {&#10;            throw new Error(&quot;Server creation failed&quot;);&#10;        }&#10;&#10;        // Refresh servers list&#10;        await loadServers();&#10;        return response.server_id;&#10;    };&#10;&#10;    const isServerRunning = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        if (!targetServer) return false;&#10;        return targetServer.status === &quot;running&quot; || targetServer.status === &quot;starting&quot; || targetServer.status === &quot;stopping&quot; || targetServer.status === &quot;hanging&quot;;&#10;    }, [server, servers]);&#10;&#10;    const updateServer = useCallback(async (updates: Partial&lt;Server&gt;, serverId?: string) =&gt;&#10;    {&#10;        let targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        let targetServer: Server | null | undefined = serverId != undefined ? servers.find(s =&gt; s.id === targetServerId) : server;&#10;        if (targetServer == null)&#10;        {&#10;            targetServer = await $.get(`/api/server/${targetServerId}`);&#10;            if (!targetServer) throw new Error(&quot;No server loaded&quot;);&#10;        }&#10;&#10;        console.log(&quot;Updating server&quot;, targetServerId, updates, &quot;Original server:&quot;, targetServer);&#10;        const updatedServer = {...targetServer, ...updates};&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(updatedServer)&#10;        });&#10;        await loadServers();&#10;    }, [server, servers]);&#10;&#10;    const deleteServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;DELETE&quot;&#10;        });&#10;&#10;        // If deleting the currently loaded server, clear it&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(null);&#10;        }&#10;&#10;        // Remove from servers list&#10;        setServers(prev =&gt; prev.filter(s =&gt; s.id !== targetServerId));&#10;    }, [server]);&#10;&#10;    const startServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/start`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;starting&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const stopServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/stop`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const restartServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/restart`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const killServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/kill`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const sendCommand = useCallback(async (command: string, serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}/send-command`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;text/plain&quot;,&#10;            data: command&#10;        });&#10;    }, [server]);&#10;&#10;    const cleanupConsoleConnection = useCallback((serverId?: string) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = serverId || targetServer?.id;&#10;        if (!targetServerId) return;&#10;&#10;        const existingCleanup = consoleConnections.current.get(targetServerId);&#10;        if (existingCleanup)&#10;        {&#10;            existingCleanup();&#10;            consoleConnections.current.delete(targetServerId);&#10;        }&#10;    }, [server]);&#10;&#10;    const hasActiveConsoleConnection = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) return false;&#10;&#10;        return consoleConnections.current.has(targetServerId);&#10;    }, [server]);&#10;&#10;    const subscribeToConsole = useCallback((callback: (data: string) =&gt; void, serverId?: string): (() =&gt; void) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        cleanupConsoleConnection(targetServerId);&#10;&#10;        try&#10;        {&#10;            const eventSource = new EventSource(`/api/server/${targetServerId}/console`);&#10;            const eventName = `console`;&#10;&#10;            const handleMessage = (event: MessageEvent) =&gt;&#10;            {&#10;                console.log(`Received console message for server ${targetServerId}:`, event.data);&#10;                callback(event.data);&#10;            };&#10;&#10;            const handleError = (event: Event) =&gt;&#10;            {&#10;                console.error(`EventSource error for server ${targetServerId}:`, event);&#10;            };&#10;&#10;            const handleOpen = () =&gt;&#10;            {&#10;                console.log(`Console EventSource for server ${targetServerId} opened successfully.`);&#10;            };&#10;&#10;            eventSource.addEventListener(&quot;open&quot;, handleOpen);&#10;            eventSource.addEventListener(eventName, handleMessage);&#10;            eventSource.addEventListener(&quot;message&quot;, handleMessage);&#10;            eventSource.addEventListener(&quot;error&quot;, handleError);&#10;&#10;            const cleanup = () =&gt;&#10;            {&#10;                eventSource.removeEventListener(eventName, handleMessage);&#10;                eventSource.removeEventListener(&quot;message&quot;, handleMessage);&#10;                eventSource.removeEventListener(&quot;error&quot;, handleError);&#10;                eventSource.close();&#10;                consoleConnections.current.delete(targetServerId);&#10;                console.log(`EventSource for server ${targetServerId} closed and cleaned up.`);&#10;            };&#10;&#10;            // Store cleanup function in connection map&#10;            consoleConnections.current.set(targetServerId, cleanup);&#10;&#10;&#10;            // Return cleanup function&#10;            return cleanup;&#10;        } catch (error)&#10;        {&#10;            console.error(`Failed to create EventSource for server ${targetServerId}:`, error);&#10;            throw error;&#10;        }&#10;    }, [server, cleanupConsoleConnection]);&#10;&#10;    const backupServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        // Note: There's no backup endpoint in the server_endpoint.rs file&#10;        // You may need to implement this endpoint on the backend&#10;        throw new Error(&quot;Backup endpoint not implemented&quot;);&#10;    }, [server]);&#10;&#10;    const getServerStatus = useCallback(async (serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        const serverData: Server = await $.get(`/api/server/${targetServerId}`);&#10;        return serverData.status;&#10;    }, [server]);&#10;&#10;    // Filesystem functions&#10;    const getEntries = useCallback(async (path: string, serverId?: string): Promise&lt;FilesystemData&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getEntries(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const downloadEntry = useCallback(async (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        // if the entry is FileSystemEntry or FilesystemEntry[], convert it to string[]&#10;        if (Array.isArray(entry))&#10;        {&#10;            if (entry[0] &amp;&amp; typeof entry[0] === &quot;object&quot;)&#10;            {&#10;                entry = (entry as FilesystemEntry[]).map(e =&gt; e.path);&#10;            }&#10;        } else if (typeof entry === &quot;object&quot;)&#10;        {&#10;            entry = [(entry as FilesystemEntry).path];&#10;        }&#10;&#10;        return await FileSystem.download(entry as string[], targetServerId);&#10;    }, [server]);&#10;&#10;    const copyEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.copyEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const moveEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.moveEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const renameEntry = useCallback(async (source: string, destination: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.renameEntry(source, destination, targetServerId);&#10;    }, [server]);&#10;&#10;    const deleteEntry = useCallback(async (path: string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.deleteEntry(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFile = useCallback(async (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.upload(file, path, targetServerId, updateProgress, onCancelled);&#10;    }, [server]);&#10;&#10;    const createEntry = useCallback(async (filename: string, cwd: string, isDirectory: boolean, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.createEntry(filename, cwd, isDirectory, targetServerId);&#10;    }, [server]);&#10;&#10;    const searchFiles = useCallback(async (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string): Promise&lt;FilesystemEntry[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.search(query, filename_only, targetServerId, abortSignal);&#10;    }, [server]);&#10;&#10;    const archiveFiles = useCallback((filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.archive(filename, filenames, cwd, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelArchive = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelArchive(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFromUrl = useCallback(async (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.uploadFromUrl(url, filepath, targetServerId, onProgress, onSuccess, onError);&#10;    }, [server]);&#10;&#10;    const getLogs = useCallback(async (serverId?: string): Promise&lt;string[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs`);&#10;    }, [server]);&#10;&#10;    const getLog = useCallback(async (filename: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs/${filename}`);&#10;    }, [server]);&#10;    &#10;    const getFileContents = useCallback(async (path: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getFileContents(path, targetServerId);&#10;    }, [server]);&#10;    &#10;    const setFileContents = useCallback(async (path: string, contents: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.setFileContents(path, contents, targetServerId);&#10;    }, [server]);&#10;&#10;&#10;    return (&#10;        &lt;ServerContext.Provider value={{&#10;            server,&#10;            servers,&#10;            loadServer,&#10;            unloadServer,&#10;            loadServers,&#10;            createServer,&#10;            updateServer,&#10;            deleteServer,&#10;            startServer,&#10;            stopServer,&#10;            restartServer,&#10;            killServer,&#10;            sendCommand,&#10;            subscribeToConsole,&#10;            cleanupConsoleConnection,&#10;            hasActiveConsoleConnection,&#10;            backupServer,&#10;            getServerStatus,&#10;            isServerRunning,&#10;            // Filesystem functions&#10;            getEntries,&#10;            downloadEntry,&#10;            copyEntry,&#10;            moveEntry,&#10;            renameEntry,&#10;            deleteEntry,&#10;            uploadFile,&#10;            createEntry,&#10;            searchFiles,&#10;            archiveFiles,&#10;            cancelArchive,&#10;            uploadFromUrl,&#10;            getFileContents,&#10;            setFileContents,&#10;            getLogs,&#10;            getLog&#10;        }}&gt;&#10;            {children}&#10;        &lt;/ServerContext.Provider&gt;&#10;    );&#10;}&#10;&#10;export function useServer(): ServerContextType&#10;{&#10;    const context = useContext(ServerContext);&#10;    if (!context)&#10;    {&#10;        throw new Error(&quot;useServer must be used within a ServerProvider&quot;);&#10;    }&#10;    return context;&#10;}" />
              <option name="updatedContent" value="import {createContext, ReactNode, useCallback, useContext, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {FileSystem, FilesystemData, FilesystemEntry} from &quot;../ts/filesystem.ts&quot;;&#10;&#10;export type Server =&#10;    {&#10;        /** Unique identifier for the server */&#10;        id: string;&#10;        /** Directory name where server files are stored, e.g. 'my_minecraft_server' */&#10;        directory: string;&#10;        /** Additional JVM arguments excluding -Xmx and -Xms */&#10;        java_args: string;&#10;        /** Maximum memory in GB for JVM -Xmx argument */&#10;        max_memory: number;&#10;        /** Minimum memory in GB for JVM -Xms argument */&#10;        min_memory: number;&#10;        /** Additional Minecraft server arguments */&#10;        minecraft_args: string;&#10;        /** Name/path of the server JAR file */&#10;        server_jar: string;&#10;        /** Whether UPnP port forwarding is enabled */&#10;        upnp: boolean;&#10;        /** Server status: 'stopped', 'starting', 'running', 'stopping', 'error' */&#10;        status: ServerStatus;&#10;        /** Whether the server should start automatically on boot */&#10;        auto_start: boolean;&#10;        /** Whether the server should restart automatically if it crashes */&#10;        auto_restart: boolean;&#10;        /** Whether automatic backups are enabled */&#10;        backup_enabled: boolean;&#10;        /** Backup interval in minutes */&#10;        backup_interval: number;&#10;        /** Optional server description */&#10;        description: string | null;&#10;        /** ID of the user who owns this server */&#10;        owner_id: number;&#10;        /** Timestamp of when the server was created (seconds since epoch) */&#10;        created_at: number;&#10;        /** Timestamp of when the server was last updated (seconds since epoch) */&#10;        updated_at: number;&#10;        /** Timestamp of when the server was last started (seconds since epoch) */&#10;        last_started: number | null;&#10;    } &amp; CreateServerData&#10;&#10;export type CreateServerData = {&#10;    /** Name of the server, e.g. 'My Minecraft Server' */&#10;    name: string;&#10;    /** Server type: 'vanilla', 'fabric', 'forge', 'neoforge', 'quilt' , or 'custom' */&#10;    server_type: LoaderType;&#10;    /** Minecraft version, e.g. '1.20.1', '1.19.4', or 'custom' */&#10;    minecraft_version: string;&#10;    /** Loader version e.g. '0.14.0', '1.20.1-44.1.23', or 'custom' */&#10;    loader_version: string;&#10;    /** Path to Java executable, e.g. '/usr/bin/java' or 'java' for system PATH */&#10;    java_executable: string;&#10;}&#10;&#10;export type LoaderType = &quot;vanilla&quot; | &quot;fabric&quot; | &quot;forge&quot; | &quot;neoforge&quot; | &quot;quilt&quot; | &quot;custom&quot;;&#10;export type ServerStatus = &quot;idle&quot; | &quot;running&quot; | &quot;stopped&quot; | &quot;error&quot; | &quot;starting&quot; | &quot;stopping&quot; | &quot;crashed&quot; | &quot;hanging&quot;;&#10;&#10;interface ServerContextType&#10;{&#10;    server: Server | null;&#10;    servers: Server[];&#10;    loadServer: (id: string) =&gt; Promise&lt;void&gt;;&#10;    unloadServer: () =&gt; void;&#10;    loadServers: () =&gt; Promise&lt;void&gt;;&#10;    createServer: (server: CreateServerData) =&gt; Promise&lt;string&gt;;&#10;    updateServer: (server: Partial&lt;Server&gt;, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    startServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    stopServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    restartServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    killServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    sendCommand: (command: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    subscribeToConsole: (callback: (data: string) =&gt; void, serverId?: string) =&gt; () =&gt; void;&#10;    cleanupConsoleConnection: (serverId?: string) =&gt; void;&#10;    hasActiveConsoleConnection: (serverId?: string) =&gt; boolean;&#10;    backupServer: (serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getServerStatus: (serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    isServerRunning: (serverId?: string) =&gt; boolean;&#10;    // Filesystem functions&#10;    getEntries: (path: string, serverId?: string) =&gt; Promise&lt;FilesystemData&gt;;&#10;    downloadEntry: (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    copyEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    moveEntry: (sourcePaths: string[], destinationPath: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    renameEntry: (source: string, destination: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    deleteEntry: (path: string | string[], serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFile: (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string) =&gt; Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;;&#10;    createEntry: (filename: string, cwd: string, isDirectory: boolean, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    searchFiles: (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string) =&gt; Promise&lt;FilesystemEntry[]&gt;;&#10;    archiveFiles: (filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelArchive: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    extractArchive: (archivePath: string, outputPath: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string) =&gt; { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string };&#10;    cancelExtract: (trackerId: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    uploadFromUrl: (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    getFileContents: (path: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;    setFileContents: (path: string, contents: string, serverId?: string) =&gt; Promise&lt;void&gt;;&#10;    // Logging and console functions&#10;    getLogs: (serverId?: string) =&gt; Promise&lt;string[]&gt;;&#10;    getLog: (filename: string, serverId?: string) =&gt; Promise&lt;string&gt;;&#10;}&#10;&#10;const ServerContext = createContext&lt;ServerContextType | undefined&gt;(undefined);&#10;&#10;export function ServerProvider({children}: { children: ReactNode })&#10;{&#10;    const [server, setServer] = useState&lt;Server | null&gt;(null);&#10;    const [servers, setServers] = useState&lt;Server[]&gt;([]);&#10;&#10;    // Connection tracking for console subscriptions&#10;    const consoleConnections = useRef&lt;Map&lt;string, () =&gt; void&gt;&gt;(new Map());&#10;&#10;    const loadServer = async (id: string) =&gt;&#10;    {&#10;        let server: Server = await $.get(`/api/server/${id}`);&#10;        server.status = server.status.toLowerCase() as ServerStatus; // Ensure server_type is lowercase&#10;        setServer(server);&#10;    };&#10;&#10;    const unloadServer = () =&gt;&#10;    {&#10;        setServer(null);&#10;    };&#10;&#10;    const loadServers = async () =&gt;&#10;    {&#10;        let servers: Server[] = await $.get(&quot;/api/server&quot;);&#10;        servers = servers.map(s =&gt; ({...s, status: s.status.toLowerCase()} as Server));&#10;        setServers(servers);&#10;    };&#10;&#10;    const createServer = async (server: CreateServerData): Promise&lt;string&gt; =&gt;&#10;    {&#10;        // Example response: { &quot;message&quot;: &quot;Server created successfully&quot;,&quot;server_id&quot;: &quot;lW97O03zR32QygKY&quot; }&#10;        let response = await $.ajax({&#10;            url: &quot;/api/server&quot;,&#10;            type: &quot;PUT&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(server)&#10;        });&#10;        if (!response || !response.server_id)&#10;        {&#10;            throw new Error(&quot;Server creation failed&quot;);&#10;        }&#10;&#10;        // Refresh servers list&#10;        await loadServers();&#10;        return response.server_id;&#10;    };&#10;&#10;    const isServerRunning = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        if (!targetServer) return false;&#10;        return targetServer.status === &quot;running&quot; || targetServer.status === &quot;starting&quot; || targetServer.status === &quot;stopping&quot; || targetServer.status === &quot;hanging&quot;;&#10;    }, [server, servers]);&#10;&#10;    const updateServer = useCallback(async (updates: Partial&lt;Server&gt;, serverId?: string) =&gt;&#10;    {&#10;        let targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        let targetServer: Server | null | undefined = serverId != undefined ? servers.find(s =&gt; s.id === targetServerId) : server;&#10;        if (targetServer == null)&#10;        {&#10;            targetServer = await $.get(`/api/server/${targetServerId}`);&#10;            if (!targetServer) throw new Error(&quot;No server loaded&quot;);&#10;        }&#10;&#10;        console.log(&quot;Updating server&quot;, targetServerId, updates, &quot;Original server:&quot;, targetServer);&#10;        const updatedServer = {...targetServer, ...updates};&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;application/json&quot;,&#10;            data: JSON.stringify(updatedServer)&#10;        });&#10;        await loadServers();&#10;    }, [server, servers]);&#10;&#10;    const deleteServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}`,&#10;            type: &quot;DELETE&quot;&#10;        });&#10;&#10;        // If deleting the currently loaded server, clear it&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(null);&#10;        }&#10;&#10;        // Remove from servers list&#10;        setServers(prev =&gt; prev.filter(s =&gt; s.id !== targetServerId));&#10;    }, [server]);&#10;&#10;    const startServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/start`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;starting&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const stopServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/stop`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;    }, [server]);&#10;&#10;    const restartServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/restart`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const killServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.post(`/api/server/${targetServerId}/kill`);&#10;&#10;        // Update status for currently loaded server if it matches&#10;        if (server &amp;&amp; server.id === targetServerId)&#10;        {&#10;            setServer(prev =&gt; prev ? {...prev, status: &quot;stopping&quot;} : null);&#10;        }&#10;&#10;    }, [server]);&#10;&#10;    const sendCommand = useCallback(async (command: string, serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        await $.ajax({&#10;            url: `/api/server/${targetServerId}/send-command`,&#10;            type: &quot;POST&quot;,&#10;            contentType: &quot;text/plain&quot;,&#10;            data: command&#10;        });&#10;    }, [server]);&#10;&#10;    const cleanupConsoleConnection = useCallback((serverId?: string) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = serverId || targetServer?.id;&#10;        if (!targetServerId) return;&#10;&#10;        const existingCleanup = consoleConnections.current.get(targetServerId);&#10;        if (existingCleanup)&#10;        {&#10;            existingCleanup();&#10;            consoleConnections.current.delete(targetServerId);&#10;        }&#10;    }, [server]);&#10;&#10;    const hasActiveConsoleConnection = useCallback((serverId?: string): boolean =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) return false;&#10;&#10;        return consoleConnections.current.has(targetServerId);&#10;    }, [server]);&#10;&#10;    const subscribeToConsole = useCallback((callback: (data: string) =&gt; void, serverId?: string): (() =&gt; void) =&gt;&#10;    {&#10;        let targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        cleanupConsoleConnection(targetServerId);&#10;&#10;        try&#10;        {&#10;            const eventSource = new EventSource(`/api/server/${targetServerId}/console`);&#10;            const eventName = `console`;&#10;&#10;            const handleMessage = (event: MessageEvent) =&gt;&#10;            {&#10;                console.log(`Received console message for server ${targetServerId}:`, event.data);&#10;                callback(event.data);&#10;            };&#10;&#10;            const handleError = (event: Event) =&gt;&#10;            {&#10;                console.error(`EventSource error for server ${targetServerId}:`, event);&#10;            };&#10;&#10;            const handleOpen = () =&gt;&#10;            {&#10;                console.log(`Console EventSource for server ${targetServerId} opened successfully.`);&#10;            };&#10;&#10;            eventSource.addEventListener(&quot;open&quot;, handleOpen);&#10;            eventSource.addEventListener(eventName, handleMessage);&#10;            eventSource.addEventListener(&quot;message&quot;, handleMessage);&#10;            eventSource.addEventListener(&quot;error&quot;, handleError);&#10;&#10;            const cleanup = () =&gt;&#10;            {&#10;                eventSource.removeEventListener(eventName, handleMessage);&#10;                eventSource.removeEventListener(&quot;message&quot;, handleMessage);&#10;                eventSource.removeEventListener(&quot;error&quot;, handleError);&#10;                eventSource.close();&#10;                consoleConnections.current.delete(targetServerId);&#10;                console.log(`EventSource for server ${targetServerId} closed and cleaned up.`);&#10;            };&#10;&#10;            // Store cleanup function in connection map&#10;            consoleConnections.current.set(targetServerId, cleanup);&#10;&#10;&#10;            // Return cleanup function&#10;            return cleanup;&#10;        } catch (error)&#10;        {&#10;            console.error(`Failed to create EventSource for server ${targetServerId}:`, error);&#10;            throw error;&#10;        }&#10;    }, [server, cleanupConsoleConnection]);&#10;&#10;    const backupServer = useCallback(async (serverId?: string) =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        // Note: There's no backup endpoint in the server_endpoint.rs file&#10;        // You may need to implement this endpoint on the backend&#10;        throw new Error(&quot;Backup endpoint not implemented&quot;);&#10;    }, [server]);&#10;&#10;    const getServerStatus = useCallback(async (serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        const serverData: Server = await $.get(`/api/server/${targetServerId}`);&#10;        return serverData.status;&#10;    }, [server]);&#10;&#10;    // Filesystem functions&#10;    const getEntries = useCallback(async (path: string, serverId?: string): Promise&lt;FilesystemData&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getEntries(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const downloadEntry = useCallback(async (entry: FilesystemEntry | FilesystemEntry[] | string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServer = serverId ? servers.find(s =&gt; s.id === serverId) : server;&#10;        const targetServerId = targetServer?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;        // if the entry is FileSystemEntry or FilesystemEntry[], convert it to string[]&#10;        if (Array.isArray(entry))&#10;        {&#10;            if (entry[0] &amp;&amp; typeof entry[0] === &quot;object&quot;)&#10;            {&#10;                entry = (entry as FilesystemEntry[]).map(e =&gt; e.path);&#10;            }&#10;        } else if (typeof entry === &quot;object&quot;)&#10;        {&#10;            entry = [(entry as FilesystemEntry).path];&#10;        }&#10;&#10;        return await FileSystem.download(entry as string[], targetServerId);&#10;    }, [server]);&#10;&#10;    const copyEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.copyEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const moveEntry = useCallback(async (sourcePaths: string[], destinationPath: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.moveEntry(sourcePaths, destinationPath, targetServerId);&#10;    }, [server]);&#10;&#10;    const renameEntry = useCallback(async (source: string, destination: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.renameEntry(source, destination, targetServerId);&#10;    }, [server]);&#10;&#10;    const deleteEntry = useCallback(async (path: string | string[], serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.deleteEntry(path, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFile = useCallback(async (file: File, path: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void, serverId?: string): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.upload(file, path, targetServerId, updateProgress, onCancelled);&#10;    }, [server]);&#10;&#10;    const createEntry = useCallback(async (filename: string, cwd: string, isDirectory: boolean, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.createEntry(filename, cwd, isDirectory, targetServerId);&#10;    }, [server]);&#10;&#10;    const searchFiles = useCallback(async (query: string, filename_only: boolean, abortSignal: AbortSignal, serverId?: string): Promise&lt;FilesystemEntry[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.search(query, filename_only, targetServerId, abortSignal);&#10;    }, [server]);&#10;&#10;    const archiveFiles = useCallback((filename: string, filenames: string[], cwd: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.archive(filename, filenames, cwd, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelArchive = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelArchive(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const extractArchive = useCallback((archivePath: string, outputPath: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void, serverId?: string): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string } =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return FileSystem.extract(archivePath, outputPath, targetServerId, on_progress, on_success, on_error, on_cancelled);&#10;    }, [server]);&#10;&#10;    const cancelExtract = useCallback(async (trackerId: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.cancelExtract(trackerId, targetServerId);&#10;    }, [server]);&#10;&#10;    const uploadFromUrl = useCallback(async (url: string, filepath: string, onProgress: (progress: number, downloaded: number, total: number) =&gt; void, onSuccess: () =&gt; void, onError: (error: string) =&gt; void, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.uploadFromUrl(url, filepath, targetServerId, onProgress, onSuccess, onError);&#10;    }, [server]);&#10;&#10;    const getLogs = useCallback(async (serverId?: string): Promise&lt;string[]&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs`);&#10;    }, [server]);&#10;&#10;    const getLog = useCallback(async (filename: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return $.get(`/api/server/${targetServerId}/logs/${filename}`);&#10;    }, [server]);&#10;    &#10;    const getFileContents = useCallback(async (path: string, serverId?: string): Promise&lt;string&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.getFileContents(path, targetServerId);&#10;    }, [server]);&#10;    &#10;    const setFileContents = useCallback(async (path: string, contents: string, serverId?: string): Promise&lt;void&gt; =&gt;&#10;    {&#10;        const targetServerId = serverId || server?.id;&#10;        if (!targetServerId) throw new Error(&quot;No server ID provided and no server loaded&quot;);&#10;&#10;        return await FileSystem.setFileContents(path, contents, targetServerId);&#10;    }, [server]);&#10;&#10;&#10;    return (&#10;        &lt;ServerContext.Provider value={{&#10;            server,&#10;            servers,&#10;            loadServer,&#10;            unloadServer,&#10;            loadServers,&#10;            createServer,&#10;            updateServer,&#10;            deleteServer,&#10;            startServer,&#10;            stopServer,&#10;            restartServer,&#10;            killServer,&#10;            sendCommand,&#10;            subscribeToConsole,&#10;            cleanupConsoleConnection,&#10;            hasActiveConsoleConnection,&#10;            backupServer,&#10;            getServerStatus,&#10;            isServerRunning,&#10;            // Filesystem functions&#10;            getEntries,&#10;            downloadEntry,&#10;            copyEntry,&#10;            moveEntry,&#10;            renameEntry,&#10;            deleteEntry,&#10;            uploadFile,&#10;            createEntry,&#10;            searchFiles,&#10;            archiveFiles,&#10;            cancelArchive,&#10;            extractArchive,&#10;            cancelExtract,&#10;            uploadFromUrl,&#10;            getFileContents,&#10;            setFileContents,&#10;            getLogs,&#10;            getLog&#10;        }}&gt;&#10;            {children}&#10;        &lt;/ServerContext.Provider&gt;&#10;    );&#10;}&#10;&#10;export function useServer(): ServerContextType&#10;{&#10;    const context = useContext(ServerContext);&#10;    if (!context)&#10;    {&#10;        throw new Error(&quot;useServer must be used within a ServerProvider&quot;);&#10;    }&#10;    return context;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/ts/filesystem.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/ts/filesystem.ts" />
              <option name="originalContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    resolve(); // Resolve immediately when connection opens&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    onSuccess();&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    static extract(archivePath: string, outputPath: string, serverId: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `extract-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/extract/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        &#10;        // Trim leading slashes from paths&#10;        archivePath = archivePath.startsWith(&quot;/&quot;) ? archivePath.substring(1) : archivePath;&#10;        outputPath = outputPath.startsWith(&quot;/&quot;) ? outputPath.substring(1) : outputPath;&#10;        &#10;        // Function to cancel the extract operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel extract:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling extract:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0, 0, 0);&#10;            try&#10;            {&#10;                const url = new URL(`/api/server/${serverId}/fs/extract`, window.location.origin);&#10;                url.searchParams.set(&quot;archive&quot;, archivePath);&#10;                url.searchParams.set(&quot;directory&quot;, outputPath);&#10;                url.searchParams.set(&quot;tracker&quot;, id);&#10;                &#10;                const response = await fetch(url.toString(), {&#10;                    method: &quot;POST&quot;&#10;                });&#10;                &#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to extract the archive.&quot;}`);&#10;            }&#10;        });&#10;        &#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;            &#10;            // Check if the operation completed successfully&#10;            if (data.status === &quot;complete&quot;)&#10;            {&#10;                on_success();&#10;                return;&#10;            }&#10;            &#10;            // Check if there was an error&#10;            if (data.status === &quot;error&quot;)&#10;            {&#10;                on_error(data.error || &quot;Unknown error occurred during extraction&quot;);&#10;                return;&#10;            }&#10;&#10;            // Update progress&#10;            on_progress(data.progress || 0, data.filesProcessed || 0, data.totalFiles || 0);&#10;        };&#10;        &#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelExtract(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel extract operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    resolve(); // Resolve immediately when connection opens&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    onSuccess();&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>