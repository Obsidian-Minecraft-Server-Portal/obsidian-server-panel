<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Archive.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Archive&#10;  type: http&#10;  seq: 15&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/archive/cancel/:tracker-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  tracker-id: archive123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Cancel Upload.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Cancel Upload&#10;  type: http&#10;  seq: 6&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/cancel/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Copy Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Copy Files&#10;  type: http&#10;  seq: 7&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/copy&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Create New Entry.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Create New Entry&#10;  type: http&#10;  seq: 11&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/new&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;path&quot;: &quot;new-folder&quot;,&#10;    &quot;is_directory&quot;: true&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Delete Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Delete Files&#10;  type: http&#10;  seq: 10&#10;}&#10;&#10;delete {&#10;  url: {{baseurl}}/server/:server-id/fs/&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;paths&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;, &quot;file2.txt&quot;]&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Download Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id:&#10;}" />
              <option name="updatedContent" value="meta {&#10;  name: Download Files&#10;  type: http&#10;  seq: 4&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/download?items=logs&amp;items=config&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  items: logs&#10;  items: config&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Get Files.bru" />
              <option name="originalContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?filepath&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath:&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Get Files&#10;  type: http&#10;  seq: 1&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/files?path=&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  path: &#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Move Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Move Files&#10;  type: http&#10;  seq: 8&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/move&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;entries&quot;: [&quot;file1.txt&quot;, &quot;folder1&quot;],&#10;    &quot;path&quot;: &quot;destination/folder&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Rename File.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Rename File&#10;  type: http&#10;  seq: 9&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/rename&#10;  body: json&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:json {&#10;  {&#10;    &quot;source&quot;: &quot;oldfile.txt&quot;,&#10;    &quot;destination&quot;: &quot;newfile.txt&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Search Files.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Search Files&#10;  type: http&#10;  seq: 12&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/search?q=config&amp;filename_only=false&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  q: config&#10;  filename_only: false&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload File.bru" />
              <option name="originalContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?filepath=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  filepath: example.txt&#10;  server-id:&#10;  server-id:&#10;  server-id:&#10;  server-id:&#10;  server-id:&#10;  server-id:&#10;" />
              <option name="updatedContent" value="meta {&#10;  name: Upload File&#10;  type: http&#10;  seq: 2&#10;}&#10;&#10;post {&#10;  url: {{baseurl}}/server/:server-id/fs/upload?upload_id=upload123&amp;path=example.txt&#10;  body: text&#10;  auth: inherit&#10;}&#10;&#10;params:query {&#10;  upload_id: upload123&#10;  path: example.txt&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;}&#10;&#10;body:text {&#10;  This is the content of the uploaded file.&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.bruno/Filesystem Operations/Upload Progress.bru" />
              <option name="updatedContent" value="meta {&#10;  name: Upload Progress&#10;  type: http&#10;  seq: 5&#10;}&#10;&#10;get {&#10;  url: {{baseurl}}/server/:server-id/fs/upload/progress/:upload-id&#10;  body: none&#10;  auth: inherit&#10;}&#10;&#10;params:path {&#10;  server-id: lW97O03zR32QygKY&#10;  upload-id: upload123&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Cargo.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Cargo.toml" />
              <option name="originalContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;" />
              <option name="updatedContent" value="[package]&#10;name = &quot;obsidian_server_panel&quot;&#10;version = &quot;0.0.0&quot;&#10;edition = &quot;2024&quot;&#10;authors = [&quot;Drew Chase (Work) &lt;dcmanproductions@gmail.com&gt;&quot;]&#10;build = &quot;src-actix/build.rs&quot;&#10;&#10;[[bin]]&#10;name = &quot;obsidian_server_panel&quot;&#10;path = &quot;src-actix/main.rs&quot;&#10;&#10;[lib]&#10;name = &quot;obsidian_server_panel_lib&quot;&#10;path = &quot;src-actix/lib.rs&quot;&#10;crate-type = [&quot;lib&quot;]&#10;&#10;[dependencies]&#10;actix-web = { version = &quot;4.9.0&quot; }&#10;actix-files = { version = &quot;0.6.6&quot; }&#10;actix-web-lab = { version = &quot;0.24.2&quot; }&#10;serde = { version = &quot;1.0.208&quot;, features = [&quot;derive&quot;] }&#10;serde_json = { version = &quot;1.0.125&quot; }&#10;pretty_env_logger = &quot;0.5.0&quot;&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;&#10;log = &quot;0.4.22&quot;&#10;anyhow = &quot;1.0.95&quot;&#10;thiserror = &quot;2.0.11&quot;&#10;vite-actix = &quot;0.2.5&quot;&#10;chrono = { version = &quot;0.4.41&quot;, features = [&quot;serde&quot;] }&#10;sqlx = { version = &quot;0.8.6&quot;, features = [&quot;sqlite&quot;, &quot;chrono&quot;, &quot;json&quot;, &quot;runtime-tokio&quot;, &quot;derive&quot;, &quot;time&quot;] }&#10;serde_hash = { version = &quot;0.1.3&quot; }&#10;bcrypt = { version = &quot;0.17.0&quot; }&#10;enumflags2 = { version = &quot;0.7.12&quot;, features = [&quot;serde&quot;] }&#10;futures = &quot;0.3.31&quot;&#10;reqwest = { version = &quot;0.12.22&quot;, features = [&quot;json&quot;, &quot;stream&quot;] }&#10;sysinfo = { version = &quot;0.36.1&quot;, features = [&quot;multithread&quot;, &quot;disk&quot;, &quot;windows&quot;, &quot;system&quot;, &quot;user&quot;, &quot;network&quot;] }&#10;tokio = { version = &quot;1.46.1&quot;, features = [&quot;time&quot;, &quot;fs&quot;, &quot;rt-multi-thread&quot;, &quot;sync&quot;, &quot;rt&quot;, &quot;macros&quot;] }&#10;tokio-util = &quot;0.7.15&quot;&#10;regex = { version = &quot;1.11.1&quot;, features = [&quot;perf&quot;] }&#10;uuid = { version = &quot;1.17.0&quot;, features = [&quot;v4&quot;] }&#10;zip = &quot;3.0.0&quot;&#10;archflow = { version = &quot;0.1.4&quot;, features = [&quot;tokio&quot;] }&#10;tokio-interactive = { version = &quot;0.2.0&quot; }&#10;flate2 = { version = &quot;1.1.2&quot; }&#10;tar = &quot;0.4.44&quot;&#10;obsidian-upnp = { git = &quot;https://github.com/Obsidian-Minecraft-Server-Portal/upnp.git&quot; }&#10;&#10;[build-dependencies]&#10;include_dir = &quot;0.7.4&quot;&#10;walkdir = &quot;2.5.0&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src-actix/server/filesystem/mod.rs" />
              <option name="originalContent" value="mod filesystem_data;&#10;mod filesystem_endpoint;&#10;mod download_parameters;&#10;mod archive_wrapper;&#10;" />
              <option name="updatedContent" value="mod filesystem_data;&#13;&#10;mod filesystem_endpoint;&#13;&#10;mod download_parameters;&#13;&#10;mod archive_wrapper;&#13;&#10;mod extract_wrapper;&#13;&#10;mod normalize_path;&#13;&#10;&#13;&#10;pub use filesystem_endpoint::configure;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/MessageModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/MessageModal.tsx" />
              <option name="originalContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;" />
              <option name="updatedContent" value="import {Button, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {ReactNode, useEffect} from &quot;react&quot;;&#10;&#10;export type MessageOptions = {&#10;    title: string;&#10;    body: ReactNode | string;&#10;    responseType: MessageResponseType;&#10;    severity?: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot;;&#10;    icon?: ReactNode | string;&#10;}&#10;&#10;type MessageProperties = {&#10;    isOpen: boolean;&#10;    onClose: (response: boolean | null) =&gt; void;&#10;} &amp; MessageOptions;&#10;&#10;export enum MessageResponseType&#10;{&#10;    YesNo,&#10;    OkayCancel,&#10;    Close,&#10;}&#10;&#10;export default function MessageModal(props: MessageProperties)&#10;{&#10;    const {&#10;        title,&#10;        body,&#10;        responseType,&#10;        icon,&#10;        severity,&#10;        isOpen,&#10;        onClose&#10;    } = props;&#10;&#10;    // Handle keyboard events for Enter and Space&#10;    useEffect(() =&gt; {&#10;        if (!isOpen) return;&#10;&#10;        const handleKeyDown = (event: KeyboardEvent) =&gt; {&#10;            if (event.key === 'Enter' || event.key === ' ') {&#10;                event.preventDefault();&#10;                event.stopPropagation();&#10;                // Trigger the primary action (Yes/Okay/Close)&#10;                onClose(true);&#10;            }&#10;        };&#10;&#10;        // Add event listener when modal is open&#10;        document.addEventListener('keydown', handleKeyDown);&#10;&#10;        // Cleanup event listener when modal closes or component unmounts&#10;        return () =&gt; {&#10;            document.removeEventListener('keydown', handleKeyDown);&#10;        };&#10;    }, [isOpen, onClose]);&#10;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={isOpen}&#10;            onClose={() =&gt; onClose(responseType === MessageResponseType.Close ? null : false)}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{&#10;                closeButton: &quot;rounded-none&quot;,&#10;                backdrop: severity === &quot;danger&quot; ? &quot;bg-danger/10&quot; : &quot;&quot;&#10;            }}&#10;            data-severity={severity}&#10;            isDismissable={false}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {() =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;flex flex-row items-center gap-2 text-2xl&quot;}&gt;&#10;                            &lt;span className={&quot;text-3xl h-[30px]&quot;}&gt;{typeof icon === &quot;string&quot; ? &lt;Icon icon={icon}/&gt; : icon == null ? &lt;MessageIcon severity={severity}/&gt; : icon}&lt;/span&gt;&#10;                            &lt;span&#10;                                className={&quot;data-[severity=danger]:text-danger data-[severity=warning]:text-warning data-[severity=info]:text-blue-500 data-[severity=success]:text-success&quot;}&#10;                                data-severity={severity}&#10;                            &gt;&#10;                                {title}&#10;                            &lt;/span&gt;&#10;                        &lt;/ModalHeader&gt;&#10;                        &lt;ModalBody&gt;&#10;                            {body}&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            {({&#10;                                [MessageResponseType.YesNo]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Yes&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;No&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.OkayCancel]: (&#10;                                    &lt;&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} color={severity === &quot;danger&quot; ? &quot;danger&quot; : &quot;primary&quot;} autoFocus&gt;Okay&lt;/Button&gt;&#10;                                        &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(false)} variant={&quot;ghost&quot;}&gt;Cancel&lt;/Button&gt;&#10;                                    &lt;/&gt;&#10;                                ),&#10;                                [MessageResponseType.Close]: (&#10;                                    &lt;Button radius={&quot;none&quot;} onPress={() =&gt; onClose(true)} autoFocus&gt;Close&lt;/Button&gt;&#10;                                )&#10;                            })[responseType]}&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;const MessageIcon = ({severity}: { severity: &quot;info&quot; | &quot;warning&quot; | &quot;danger&quot; | &quot;success&quot; | undefined }) =&gt;&#10;{&#10;    switch (severity)&#10;    {&#10;        case &quot;info&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:info-box&quot;} className={&quot;text-blue-500&quot;}/&gt;;&#10;        case &quot;warning&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:warning-box&quot;} className={&quot;text-warning&quot;}/&gt;;&#10;        case &quot;danger&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:alert&quot;} className={&quot;text-danger&quot;}/&gt;;&#10;        case &quot;success&quot;:&#10;            return &lt;Icon icon={&quot;pixelarticons:radio-on&quot;} className={&quot;text-success&quot;}/&gt;;&#10;        default:&#10;            return null;&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/JavaExecutableSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/JavaExecutableSelector.tsx" />
              <option name="originalContent" value="import {useJavaVersion} from &quot;../../providers/JavaVersionProvider.tsx&quot;;&#10;import {Button, Progress, Select, SelectItem, SelectSection} from &quot;@heroui/react&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {JavaVersion} from &quot;../../ts/java-versions.ts&quot;;&#10;import {Tooltip} from &quot;../extended/Tooltip.tsx&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {useMessage} from &quot;../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../MessageModal.tsx&quot;;&#10;&#10;type JavaExecutableSelectorProps = {&#10;    value?: string;&#10;    onVersionChange: (version: string | undefined) =&gt; void;&#10;    isDisabled: boolean&#10;}&#10;&#10;export default function JavaExecutableSelector(props: JavaExecutableSelectorProps)&#10;{&#10;    const {onVersionChange, value} = props;&#10;    const {open} = useMessage();&#10;    const {javaVersions, installVersion, refreshJavaVersions, uninstallVersion} = useJavaVersion();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;JavaVersion | undefined&gt;(undefined);&#10;    const [installationProgress, setInstallationProgress] = useState(0);&#10;    const [isInstalling, setIsInstalling] = useState(false);&#10;&#10;    // Initialize selectedVersion based on the value prop&#10;    useEffect(() =&gt; {&#10;        if (value &amp;&amp; javaVersions.length &gt; 0) {&#10;            const versionByExecutable = javaVersions.find(v =&gt; v.executable === value);&#10;            if (versionByExecutable &amp;&amp; versionByExecutable !== selectedVersion) {&#10;                setSelectedVersion(versionByExecutable);&#10;            }&#10;        } else if (!value &amp;&amp; selectedVersion) {&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [value, javaVersions, selectedVersion]);&#10;&#10;    // Update the parent component whenever selectedVersion or javaVersions change&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedVersion &amp;&amp; selectedVersion.installed &amp;&amp; selectedVersion.executable)&#10;        {&#10;            onVersionChange(selectedVersion.executable);&#10;        } else&#10;        {&#10;            onVersionChange(undefined);&#10;        }&#10;    }, [selectedVersion, onVersionChange]);&#10;&#10;    // Update selectedVersion when javaVersions change (after install/uninstall)&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedVersion)&#10;        {&#10;            const updatedVersion = javaVersions.find(v =&gt; v.runtime === selectedVersion.runtime);&#10;            if (updatedVersion &amp;&amp; (updatedVersion.installed !== selectedVersion.installed || updatedVersion.executable !== selectedVersion.executable))&#10;            {&#10;                setSelectedVersion(updatedVersion);&#10;            }&#10;        }&#10;    }, [javaVersions, selectedVersion]);&#10;&#10;    const handleInstall = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedVersion || selectedVersion.installed) return;&#10;&#10;        setInstallationProgress(0);&#10;        setIsInstalling(true);&#10;&#10;        try&#10;        {&#10;            await installVersion(selectedVersion.runtime, (progress) =&gt; setInstallationProgress(progress.progress));&#10;            await refreshJavaVersions();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to install Java version:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsInstalling(false);&#10;            setInstallationProgress(0);&#10;        }&#10;    }, [selectedVersion, installVersion, refreshJavaVersions]);&#10;&#10;    const handleUninstall = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedVersion || !selectedVersion.installed) return;&#10;&#10;        try&#10;        {&#10;            await uninstallVersion(selectedVersion.runtime);&#10;            await refreshJavaVersions();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to uninstall Java version:&quot;, error);&#10;        }&#10;    }, [selectedVersion, uninstallVersion, refreshJavaVersions]);&#10;&#10;    return (&#10;        &lt;div className={&quot;flex flex-col gap-1&quot;}&gt;&#10;            &lt;div className={&quot;flex flex-row gap-2&quot;}&gt;&#10;                &lt;Select&#10;                    label={&quot;Java&quot;}&#10;                    placeholder={&quot;Select Java Version&quot;}&#10;                    radius={&quot;none&quot;}&#10;                    size={&quot;sm&quot;}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    classNames={{listbox: &quot;font-minecraft-body&quot;}}&#10;                    disallowEmptySelection&#10;                    selectedKeys={selectedVersion ? [selectedVersion.runtime] : []}&#10;                    isDisabled={props.isDisabled}&#10;                    onSelectionChange={keys =&gt;&#10;                    {&#10;                        const key = [...keys][0];&#10;                        const selected = javaVersions.find(v =&gt; v.runtime == key);&#10;                        if (selected)&#10;                        {&#10;                            setSelectedVersion(selected);&#10;                        }&#10;                    }}&#10;                &gt;&#10;                    &lt;SelectSection title={&quot;Installed&quot;}&gt;&#10;                        {javaVersions.filter(v =&gt; v.installed &amp;&amp; v.executable != undefined).map((v) =&gt; (&#10;                            &lt;SelectItem&#10;                                key={v.runtime}&#10;                                textValue={`${v.version} (Installed)`}&#10;                            &gt;&#10;                                {v.version} ({v.executable})&#10;                            &lt;/SelectItem&gt;&#10;                        ))}&#10;                    &lt;/SelectSection&gt;&#10;                    &lt;SelectSection title={&quot;Available&quot;}&gt;&#10;                        {javaVersions.filter(v =&gt; !v.installed).map((v) =&gt; (&#10;                            &lt;SelectItem&#10;                                key={v.runtime}&#10;                                textValue={v.version}&#10;                            &gt;&#10;                                {v.version} &lt;span className={&quot;italic opacity-50&quot;}&gt;({v.runtime})&lt;/span&gt;&#10;                            &lt;/SelectItem&gt;&#10;                        ))}&#10;                    &lt;/SelectSection&gt;&#10;                &lt;/Select&gt;&#10;&#10;                {selectedVersion != undefined &amp;&amp; !selectedVersion.installed ?&#10;                    &lt;Tooltip content={&quot;Install this Java version&quot;}&gt;&#10;                        &lt;Button&#10;                            isIconOnly&#10;                            radius={&quot;none&quot;}&#10;                            size={&quot;lg&quot;}&#10;                            variant={&quot;ghost&quot;}&#10;                            color={&quot;primary&quot;}&#10;                            disabled={isInstalling}&#10;                            onPress={async () =&gt;&#10;                            {&#10;                                const response = await open({&#10;                                    title: &quot;Install Java&quot;,&#10;                                    body: `Are you sure you want to install Java ${selectedVersion.version}?`,&#10;                                    responseType: MessageResponseType.YesNo,&#10;                                    severity: &quot;info&quot;&#10;                                });&#10;                                if (response) await handleInstall();&#10;                            }}&#10;                        &gt;&#10;                            &lt;Icon icon={&quot;pixelarticons:download&quot;}/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                    : selectedVersion != undefined &amp;&amp; selectedVersion.installed ?&#10;                        &lt;Tooltip content={&quot;Uninstall this Java version&quot;}&gt;&#10;                            &lt;Button&#10;                                isIconOnly&#10;                                radius={&quot;none&quot;}&#10;                                size={&quot;lg&quot;}&#10;                                color={&quot;danger&quot;}&#10;                                variant={&quot;ghost&quot;}&#10;                                onPress={async () =&gt;&#10;                                {&#10;                                    const response = await open({&#10;                                        title: &quot;Uninstall Java&quot;,&#10;                                        body: `Are you sure you want to uninstall Java ${selectedVersion.version}?`,&#10;                                        responseType: MessageResponseType.OkayCancel,&#10;                                        severity: &quot;danger&quot;&#10;                                    });&#10;                                    if (response) await handleUninstall();&#10;                                }}&#10;                            &gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt; : null&#10;                }&#10;&#10;            &lt;/div&gt;&#10;            {isInstalling &amp;&amp;&#10;                &lt;Progress&#10;                    size={&quot;sm&quot;}&#10;                    minValue={0}&#10;                    maxValue={1}&#10;                    value={installationProgress}&#10;                /&gt;&#10;            }&#10;        &lt;/div&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {useJavaVersion} from &quot;../../providers/JavaVersionProvider.tsx&quot;;&#10;import {Button, Progress, Select, SelectItem, SelectSection} from &quot;@heroui/react&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {JavaVersion} from &quot;../../ts/java-versions.ts&quot;;&#10;import {Tooltip} from &quot;../extended/Tooltip.tsx&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {useMessage} from &quot;../../providers/MessageProvider.tsx&quot;;&#10;import {MessageResponseType} from &quot;../MessageModal.tsx&quot;;&#10;&#10;type JavaExecutableSelectorProps = {&#10;    value?: string;&#10;    onVersionChange: (version: string | undefined) =&gt; void;&#10;    isDisabled: boolean&#10;}&#10;&#10;export default function JavaExecutableSelector(props: JavaExecutableSelectorProps)&#10;{&#10;    const {onVersionChange, value} = props;&#10;    const {open} = useMessage();&#10;    const {javaVersions, installVersion, refreshJavaVersions, uninstallVersion} = useJavaVersion();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;JavaVersion | undefined&gt;(undefined);&#10;    const [installationProgress, setInstallationProgress] = useState(0);&#10;    const [isInstalling, setIsInstalling] = useState(false);&#10;&#10;    // Initialize selectedVersion based on the value prop when javaVersions are loaded&#10;    useEffect(() =&gt; {&#10;        if (javaVersions.length &gt; 0) {&#10;            if (value) {&#10;                const versionByExecutable = javaVersions.find(v =&gt; v.executable === value);&#10;                if (versionByExecutable !== selectedVersion) {&#10;                    setSelectedVersion(versionByExecutable);&#10;                }&#10;            } else if (!value &amp;&amp; selectedVersion) {&#10;                setSelectedVersion(undefined);&#10;            }&#10;        }&#10;    }, [value, javaVersions]); // Removed selectedVersion from dependencies to avoid circular updates&#10;&#10;    // Update selectedVersion when javaVersions change (after install/uninstall)&#10;    useEffect(() =&gt;&#10;    {&#10;        if (selectedVersion)&#10;        {&#10;            const updatedVersion = javaVersions.find(v =&gt; v.runtime === selectedVersion.runtime);&#10;            if (updatedVersion &amp;&amp; (updatedVersion.installed !== selectedVersion.installed || updatedVersion.executable !== selectedVersion.executable))&#10;            {&#10;                setSelectedVersion(updatedVersion);&#10;            }&#10;        }&#10;    }, [javaVersions, selectedVersion]);&#10;&#10;    // Only notify parent when there's an actual change in selection&#10;    useEffect(() =&gt;&#10;    {&#10;        const newExecutable = selectedVersion?.installed &amp;&amp; selectedVersion?.executable ? selectedVersion.executable : undefined;&#10;        onVersionChange(newExecutable);&#10;    }, [selectedVersion?.executable, selectedVersion?.installed, onVersionChange]);&#10;&#10;    const handleInstall = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedVersion || selectedVersion.installed) return;&#10;&#10;        setInstallationProgress(0);&#10;        setIsInstalling(true);&#10;&#10;        try&#10;        {&#10;            await installVersion(selectedVersion.runtime, (progress) =&gt; setInstallationProgress(progress.progress));&#10;            await refreshJavaVersions();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to install Java version:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsInstalling(false);&#10;            setInstallationProgress(0);&#10;        }&#10;    }, [selectedVersion, installVersion, refreshJavaVersions]);&#10;&#10;    const handleUninstall = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedVersion || !selectedVersion.installed) return;&#10;&#10;        try&#10;        {&#10;            await uninstallVersion(selectedVersion.runtime);&#10;            await refreshJavaVersions();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to uninstall Java version:&quot;, error);&#10;        }&#10;    }, [selectedVersion, uninstallVersion, refreshJavaVersions]);&#10;&#10;    return (&#10;        &lt;div className={&quot;flex flex-col gap-1&quot;}&gt;&#10;            &lt;div className={&quot;flex flex-row gap-2&quot;}&gt;&#10;                &lt;Select&#10;                    label={&quot;Java&quot;}&#10;                    placeholder={&quot;Select Java Version&quot;}&#10;                    radius={&quot;none&quot;}&#10;                    size={&quot;sm&quot;}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    classNames={{listbox: &quot;font-minecraft-body&quot;}}&#10;                    disallowEmptySelection&#10;                    selectedKeys={selectedVersion ? [selectedVersion.runtime] : []}&#10;                    isDisabled={props.isDisabled}&#10;                    onSelectionChange={keys =&gt;&#10;                    {&#10;                        const key = [...keys][0];&#10;                        const selected = javaVersions.find(v =&gt; v.runtime == key);&#10;                        if (selected)&#10;                        {&#10;                            setSelectedVersion(selected);&#10;                        }&#10;                    }}&#10;                &gt;&#10;                    &lt;SelectSection title={&quot;Installed&quot;}&gt;&#10;                        {javaVersions.filter(v =&gt; v.installed &amp;&amp; v.executable != undefined).map((v) =&gt; (&#10;                            &lt;SelectItem&#10;                                key={v.runtime}&#10;                                textValue={`${v.version} (Installed)`}&#10;                            &gt;&#10;                                {v.version} ({v.executable})&#10;                            &lt;/SelectItem&gt;&#10;                        ))}&#10;                    &lt;/SelectSection&gt;&#10;                    &lt;SelectSection title={&quot;Available&quot;}&gt;&#10;                        {javaVersions.filter(v =&gt; !v.installed).map((v) =&gt; (&#10;                            &lt;SelectItem&#10;                                key={v.runtime}&#10;                                textValue={v.version}&#10;                            &gt;&#10;                                {v.version} &lt;span className={&quot;italic opacity-50&quot;}&gt;({v.runtime})&lt;/span&gt;&#10;                            &lt;/SelectItem&gt;&#10;                        ))}&#10;                    &lt;/SelectSection&gt;&#10;                &lt;/Select&gt;&#10;&#10;                {selectedVersion != undefined &amp;&amp; !selectedVersion.installed ?&#10;                    &lt;Tooltip content={&quot;Install this Java version&quot;}&gt;&#10;                        &lt;Button&#10;                            isIconOnly&#10;                            radius={&quot;none&quot;}&#10;                            size={&quot;lg&quot;}&#10;                            variant={&quot;ghost&quot;}&#10;                            color={&quot;primary&quot;}&#10;                            disabled={isInstalling}&#10;                            onPress={async () =&gt;&#10;                            {&#10;                                const response = await open({&#10;                                    title: &quot;Install Java&quot;,&#10;                                    body: `Are you sure you want to install Java ${selectedVersion.version}?`,&#10;                                    responseType: MessageResponseType.YesNo,&#10;                                    severity: &quot;info&quot;&#10;                                });&#10;                                if (response) await handleInstall();&#10;                            }}&#10;                        &gt;&#10;                            &lt;Icon icon={&quot;pixelarticons:download&quot;}/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                    : selectedVersion != undefined &amp;&amp; selectedVersion.installed ?&#10;                        &lt;Tooltip content={&quot;Uninstall this Java version&quot;}&gt;&#10;                            &lt;Button&#10;                                isIconOnly&#10;                                radius={&quot;none&quot;}&#10;                                size={&quot;lg&quot;}&#10;                                color={&quot;danger&quot;}&#10;                                variant={&quot;ghost&quot;}&#10;                                onPress={async () =&gt;&#10;                                {&#10;                                    const response = await open({&#10;                                        title: &quot;Uninstall Java&quot;,&#10;                                        body: `Are you sure you want to uninstall Java ${selectedVersion.version}?`,&#10;                                        responseType: MessageResponseType.OkayCancel,&#10;                                        severity: &quot;danger&quot;&#10;                                    });&#10;                                    if (response) await handleUninstall();&#10;                                }}&#10;                            &gt;&#10;                                &lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;&#10;                            &lt;/Button&gt;&#10;                        &lt;/Tooltip&gt; : null&#10;                }&#10;&#10;            &lt;/div&gt;&#10;            {isInstalling &amp;&amp;&#10;                &lt;Progress&#10;                    size={&quot;sm&quot;}&#10;                    minValue={0}&#10;                    maxValue={1}&#10;                    value={installationProgress}&#10;                /&gt;&#10;            }&#10;        &lt;/div&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/NewServerModal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/NewServerModal.tsx" />
              <option name="originalContent" value="import {addToast, Button, CircularProgress, Input, Link, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader, Tab, Tabs} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {NeoForge} from &quot;../icons/NeoForge.svg.tsx&quot;;&#10;import Quilt from &quot;../icons/Quilt.svg.tsx&quot;;&#10;import {Tooltip} from &quot;../extended/Tooltip.tsx&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {MinecraftVersionSelector} from &quot;./version-selectors/MinecraftVersionSelector.tsx&quot;;&#10;import {ForgeVersionSelector} from &quot;./version-selectors/ForgeVersionSelector.tsx&quot;;&#10;import {FabricVersionSelector} from &quot;./version-selectors/FabricVersionSelector.tsx&quot;;&#10;import {FileInput} from &quot;../extended/FileInput.tsx&quot;;&#10;import {QuiltVersionSelector} from &quot;./version-selectors/QuiltVersionSelector.tsx&quot;;&#10;import {NeoForgeVersionSelector} from &quot;./version-selectors/NeoForgeVersionSelector.tsx&quot;;&#10;import {LoaderType, useServer} from &quot;../../providers/ServerProvider.tsx&quot;;&#10;import RamSlider from &quot;./RamSlider.tsx&quot;;&#10;import JavaExecutableSelector from &quot;./JavaExecutableSelector.tsx&quot;;&#10;import {getMinecraftVersionDownloadUrl} from &quot;../../ts/minecraft-versions.ts&quot;;&#10;&#10;type NewServerProperties = {&#10;    isOpen: boolean;&#10;    onClose: () =&gt; void;&#10;};&#10;&#10;export default function NewServerModal(props: NewServerProperties)&#10;{&#10;    const {createServer, uploadFromUrl, uploadFile, updateServer} = useServer();&#10;    const [ram, setRam] = useState(4); // Default RAM value&#10;    const [selectedLoader, setSelectedLoader] = useState&lt;LoaderType&gt;(&quot;vanilla&quot;); // Default selected loader&#10;    const [loaderVersion, setLoaderVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [selectedMinecraftVersion, setSelectedMinecraftVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [selectedJavaExecutable, setSelectedJavaExecutable] = useState&lt;string | undefined&gt;(undefined);&#10;&#10;    const [loaderUrl, setLoaderUrl] = useState&lt;string | undefined&gt;(undefined); // For custom loader URLs&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [customJarFile, setCustomJarFile] = useState&lt;File | undefined&gt;(undefined); // For custom jar file uploads&#10;    const [isCreatingServer, setIsCreatingServer] = useState(false);&#10;    const [isValidForm, setIsValidForm] = useState(false);&#10;    const [creationProgress, setCreationProgress] = useState(0);&#10;&#10;&#10;    const submit = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedMinecraftVersion || !selectedLoader || !selectedJavaExecutable || !isValidForm)&#10;        {&#10;            console.log(`Invalid form submission: Minecraft Version: ${selectedMinecraftVersion}, Loader: ${selectedLoader}, Java Executable: ${selectedJavaExecutable}, Is Valid Form: ${isValidForm}`);&#10;            return;&#10;        }&#10;        setIsCreatingServer(true);&#10;        setCreationProgress(0.1); // Started creating server&#10;        const filepath = selectedLoader === &quot;vanilla&quot; || selectedLoader === &quot;custom&quot; ? `server-${selectedMinecraftVersion}.jar` : `${selectedLoader}-${loaderVersion}-${selectedMinecraftVersion}-server.jar`;&#10;        try&#10;        {&#10;            let serverId = await createServer({&#10;                name,&#10;                server_type: selectedLoader,&#10;                minecraft_version: selectedMinecraftVersion,&#10;                loader_version: loaderVersion ?? &quot;&quot;,&#10;                java_executable: selectedJavaExecutable&#10;            });&#10;&#10;            setCreationProgress(0.3); // Server created&#10;&#10;            if (!serverId)&#10;            {&#10;                addToast({&#10;                    title: &quot;Error&quot;,&#10;                    description: &quot;Failed to create server. Please try again.&quot;,&#10;                    color: &quot;danger&quot;&#10;                });&#10;                setIsCreatingServer(false);&#10;                return;&#10;            }&#10;&#10;            if (selectedLoader !== &quot;custom&quot;)&#10;            {&#10;                if (!loaderUrl &amp;&amp; selectedLoader !== &quot;vanilla&quot;)&#10;                {&#10;                    console.error(&quot;Loader URL is not defined for selected loader:&quot;, selectedLoader);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: `Loader URL is not defined for selected loader: ${selectedLoader}. Please select a valid loader version.`,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;                const onProgress = (progress: number, downloaded: number, total: number) =&gt;&#10;                {&#10;                    setCreationProgress(0.3 + (progress / 100 * 0.5)); // Progress from 30% to 80%&#10;                    console.log(`Downloading ${selectedLoader} server: ${progress}% (${downloaded}/${total} bytes)`);&#10;                };&#10;                const onSuccess = () =&gt;&#10;                {&#10;                    setCreationProgress(0.8); // Download complete&#10;                };&#10;                const onError = (error: string) =&gt;&#10;                {&#10;                    console.error(&quot;Error uploading server jar:&quot;, error);&#10;                };&#10;                try&#10;                {&#10;                    await uploadFromUrl(loaderUrl ?? await getMinecraftVersionDownloadUrl(selectedMinecraftVersion), filepath, onProgress, onSuccess, onError, serverId);&#10;                } catch (error)&#10;                {&#10;                    console.error(&quot;Error uploading server jar:&quot;, error);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Failed to upload server jar. Please check the URL or try again.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;            } else&#10;            {&#10;                if (!customJarFile)&#10;                {&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Please upload a custom jar file.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    return;&#10;                }&#10;                const onProgress = (bytes: number) =&gt;&#10;                {&#10;                    const percentage = bytes / customJarFile.size;&#10;                    setCreationProgress(0.3 + (percentage * 0.5)); // Progress from 30% to 80%&#10;                    console.log(`Uploading custom server jar: ${bytes} bytes uploaded of ${customJarFile.size} bytes ${Math.round(percentage * 100)}%`);&#10;                };&#10;                const onCancel = () =&gt;&#10;                {&#10;                };&#10;                try&#10;                {&#10;                    await uploadFile(customJarFile, filepath, onProgress, onCancel, serverId);&#10;                    setCreationProgress(0.8); // Upload complete&#10;                } catch (error)&#10;                {&#10;                    console.error(&quot;Error uploading custom jar file:&quot;, error);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Failed to upload custom jar file. Please try again.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;            }&#10;&#10;            try&#10;            {&#10;                await updateServer({max_memory: ram, server_jar: filepath}, serverId);&#10;                setCreationProgress(1); // Server settings updated&#10;            } catch (error)&#10;            {&#10;                console.error(&quot;Error updating server RAM:&quot;, error);&#10;                addToast({&#10;                    title: &quot;Error&quot;,&#10;                    description: &quot;Failed to update server RAM. Please try again.&quot;,&#10;                    color: &quot;danger&quot;&#10;                });&#10;                setIsCreatingServer(false);&#10;                return;&#10;            }&#10;&#10;            setIsCreatingServer(false);&#10;            props.onClose();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error creating server:&quot;, error);&#10;&#10;            addToast({&#10;                title: &quot;Error&quot;,&#10;                description: &quot;Failed to create server. Please try again.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [loaderUrl, selectedLoader, selectedMinecraftVersion, ram, selectedJavaExecutable, isValidForm, name]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        setIsValidForm(name.trim() !== &quot;&quot; &amp;&amp; selectedMinecraftVersion !== undefined &amp;&amp; (selectedLoader !== &quot;custom&quot; || loaderUrl !== undefined) &amp;&amp; selectedJavaExecutable !== undefined);&#10;    }, [loaderUrl, selectedLoader, selectedMinecraftVersion, name, selectedJavaExecutable]);&#10;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={props.isOpen}&#10;            onClose={props.onClose}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{closeButton: &quot;rounded-none&quot;}}&#10;            size={&quot;3xl&quot;}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            isDismissable={!isCreatingServer}&#10;            hideCloseButton={isCreatingServer}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {onClose =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;font-minecraft-header&quot;}&gt;Create New Server&lt;/ModalHeader&gt;&#10;                        &lt;ModalBody className={&quot;flex flex-col gap-4&quot;}&gt;&#10;                            &lt;p className={&quot;font-minecraft-body&quot;}&gt;Configure your server&lt;/p&gt;&#10;                            &lt;Input&#10;                                label={&quot;Server Name&quot;}&#10;                                className={&quot;font-minecraft-body&quot;}&#10;                                radius={&quot;none&quot;}&#10;                                size={&quot;sm&quot;}&#10;                                endContent={&lt;Icon icon={&quot;&quot;}/&gt;}&#10;                                value={name}&#10;                                onValueChange={setName}&#10;                                isDisabled={isCreatingServer}&#10;                            /&gt;&#10;                            &lt;div className={&quot;mx-auto&quot;}&gt;&#10;                                &lt;Tabs&#10;                                    radius={&quot;none&quot;}&#10;                                    className={&quot;font-minecraft-body&quot;}&#10;                                    fullWidth&#10;                                    variant={&quot;solid&quot;}&#10;                                    color={&quot;primary&quot;}&#10;                                    classNames={{&#10;                                        tab: &quot;flex flex-col items-center justify-center h-24 w-28&quot;&#10;                                    }}&#10;                                    isDisabled={isCreatingServer}&#10;                                    selectedKey={selectedLoader}&#10;                                    onSelectionChange={key =&gt; setSelectedLoader(key as LoaderType)}&#10;                                &gt;&#10;                                    &lt;Tab key={&quot;vanilla&quot;} title={&lt;&gt;&lt;Icon icon={&quot;heroicons:cube-transparent-16-solid&quot;} width={32}/&gt;&lt;p&gt;Vanilla&lt;/p&gt;&lt;/&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;fabric&quot;} title={&lt;div className={&quot;relative&quot;}&gt;&lt;Icon icon={&quot;file-icons:fabric&quot;} width={32}/&gt;&lt;p&gt;Fabric&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;forge&quot;} title={&lt;&gt;&lt;Icon icon={&quot;simple-icons:curseforge&quot;} width={32}/&gt;&lt;p&gt;Forge&lt;/p&gt;&lt;/&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;quilt&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;Quilt size={32}/&gt;&lt;p&gt;Quilt&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;neo_forge&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;NeoForge size={32}/&gt;&lt;p&gt;NeoForge&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;custom&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;Icon icon={&quot;pixelarticons:cloud-upload&quot;} width={32}/&gt;&lt;p&gt;Custom Jar&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                &lt;/Tabs&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className={&quot;flex flex-row gap-1 items-center text-gray-500 text-sm font-minecraft-body&quot;}&gt;&#10;                                &lt;Tooltip content={&lt;p&gt;For more information about these settings, &lt;Link href={&quot;https://github.com/Obsidian-Minecraft-Server-Portal/obsidian-server-panel&quot;}&gt;visit the documentation&lt;/Link&gt;.&lt;/p&gt;}&gt;&#10;                                    &lt;Icon icon={&quot;pixelarticons:info-box&quot;}/&gt;&#10;                                &lt;/Tooltip&gt;&#10;                                &lt;p&gt;You can change these settings later in your server options.&lt;/p&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            &lt;MinecraftVersionSelector onVersionChange={setSelectedMinecraftVersion} version={selectedMinecraftVersion} isDisabled={isCreatingServer}/&gt;&#10;                            &lt;LoaderSelector&#10;                                selectedLoader={selectedLoader}&#10;                                version={selectedMinecraftVersion}&#10;                                isSnapshot={(selectedMinecraftVersion?.includes(&quot;snapshot&quot;) || selectedMinecraftVersion?.includes(&quot;pre-release&quot;)) ?? false}&#10;                                onChange={(url, version) =&gt;&#10;                                {&#10;                                    setLoaderUrl(url);&#10;                                    setLoaderVersion(version);&#10;                                }}&#10;                                onCustomJarChange={setCustomJarFile}&#10;                                isDisabled={isCreatingServer}&#10;                            /&gt;&#10;                            &lt;RamSlider value={ram} onValueChange={setRam} isDisabled={isCreatingServer}/&gt;&#10;                            &lt;JavaExecutableSelector onVersionChange={setSelectedJavaExecutable} isDisabled={isCreatingServer}/&gt;&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            &lt;Button onPress={submit} radius={&quot;none&quot;} variant={&quot;ghost&quot;} color={&quot;primary&quot;} isDisabled={!isValidForm || isCreatingServer}&gt;&#10;                                {isCreatingServer &amp;&amp;&#10;                                    &lt;CircularProgress&#10;                                        minValue={0}&#10;                                        maxValue={1}&#10;                                        value={creationProgress}&#10;                                        color={&quot;primary&quot;}&#10;                                        size={&quot;sm&quot;}&#10;                                        classNames={{&#10;                                            svg: &quot;h-6 w-6&quot;&#10;                                        }}&#10;                                    /&gt;&#10;                                }&#10;                                Create&#10;                            &lt;/Button&gt;&#10;                            &lt;Button onPress={onClose} radius={&quot;none&quot;} variant={&quot;light&quot;} color={&quot;danger&quot;} isLoading={isCreatingServer}&gt;Cancel&lt;/Button&gt;&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;type LoaderSelectorProps = {&#10;    selectedLoader: string;&#10;    version: string | undefined;&#10;    onChange: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    onCustomJarChange: (file: File | undefined) =&gt; void;&#10;    isDisabled: boolean;&#10;    isSnapshot: boolean;&#10;}&#10;&#10;function LoaderSelector(props: LoaderSelectorProps)&#10;{&#10;    const {&#10;        selectedLoader,&#10;        version,&#10;        onChange,&#10;        isDisabled&#10;    } = props;&#10;    if (!version) return &lt;p className={&quot;text-danger font-minecraft-body text-tiny italic underline&quot;}&gt;Please select a Minecraft version first.&lt;/p&gt;;&#10;    switch (selectedLoader)&#10;    {&#10;        case &quot;fabric&quot;:&#10;            return &lt;FabricVersionSelector minecraftVersion={version} onVersionChange={onChange} isDisabled={isDisabled} isSnapshot={props.isSnapshot}/&gt;;&#10;        case &quot;forge&quot;:&#10;            return &lt;ForgeVersionSelector minecraftVersion={version} onVersionChange={onChange} isDisabled={isDisabled}/&gt;;&#10;        case &quot;quilt&quot;:&#10;            return &lt;QuiltVersionSelector minecraftVersion={version} isDisabled={isDisabled}/&gt;;&#10;        case &quot;neo_forge&quot;:&#10;            return &lt;NeoForgeVersionSelector minecraftVersion={version} isDisabled={isDisabled}/&gt;;&#10;        case &quot;custom&quot;:&#10;            return (&#10;                &lt;FileInput&#10;                    accept={&quot;.jar,.zip,.tar.gz,.tar&quot;}&#10;                    description={&quot;Upload your custom jar file or modpack archive.&quot;}&#10;                    multiple={false}&#10;                    onChange={file =&gt; props.onCustomJarChange(file as File | undefined)}&#10;                    readOnly={isDisabled}&#10;                /&gt;&#10;            );&#10;        default:&#10;            return null;&#10;    }&#10;}" />
              <option name="updatedContent" value="import {addToast, Button, CircularProgress, Input, Link, Modal, ModalBody, ModalContent, ModalFooter, ModalHeader, Tab, Tabs} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {NeoForge} from &quot;../icons/NeoForge.svg.tsx&quot;;&#10;import Quilt from &quot;../icons/Quilt.svg.tsx&quot;;&#10;import {Tooltip} from &quot;../extended/Tooltip.tsx&quot;;&#10;import {useCallback, useEffect, useState} from &quot;react&quot;;&#10;import {MinecraftVersionSelector} from &quot;./version-selectors/MinecraftVersionSelector.tsx&quot;;&#10;import {ForgeVersionSelector} from &quot;./version-selectors/ForgeVersionSelector.tsx&quot;;&#10;import {FabricVersionSelector} from &quot;./version-selectors/FabricVersionSelector.tsx&quot;;&#10;import {FileInput} from &quot;../extended/FileInput.tsx&quot;;&#10;import {QuiltVersionSelector} from &quot;./version-selectors/QuiltVersionSelector.tsx&quot;;&#10;import {NeoForgeVersionSelector} from &quot;./version-selectors/NeoForgeVersionSelector.tsx&quot;;&#10;import {LoaderType, useServer} from &quot;../../providers/ServerProvider.tsx&quot;;&#10;import RamSlider from &quot;./RamSlider.tsx&quot;;&#10;import JavaExecutableSelector from &quot;./JavaExecutableSelector.tsx&quot;;&#10;import {getMinecraftVersionDownloadUrl} from &quot;../../ts/minecraft-versions.ts&quot;;&#10;&#10;type NewServerProperties = {&#10;    isOpen: boolean;&#10;    onClose: () =&gt; void;&#10;};&#10;&#10;export default function NewServerModal(props: NewServerProperties)&#10;{&#10;    const {createServer, uploadFromUrl, uploadFile, updateServer} = useServer();&#10;    const [ram, setRam] = useState(4); // Default RAM value&#10;    const [selectedLoader, setSelectedLoader] = useState&lt;LoaderType&gt;(&quot;vanilla&quot;); // Default selected loader&#10;    const [loaderVersion, setLoaderVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [selectedMinecraftVersion, setSelectedMinecraftVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [selectedJavaExecutable, setSelectedJavaExecutable] = useState&lt;string | undefined&gt;(undefined);&#10;&#10;    const [loaderUrl, setLoaderUrl] = useState&lt;string | undefined&gt;(undefined); // For custom loader URLs&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [customJarFile, setCustomJarFile] = useState&lt;File | undefined&gt;(undefined); // For custom jar file uploads&#10;    const [isCreatingServer, setIsCreatingServer] = useState(false);&#10;    const [isValidForm, setIsValidForm] = useState(false);&#10;    const [creationProgress, setCreationProgress] = useState(0);&#10;&#10;&#10;    const submit = useCallback(async () =&gt;&#10;    {&#10;        if (!selectedMinecraftVersion || !selectedLoader || !selectedJavaExecutable || !isValidForm)&#10;        {&#10;            console.log(`Invalid form submission: Minecraft Version: ${selectedMinecraftVersion}, Loader: ${selectedLoader}, Java Executable: ${selectedJavaExecutable}, Is Valid Form: ${isValidForm}`);&#10;            return;&#10;        }&#10;        setIsCreatingServer(true);&#10;        setCreationProgress(0.1); // Started creating server&#10;        const filepath = selectedLoader === &quot;vanilla&quot; || selectedLoader === &quot;custom&quot; ? `server-${selectedMinecraftVersion}.jar` : `${selectedLoader}-${loaderVersion}-${selectedMinecraftVersion}-server.jar`;&#10;        try&#10;        {&#10;            let serverId = await createServer({&#10;                name,&#10;                server_type: selectedLoader,&#10;                minecraft_version: selectedMinecraftVersion,&#10;                loader_version: loaderVersion ?? &quot;&quot;,&#10;                java_executable: selectedJavaExecutable&#10;            });&#10;&#10;            setCreationProgress(0.3); // Server created&#10;&#10;            if (!serverId)&#10;            {&#10;                addToast({&#10;                    title: &quot;Error&quot;,&#10;                    description: &quot;Failed to create server. Please try again.&quot;,&#10;                    color: &quot;danger&quot;&#10;                });&#10;                setIsCreatingServer(false);&#10;                return;&#10;            }&#10;&#10;            if (selectedLoader !== &quot;custom&quot;)&#10;            {&#10;                if (!loaderUrl &amp;&amp; selectedLoader !== &quot;vanilla&quot;)&#10;                {&#10;                    console.error(&quot;Loader URL is not defined for selected loader:&quot;, selectedLoader);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: `Loader URL is not defined for selected loader: ${selectedLoader}. Please select a valid loader version.`,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;                const onProgress = (progress: number, downloaded: number, total: number) =&gt;&#10;                {&#10;                    setCreationProgress(0.3 + (progress / 100 * 0.5)); // Progress from 30% to 80%&#10;                    console.log(`Downloading ${selectedLoader} server: ${progress}% (${downloaded}/${total} bytes)`);&#10;                };&#10;                const onSuccess = () =&gt;&#10;                {&#10;                    setCreationProgress(0.8); // Download complete&#10;                };&#10;                const onError = (error: string) =&gt;&#10;                {&#10;                    console.error(&quot;Error uploading server jar:&quot;, error);&#10;                };&#10;                try&#10;                {&#10;                    await uploadFromUrl(loaderUrl ?? await getMinecraftVersionDownloadUrl(selectedMinecraftVersion), filepath, onProgress, onSuccess, onError, serverId);&#10;                    setCreationProgress(0.8); // Download complete after successful upload&#10;                } catch (error)&#10;                {&#10;                    console.error(&quot;Error uploading server jar:&quot;, error);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Failed to upload server jar. Please check the URL or try again.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;            } else&#10;            {&#10;                if (!customJarFile)&#10;                {&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Please upload a custom jar file.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    return;&#10;                }&#10;                const onProgress = (bytes: number) =&gt;&#10;                {&#10;                    const percentage = bytes / customJarFile.size;&#10;                    setCreationProgress(0.3 + (percentage * 0.5)); // Progress from 30% to 80%&#10;                    console.log(`Uploading custom server jar: ${bytes} bytes uploaded of ${customJarFile.size} bytes ${Math.round(percentage * 100)}%`);&#10;                };&#10;                const onCancel = () =&gt;&#10;                {&#10;                };&#10;                try&#10;                {&#10;                    await uploadFile(customJarFile, filepath, onProgress, onCancel, serverId);&#10;                    setCreationProgress(0.8); // Upload complete&#10;                } catch (error)&#10;                {&#10;                    console.error(&quot;Error uploading custom jar file:&quot;, error);&#10;                    addToast({&#10;                        title: &quot;Error&quot;,&#10;                        description: &quot;Failed to upload custom jar file. Please try again.&quot;,&#10;                        color: &quot;danger&quot;&#10;                    });&#10;                    setIsCreatingServer(false);&#10;                    return;&#10;                }&#10;            }&#10;&#10;            try&#10;            {&#10;                await updateServer({max_memory: ram, server_jar: filepath}, serverId);&#10;                setCreationProgress(1); // Server settings updated&#10;            } catch (error)&#10;            {&#10;                console.error(&quot;Error updating server RAM:&quot;, error);&#10;                addToast({&#10;                    title: &quot;Error&quot;,&#10;                    description: &quot;Failed to update server RAM. Please try again.&quot;,&#10;                    color: &quot;danger&quot;&#10;                });&#10;                setIsCreatingServer(false);&#10;                return;&#10;            }&#10;&#10;            setIsCreatingServer(false);&#10;            props.onClose();&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error creating server:&quot;, error);&#10;&#10;            addToast({&#10;                title: &quot;Error&quot;,&#10;                description: &quot;Failed to create server. Please try again.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;        }&#10;    }, [loaderUrl, selectedLoader, selectedMinecraftVersion, ram, selectedJavaExecutable, isValidForm, name]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        setIsValidForm(name.trim() !== &quot;&quot; &amp;&amp; selectedMinecraftVersion !== undefined &amp;&amp; (selectedLoader !== &quot;custom&quot; || loaderUrl !== undefined) &amp;&amp; selectedJavaExecutable !== undefined);&#10;    }, [loaderUrl, selectedLoader, selectedMinecraftVersion, name, selectedJavaExecutable]);&#10;&#10;    return (&#10;        &lt;Modal&#10;            isOpen={props.isOpen}&#10;            onClose={props.onClose}&#10;            backdrop={&quot;blur&quot;}&#10;            radius={&quot;none&quot;}&#10;            closeButton={&lt;Icon icon={&quot;pixelarticons:close-box&quot;} width={24}/&gt;}&#10;            classNames={{closeButton: &quot;rounded-none&quot;}}&#10;            size={&quot;3xl&quot;}&#10;            scrollBehavior={&quot;inside&quot;}&#10;            isDismissable={!isCreatingServer}&#10;            hideCloseButton={isCreatingServer}&#10;        &gt;&#10;            &lt;ModalContent&gt;&#10;                {onClose =&gt; (&#10;                    &lt;&gt;&#10;                        &lt;ModalHeader className={&quot;font-minecraft-header&quot;}&gt;Create New Server&lt;/ModalHeader&gt;&#10;                        &lt;ModalBody className={&quot;flex flex-col gap-4&quot;}&gt;&#10;                            &lt;p className={&quot;font-minecraft-body&quot;}&gt;Configure your server&lt;/p&gt;&#10;                            &lt;Input&#10;                                label={&quot;Server Name&quot;}&#10;                                className={&quot;font-minecraft-body&quot;}&#10;                                radius={&quot;none&quot;}&#10;                                size={&quot;sm&quot;}&#10;                                endContent={&lt;Icon icon={&quot;&quot;}/&gt;}&#10;                                value={name}&#10;                                onValueChange={setName}&#10;                                isDisabled={isCreatingServer}&#10;                            /&gt;&#10;                            &lt;div className={&quot;mx-auto&quot;}&gt;&#10;                                &lt;Tabs&#10;                                    radius={&quot;none&quot;}&#10;                                    className={&quot;font-minecraft-body&quot;}&#10;                                    fullWidth&#10;                                    variant={&quot;solid&quot;}&#10;                                    color={&quot;primary&quot;}&#10;                                    classNames={{&#10;                                        tab: &quot;flex flex-col items-center justify-center h-24 w-28&quot;&#10;                                    }}&#10;                                    isDisabled={isCreatingServer}&#10;                                    selectedKey={selectedLoader}&#10;                                    onSelectionChange={key =&gt; setSelectedLoader(key as LoaderType)}&#10;                                &gt;&#10;                                    &lt;Tab key={&quot;vanilla&quot;} title={&lt;&gt;&lt;Icon icon={&quot;heroicons:cube-transparent-16-solid&quot;} width={32}/&gt;&lt;p&gt;Vanilla&lt;/p&gt;&lt;/&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;fabric&quot;} title={&lt;div className={&quot;relative&quot;}&gt;&lt;Icon icon={&quot;file-icons:fabric&quot;} width={32}/&gt;&lt;p&gt;Fabric&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;forge&quot;} title={&lt;&gt;&lt;Icon icon={&quot;simple-icons:curseforge&quot;} width={32}/&gt;&lt;p&gt;Forge&lt;/p&gt;&lt;/&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;quilt&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;Quilt size={32}/&gt;&lt;p&gt;Quilt&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;neo_forge&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;NeoForge size={32}/&gt;&lt;p&gt;NeoForge&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                    &lt;Tab key={&quot;custom&quot;} title={&lt;div className={&quot;flex justify-center items-center flex-col gap-2&quot;}&gt;&lt;Icon icon={&quot;pixelarticons:cloud-upload&quot;} width={32}/&gt;&lt;p&gt;Custom Jar&lt;/p&gt;&lt;/div&gt;}/&gt;&#10;                                &lt;/Tabs&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className={&quot;flex flex-row gap-1 items-center text-gray-500 text-sm font-minecraft-body&quot;}&gt;&#10;                                &lt;Tooltip content={&lt;p&gt;For more information about these settings, &lt;Link href={&quot;https://github.com/Obsidian-Minecraft-Server-Portal/obsidian-server-panel&quot;}&gt;visit the documentation&lt;/Link&gt;.&lt;/p&gt;}&gt;&#10;                                    &lt;Icon icon={&quot;pixelarticons:info-box&quot;}/&gt;&#10;                                &lt;/Tooltip&gt;&#10;                                &lt;p&gt;You can change these settings later in your server options.&lt;/p&gt;&#10;                            &lt;/div&gt;&#10;&#10;                            &lt;MinecraftVersionSelector onVersionChange={setSelectedMinecraftVersion} version={selectedMinecraftVersion} isDisabled={isCreatingServer}/&gt;&#10;                            &lt;LoaderSelector&#10;                                selectedLoader={selectedLoader}&#10;                                version={selectedMinecraftVersion}&#10;                                isSnapshot={(selectedMinecraftVersion?.includes(&quot;snapshot&quot;) || selectedMinecraftVersion?.includes(&quot;pre-release&quot;)) ?? false}&#10;                                onChange={(url, version) =&gt;&#10;                                {&#10;                                    setLoaderUrl(url);&#10;                                    setLoaderVersion(version);&#10;                                }}&#10;                                onCustomJarChange={setCustomJarFile}&#10;                                isDisabled={isCreatingServer}&#10;                            /&gt;&#10;                            &lt;RamSlider value={ram} onValueChange={setRam} isDisabled={isCreatingServer}/&gt;&#10;                            &lt;JavaExecutableSelector onVersionChange={setSelectedJavaExecutable} isDisabled={isCreatingServer}/&gt;&#10;                        &lt;/ModalBody&gt;&#10;                        &lt;ModalFooter&gt;&#10;                            &lt;Button onPress={submit} radius={&quot;none&quot;} variant={&quot;ghost&quot;} color={&quot;primary&quot;} isDisabled={!isValidForm || isCreatingServer}&gt;&#10;                                {isCreatingServer &amp;&amp;&#10;                                    &lt;CircularProgress&#10;                                        minValue={0}&#10;                                        maxValue={1}&#10;                                        value={creationProgress}&#10;                                        color={&quot;primary&quot;}&#10;                                        size={&quot;sm&quot;}&#10;                                        classNames={{&#10;                                            svg: &quot;h-6 w-6&quot;&#10;                                        }}&#10;                                    /&gt;&#10;                                }&#10;                                Create&#10;                            &lt;/Button&gt;&#10;                            &lt;Button onPress={onClose} radius={&quot;none&quot;} variant={&quot;light&quot;} color={&quot;danger&quot;} isLoading={isCreatingServer}&gt;Cancel&lt;/Button&gt;&#10;                        &lt;/ModalFooter&gt;&#10;                    &lt;/&gt;&#10;                )}&#10;            &lt;/ModalContent&gt;&#10;        &lt;/Modal&gt;&#10;    );&#10;}&#10;&#10;type LoaderSelectorProps = {&#10;    selectedLoader: string;&#10;    version: string | undefined;&#10;    onChange: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    onCustomJarChange: (file: File | undefined) =&gt; void;&#10;    isDisabled: boolean;&#10;    isSnapshot: boolean;&#10;}&#10;&#10;function LoaderSelector(props: LoaderSelectorProps)&#10;{&#10;    const {&#10;        selectedLoader,&#10;        version,&#10;        onChange,&#10;        isDisabled&#10;    } = props;&#10;    if (!version) return &lt;p className={&quot;text-danger font-minecraft-body text-tiny italic underline&quot;}&gt;Please select a Minecraft version first.&lt;/p&gt;;&#10;    switch (selectedLoader)&#10;    {&#10;        case &quot;fabric&quot;:&#10;            return &lt;FabricVersionSelector minecraftVersion={version} onVersionChange={onChange} isDisabled={isDisabled} isSnapshot={props.isSnapshot}/&gt;;&#10;        case &quot;forge&quot;:&#10;            return &lt;ForgeVersionSelector minecraftVersion={version} onVersionChange={onChange} isDisabled={isDisabled}/&gt;;&#10;        case &quot;quilt&quot;:&#10;            return &lt;QuiltVersionSelector minecraftVersion={version} isDisabled={isDisabled}/&gt;;&#10;        case &quot;neo_forge&quot;:&#10;            return &lt;NeoForgeVersionSelector minecraftVersion={version} isDisabled={isDisabled}/&gt;;&#10;        case &quot;custom&quot;:&#10;            return (&#10;                &lt;FileInput&#10;                    accept={&quot;.jar,.zip,.tar.gz,.tar&quot;}&#10;                    description={&quot;Upload your custom jar file or modpack archive.&quot;}&#10;                    multiple={false}&#10;                    onChange={file =&gt; props.onCustomJarChange(file as File | undefined)}&#10;                    readOnly={isDisabled}&#10;                /&gt;&#10;            );&#10;        default:&#10;            return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/files/RowContextMenu.tsx" />
              <option name="originalContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;" />
              <option name="updatedContent" value="import {Listbox, ListboxItem, ListboxSection} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {FilesystemEntry} from &quot;../../../../ts/filesystem.ts&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import $ from &quot;jquery&quot;;&#10;import {isTextFile} from &quot;../../../../ts/file-type-match.ts&quot;;&#10;import {useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;&#10;// Helper function to check if a file is an archive&#10;const isArchiveFile = (filename: string): boolean =&gt; {&#10;    const archiveExtensions = ['.zip', '.tar.gz', '.tgz', '.tar', '.rar', '.7z'];&#10;    const lowerFilename = filename.toLowerCase();&#10;    return archiveExtensions.some(ext =&gt; lowerFilename.endsWith(ext));&#10;};&#10;&#10;// Helper function to get archive name without extension&#10;const getArchiveBaseName = (filename: string): string =&gt; {&#10;    if (filename.toLowerCase().endsWith('.tar.gz')) {&#10;        return filename.slice(0, -7); // Remove .tar.gz&#10;    } else if (filename.toLowerCase().endsWith('.tgz')) {&#10;        return filename.slice(0, -4); // Remove .tgz&#10;    } else {&#10;        // Remove last extension for other formats&#10;        const lastDotIndex = filename.lastIndexOf('.');&#10;        return lastDotIndex &gt; 0 ? filename.slice(0, lastDotIndex) : filename;&#10;    }&#10;};&#10;&#10;export type ContextMenuOptions = {&#10;    entry?: FilesystemEntry | FilesystemEntry[];&#10;    x: number;&#10;    y: number;&#10;    isOpen: boolean;&#10;}&#10;type RowContextMenuProps = {&#10;    onRename: (entry: FilesystemEntry) =&gt; void;&#10;    onDelete: (entry: FilesystemEntry[]) =&gt; void;&#10;    onArchive: (entry: FilesystemEntry[]) =&gt; void;&#10;    onExtract: (entry: FilesystemEntry, outputPath?: string) =&gt; void;&#10;    onEdit: (entry: FilesystemEntry) =&gt; void;&#10;    onClose: () =&gt; void;&#10;} &amp; ContextMenuOptions;&#10;&#10;export function RowContextMenu({entry, y, x, isOpen, onClose, onRename, onDelete, onArchive, onEdit, onExtract}: RowContextMenuProps)&#10;{&#10;    const {downloadEntry} = useServer();&#10;    const [position, setPosition] = useState({x, y});&#10;    const menuRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;&#10;    const downloadSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;        onClose();&#10;        await downloadEntry(entry);&#10;    }, [entry, downloadEntry, isOpen]);&#10;&#10;    const deleteSelectedEntries = useCallback(async () =&gt;&#10;    {&#10;        if (!entry || !isOpen) return;&#10;&#10;        onClose();&#10;        if (Array.isArray(entry)) onDelete(entry);&#10;        else onDelete([entry]);&#10;    }, [entry, isOpen]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let parent = $(&quot;#server-file-browser&quot;);&#10;        let menu = menuRef.current;&#10;        if (parent.length === 0 || !menu) return;&#10;        let menuElement = $(menu);&#10;&#10;        let offset = parent.offset();&#10;        let parentWidth = parent.width();&#10;        let parentHeight = parent.height();&#10;        let menuWidth = menuElement.outerWidth();&#10;        let menuHeight = menuElement.outerHeight();&#10;        if (!offset || !menuWidth || !menuHeight || !parentWidth || !parentHeight) return;&#10;&#10;&#10;        let newX = x;&#10;        let newY = y;&#10;        if (newX + menuWidth &gt; offset.left + parentWidth)&#10;        {&#10;            newX = (offset.left + parentWidth) - menuWidth - 10; // 10px padding&#10;        }&#10;        if (newY + menuHeight &gt; offset.top + parentHeight)&#10;        {&#10;            newY = (offset.top + parentHeight) - menuHeight - 10; // 10px padding&#10;        }&#10;&#10;        setPosition({x: newX - 50, y: newY - 340});&#10;    }, [x, y, isOpen, onClose]);&#10;    return (&#10;        &lt;Listbox&#10;            id={&quot;server-files-context-menu&quot;}&#10;            ref={menuRef}&#10;            className={&quot;absolute z-50 w-64 bg-background/50 backdrop-blur-sm border border-primary/50 shadow-lg data-[open=true]:opacity-100 data-[open=false]:opacity-0 transition-opacity duration-200 data-[open=false]:pointer-events-none font-minecraft-body&quot;}&#10;            style={{top: position.y, left: position.x}}&#10;            itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&#10;            data-open={isOpen}&#10;            onSelectionChange={() =&gt; onClose()}&#10;            tabIndex={1}&#10;        &gt;&#10;            &lt;ListboxSection title={Array.isArray(entry) ? `${entry.length} Items Selected` : entry?.filename ?? &quot;&quot;} itemClasses={{base: &quot;rounded-none font-minecraft-body&quot;}}&gt;&#10;                {!Array.isArray(entry) &amp;&amp; entry ? (() =&gt;&#10;                {&#10;                    let singleItemOptions = [];&#10;                    if (!entry?.is_dir &amp;&amp; isTextFile(entry?.path))&#10;                    {&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;edit&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:edit-box&quot;}/&gt;} onPress={() =&gt; onEdit(entry)}&gt;Edit&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    // Add extract options for archive files&#10;                    if (!entry?.is_dir &amp;&amp; isArchiveFile(entry?.filename))&#10;                    {&#10;                        const archiveBaseName = getArchiveBaseName(entry.filename);&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-here&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:extract&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry);&#10;                                onClose();&#10;                            }}&gt;Extract Here&lt;/ListboxItem&gt;&#10;                        );&#10;                        singleItemOptions.push(&#10;                            &lt;ListboxItem key={&quot;extract-to-folder&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:folder-open&quot;}/&gt;} onPress={() =&gt; {&#10;                                onExtract(entry, archiveBaseName);&#10;                                onClose();&#10;                            }}&gt;Extract to {archiveBaseName}&lt;/ListboxItem&gt;&#10;                        );&#10;                    }&#10;&#10;                    return (&#10;                        &lt;&gt;&#10;                            {...singleItemOptions}&#10;                            &lt;ListboxItem key={&quot;rename&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:unlink&quot;}/&gt;} onPress={() =&gt;&#10;                            {&#10;                                onRename(entry);&#10;                                onClose();&#10;                            }}&gt;Rename&lt;/ListboxItem&gt;&#10;                        &lt;/&gt;&#10;                    );&#10;                })() : null}&#10;                &lt;ListboxItem key={&quot;archive&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;} onPress={() =&gt; onArchive(Array.isArray(entry) ? entry : [entry] as FilesystemEntry[])}&gt;Archive&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;download&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:flatten&quot;}/&gt;} onPress={downloadSelectedEntries}&gt;Download&lt;/ListboxItem&gt;&#10;                &lt;ListboxItem key={&quot;delete&quot;} color={&quot;danger&quot;} className={&quot;text-danger&quot;} endContent={&lt;Icon icon={&quot;pixelarticons:trash&quot;}/&gt;} onPress={deleteSelectedEntries}&gt;Delete&lt;/ListboxItem&gt;&#10;            &lt;/ListboxSection&gt;&#10;        &lt;/Listbox&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/server-page/options/ServerOptions.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/server-page/options/ServerOptions.tsx" />
              <option name="originalContent" value="import {Button, Divider, Input, Select, SelectItem, Switch, Tab, Tabs, Textarea} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {LoaderType, useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import RamSlider from &quot;../../RamSlider.tsx&quot;;&#10;import JavaExecutableSelector from &quot;../../JavaExecutableSelector.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {MinecraftVersionSelector} from &quot;../../version-selectors/MinecraftVersionSelector.tsx&quot;;&#10;import {ForgeVersionSelector} from &quot;../../version-selectors/ForgeVersionSelector.tsx&quot;;&#10;import {FabricVersionSelector} from &quot;../../version-selectors/FabricVersionSelector.tsx&quot;;&#10;import {QuiltVersionSelector} from &quot;../../version-selectors/QuiltVersionSelector.tsx&quot;;&#10;import {NeoForgeVersionSelector} from &quot;../../version-selectors/NeoForgeVersionSelector.tsx&quot;;&#10;import {FileInput} from &quot;../../../extended/FileInput.tsx&quot;;&#10;import {NeoForge} from &quot;../../../icons/NeoForge.svg.tsx&quot;;&#10;import Quilt from &quot;../../../icons/Quilt.svg.tsx&quot;;&#10;import {getMinecraftVersionDownloadUrl} from &quot;../../../../ts/minecraft-versions.ts&quot;;&#10;import {ServerIcon} from &quot;../ServerIcon.tsx&quot;;&#10;&#10;export function ServerOptions()&#10;{&#10;    const {server, updateServer, getEntries, uploadFromUrl, uploadFile} = useServer();&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isSaving, setIsSaving] = useState(false);&#10;&#10;    // Form state&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [description, setDescription] = useState(&quot;&quot;);&#10;    const [javaExecutable, setJavaExecutable] = useState(&quot;&quot;);&#10;    const [javaArgs, setJavaArgs] = useState(&quot;&quot;);&#10;    const [minecraftArgs, setMinecraftArgs] = useState(&quot;&quot;);&#10;    const [maxMemory, setMaxMemory] = useState(4);&#10;    const [minMemory, setMinMemory] = useState(1);&#10;    const [serverJar, setServerJar] = useState(&quot;&quot;);&#10;    const [upnpEnabled, setUpnpEnabled] = useState(false);&#10;    const [autoStart, setAutoStart] = useState(false);&#10;    const [autoRestart, setAutoRestart] = useState(false);&#10;&#10;    // Loader configuration state&#10;    const [loaderType, setLoaderType] = useState&lt;LoaderType&gt;(&quot;vanilla&quot;);&#10;    const [minecraftVersion, setMinecraftVersion] = useState(&quot;&quot;);&#10;    const [loaderVersion, setLoaderVersion] = useState(&quot;&quot;);&#10;    const [loaderUrl, setLoaderUrl] = useState&lt;string | undefined&gt;(undefined);&#10;    const [customJarFile, setCustomJarFile] = useState&lt;File | undefined&gt;(undefined);&#10;    const [isUploadingLoader, setIsUploadingLoader] = useState(false);&#10;    const firstLoadStateRef = useRef(false);&#10;&#10;    // Available files&#10;    const [availableFiles, setAvailableFiles] = useState&lt;string[]&gt;([]);&#10;&#10;&#10;    const loadAvailableFiles = useCallback(async () =&gt;&#10;    {&#10;        if (!server) return;&#10;&#10;        setIsLoading(true);&#10;        try&#10;        {&#10;            const entries = await getEntries(&quot;&quot;);&#10;            const files = entries.entries&#10;                .filter(entry =&gt; !entry.is_dir)&#10;                .filter(entry =&gt;&#10;                {&#10;                    const name = entry.filename.toLowerCase();&#10;                    return name.endsWith(&quot;.jar&quot;) || name.endsWith(&quot;.bat&quot;) || name.endsWith(&quot;.sh&quot;);&#10;                })&#10;                .map(entry =&gt; entry.filename);&#10;&#10;            setAvailableFiles(files);&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to load server files:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsLoading(false);&#10;        }&#10;    }, [server, getEntries]);&#10;&#10;    const handleLoaderChange = useCallback((url: string | undefined, version: string | undefined) =&gt;&#10;    {&#10;        if (!version) return;&#10;        setLoaderUrl(url);&#10;        setLoaderVersion(version);&#10;    }, []);&#10;&#10;    const generateNewJarFilename = useCallback(() =&gt;&#10;    {&#10;        if (loaderType === &quot;vanilla&quot; || loaderType === &quot;custom&quot;)&#10;        {&#10;            return `server-${minecraftVersion}.jar`;&#10;        }&#10;        return `${loaderType}-${loaderVersion}-${minecraftVersion}-server.jar`;&#10;    }, [loaderType, loaderVersion, minecraftVersion]);&#10;&#10;    const hasLoaderChanges = useCallback(() =&gt;&#10;    {&#10;        if (!server) return false;&#10;        return (&#10;            loaderType.toLowerCase() !== server.server_type.toLowerCase() ||&#10;            minecraftVersion !== server.minecraft_version ||&#10;            loaderVersion !== server.loader_version&#10;        );&#10;    }, [server, loaderType, minecraftVersion, loaderVersion]);&#10;&#10;    const handleSave = useCallback(async () =&gt;&#10;    {&#10;        if (!server) return;&#10;&#10;        setIsSaving(true);&#10;&#10;        try&#10;        {&#10;            let finalServerJar = serverJar;&#10;&#10;            // If loader configuration changed, upload a new server jar&#10;            if (hasLoaderChanges())&#10;            {&#10;                setIsUploadingLoader(true);&#10;                const newJarFilename = generateNewJarFilename();&#10;&#10;                if (loaderType !== &quot;custom&quot;)&#10;                {&#10;                    if (!loaderUrl)&#10;                    {&#10;                        throw new Error(`Loader URL is not defined for selected loader: ${loaderType}`);&#10;                    }&#10;&#10;&#10;                    await uploadFromUrl(&#10;                        loaderType === &quot;vanilla&quot; ? await getMinecraftVersionDownloadUrl(minecraftVersion) : loaderUrl,&#10;                        newJarFilename,&#10;                        (progress) =&gt; console.log(`Downloading ${loaderType} server: ${progress}%`),&#10;                        () =&gt; console.log(&quot;Download complete&quot;),&#10;                        (error) =&gt; console.error(&quot;Error uploading server jar:&quot;, error),&#10;                        server.id&#10;                    );&#10;                } else&#10;                {&#10;                    if (!customJarFile)&#10;                    {&#10;                        throw new Error(&quot;Please select a custom jar file.&quot;);&#10;                    }&#10;&#10;                    await uploadFile(&#10;                        customJarFile,&#10;                        newJarFilename,&#10;                        (bytes) =&gt; console.log(`Uploading custom jar: ${bytes} bytes`),&#10;                        () =&gt; console.log(&quot;Upload cancelled&quot;),&#10;                        server.id&#10;                    );&#10;                }&#10;&#10;                finalServerJar = newJarFilename;&#10;                setServerJar(newJarFilename);&#10;                setIsUploadingLoader(false);&#10;            }&#10;&#10;            await updateServer({&#10;                name,&#10;                description: description || null,&#10;                java_executable: javaExecutable,&#10;                java_args: javaArgs,&#10;                minecraft_args: minecraftArgs,&#10;                max_memory: maxMemory,&#10;                min_memory: minMemory,&#10;                server_jar: finalServerJar,&#10;                upnp: upnpEnabled,&#10;                auto_start: autoStart,&#10;                auto_restart: autoRestart,&#10;                // Update loader configuration&#10;                server_type: loaderType,&#10;                minecraft_version: minecraftVersion,&#10;                loader_version: loaderVersion&#10;            });&#10;&#10;            // Refresh file list after potential jar upload&#10;            if (hasLoaderChanges())&#10;            {&#10;                await loadAvailableFiles();&#10;            }&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save server settings:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsSaving(false);&#10;            setIsUploadingLoader(false);&#10;        }&#10;    }, [&#10;        server, updateServer, name, description, javaExecutable, javaArgs,&#10;        minecraftArgs, maxMemory, minMemory, serverJar, upnpEnabled,&#10;        autoStart, autoRestart, loaderType, minecraftVersion, loaderVersion, hasLoaderChanges,&#10;        generateNewJarFilename, loaderUrl, customJarFile, uploadFromUrl,&#10;        uploadFile, loadAvailableFiles&#10;    ]);&#10;&#10;    const hasChanges = useCallback(() =&gt;&#10;    {&#10;        if (!server) return false;&#10;&#10;        return (&#10;            name !== server.name ||&#10;            description !== (server.description || &quot;&quot;) ||&#10;            javaExecutable !== server.java_executable ||&#10;            javaArgs !== server.java_args ||&#10;            minecraftArgs !== server.minecraft_args ||&#10;            maxMemory !== server.max_memory ||&#10;            minMemory !== server.min_memory ||&#10;            serverJar !== server.server_jar ||&#10;            upnpEnabled !== server.upnp ||&#10;            autoStart !== server.auto_start ||&#10;            autoRestart !== server.auto_restart ||&#10;            hasLoaderChanges()&#10;        );&#10;    }, [&#10;        server, name, description, javaExecutable, javaArgs, minecraftArgs,&#10;        maxMemory, minMemory, serverJar, upnpEnabled, autoStart, autoRestart,&#10;        hasLoaderChanges&#10;    ]);&#10;    // Load server data when the component mounts or server changes&#10;    useEffect(() =&gt;&#10;    {&#10;        if (server)&#10;        {&#10;            // Only load data once when the server is first set or when server ID changes&#10;            if (!firstLoadStateRef.current)&#10;            {&#10;                console.log(&quot;Options Server&quot;, server);&#10;                firstLoadStateRef.current = true;&#10;                setName(server.name);&#10;                setDescription(server.description || &quot;&quot;);&#10;                setJavaExecutable(server.java_executable);&#10;                setJavaArgs(server.java_args);&#10;                setMinecraftArgs(server.minecraft_args);&#10;                setMaxMemory(server.max_memory);&#10;                setMinMemory(server.min_memory);&#10;                setServerJar(server.server_jar);&#10;                setUpnpEnabled(server.upnp);&#10;                setAutoStart(server.auto_start);&#10;                setAutoRestart(server.auto_restart);&#10;&#10;                // Load loader configuration&#10;                setLoaderType(server.server_type);&#10;                setMinecraftVersion(server.minecraft_version);&#10;                setLoaderVersion(server.loader_version);&#10;            }&#10;&#10;            // Always refresh a file list when server changes&#10;            loadAvailableFiles();&#10;        } else&#10;        {&#10;            // Reset the ref when no server is selected&#10;            firstLoadStateRef.current = false;&#10;        }&#10;    }, [server, loadAvailableFiles, firstLoadStateRef]);&#10;&#10;    if (!server)&#10;    {&#10;        return (&#10;            &lt;div className=&quot;flex items-center justify-center h-full&quot;&gt;&#10;                &lt;p className=&quot;text-gray-500 font-minecraft-body&quot;&gt;No server selected&lt;/p&gt;&#10;            &lt;/div&gt;&#10;        );&#10;    }&#10;&#10;    return (&#10;        &lt;div className=&quot;flex flex-col gap-4 p-6 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] overflow-y-auto&quot;&gt;&#10;            &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                &lt;h2 className=&quot;text-xl font-minecraft-header&quot;&gt;Server Configuration&lt;/h2&gt;&#10;                &lt;Button&#10;                    color=&quot;primary&quot;&#10;                    radius=&quot;none&quot;&#10;                    isLoading={isSaving || isUploadingLoader}&#10;                    isDisabled={!hasChanges()}&#10;                    onPress={handleSave}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:save&quot;/&gt;}&#10;                    className={&quot;absolute right-10 -translate-y-[70px] z-10&quot;}&#10;                    // className={&quot;data-[has-changes=true]:fixed data-[has-changes=false]:absolute data-[has-changes=false]:right-8 data-[has-changes=true]:right-16 z-10&quot;}&#10;                    data-has-changes={hasChanges()}&#10;                &gt;&#10;                    {isUploadingLoader ? &quot;Uploading Server...&quot; : &quot;Save Changes&quot;}&#10;                &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Basic Information */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Basic Information&lt;/h3&gt;&#10;                &lt;div className={&quot;flex flex-row gap-2&quot;}&gt;&#10;                    &lt;ServerIcon id={server.id} isChangeEnabled={true} size={&quot;sm&quot;}/&gt;&#10;                    &lt;Input&#10;                        label=&quot;Server Name&quot;&#10;                        radius=&quot;none&quot;&#10;                        className=&quot;font-minecraft-body&quot;&#10;                        value={name}&#10;                        onValueChange={setName}&#10;                        startContent={&lt;Icon icon=&quot;pixelarticons:device-game-console&quot;/&gt;}&#10;                    /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;Textarea&#10;                    label=&quot;Description&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;Optional server description...&quot;&#10;                    value={description}&#10;                    onValueChange={setDescription}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:note&quot;/&gt;}&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Files */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                    &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Files&lt;/h3&gt;&#10;                    &lt;Tooltip content=&quot;Refresh file list&quot;&gt;&#10;                        &lt;Button&#10;                            isIconOnly&#10;                            size=&quot;sm&quot;&#10;                            variant=&quot;light&quot;&#10;                            radius=&quot;none&quot;&#10;                            isLoading={isLoading}&#10;                            onPress={loadAvailableFiles}&#10;                        &gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:reload&quot;/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;Select&#10;                    label=&quot;Server JAR File&quot;&#10;                    radius=&quot;none&quot;&#10;                    disallowEmptySelection&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    selectedKeys={serverJar ? [serverJar] : []}&#10;                    onSelectionChange={(keys) =&gt;&#10;                    {&#10;                        const selected = Array.from(keys)[0] as string;&#10;                        setServerJar(selected || &quot;&quot;);&#10;                    }}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:file&quot;/&gt;}&#10;                    placeholder=&quot;Select a server file...&quot;&#10;                    isLoading={isLoading}&#10;                    classNames={{&#10;                        base: &quot;capitalize&quot;,&#10;                        popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;                    }}&#10;&#10;                    listboxProps={{&#10;                        itemClasses: {&#10;                            base: &quot;rounded-none font-minecraft-body&quot;&#10;                        }&#10;                    }}&#10;                &gt;&#10;                    {availableFiles.map((file) =&gt; (&#10;                        &lt;SelectItem key={file}&gt;&#10;                            {file}&#10;                        &lt;/SelectItem&gt;&#10;                    ))}&#10;                &lt;/Select&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Loader Configuration */}&#10;            &lt;section className=&quot;space-y-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Type &amp; Version&lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;mx-auto&quot;&gt;&#10;                    &lt;Tabs&#10;                        radius=&quot;none&quot;&#10;                        className=&quot;font-minecraft-body&quot;&#10;                        fullWidth&#10;                        variant=&quot;solid&quot;&#10;                        color=&quot;primary&quot;&#10;                        classNames={{&#10;                            tab: &quot;flex flex-col items-center justify-center h-24 w-28&quot;&#10;                        }}&#10;                        isDisabled={isSaving || isUploadingLoader}&#10;                        selectedKey={loaderType.toLowerCase()}&#10;                        onSelectionChange={async (key) =&gt;&#10;                        {&#10;                            const newLoader = key as LoaderType;&#10;                            setLoaderType(newLoader);&#10;                            if (newLoader === &quot;vanilla&quot;)&#10;                            {&#10;                                // Reset loader URL for vanilla&#10;                                setLoaderUrl(await getMinecraftVersionDownloadUrl(minecraftVersion));&#10;                                setLoaderVersion(&quot;&quot;);&#10;                            }&#10;                        }}&#10;                    &gt;&#10;                        &lt;Tab&#10;                            key=&quot;vanilla&quot;&#10;                            title={&#10;                                &lt;&gt;&#10;                                    &lt;Icon icon=&quot;heroicons:cube-transparent-16-solid&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Vanilla&lt;/p&gt;&#10;                                &lt;/&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;fabric&quot;&#10;                            title={&#10;                                &lt;div className=&quot;relative&quot;&gt;&#10;                                    &lt;Icon icon=&quot;file-icons:fabric&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Fabric&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;forge&quot;&#10;                            title={&#10;                                &lt;&gt;&#10;                                    &lt;Icon icon=&quot;simple-icons:curseforge&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Forge&lt;/p&gt;&#10;                                &lt;/&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;quilt&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;Quilt size={32}/&gt;&#10;                                    &lt;p&gt;Quilt&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;neoforge&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;NeoForge size={32}/&gt;&#10;                                    &lt;p&gt;NeoForge&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;custom&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;Icon icon=&quot;pixelarticons:cloud-upload&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Custom&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                    &lt;/Tabs&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;MinecraftVersionSelector&#10;                    onVersionChange={(version, url) =&gt;&#10;                    {&#10;                        if (!version) return;&#10;                        setMinecraftVersion(version);&#10;                        // Store the vanilla server URL if this is for vanilla servers&#10;                        if (loaderType === &quot;vanilla&quot; &amp;&amp; url)&#10;                        {&#10;                            setLoaderUrl(url);&#10;                        }&#10;                    }}&#10;                    version={minecraftVersion}&#10;                    isDisabled={isSaving || isUploadingLoader}&#10;                /&gt;&#10;&#10;                &lt;LoaderSelector&#10;                    loaderVersion={loaderVersion}&#10;                    selectedLoader={loaderType}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isSnapshot={(minecraftVersion?.includes(&quot;snapshot&quot;) || minecraftVersion?.includes(&quot;pre-release&quot;)) ?? false}&#10;                    onChange={handleLoaderChange}&#10;                    onCustomJarChange={setCustomJarFile}&#10;                    isDisabled={isSaving || isUploadingLoader}&#10;                /&gt;&#10;&#10;                {hasLoaderChanges() &amp;&amp; (&#10;                    &lt;div className=&quot;bg-warning-50 border border-warning-200 rounded-lg p-4&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2 text-warning-700&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:info-box&quot;/&gt;&#10;                            &lt;p className=&quot;font-minecraft-body text-sm&quot;&gt;&#10;                                Server type or version changes detected. A new server jar will be downloaded when you save.&#10;                                {loaderType !== &quot;custom&quot; &amp;&amp; loaderUrl &amp;&amp; (&#10;                                    &lt;span className=&quot;block mt-1 opacity-75&quot;&gt;&#10;                                        New jar: {generateNewJarFilename()}&#10;                                    &lt;/span&gt;&#10;                                )}&#10;                            &lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Java Configuration */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Java Configuration&lt;/h3&gt;&#10;&#10;                &lt;JavaExecutableSelector&#10;                    defaultSelectedExecutable={javaExecutable}&#10;                    onVersionChange={(executable) =&gt;&#10;                    {&#10;                        if (executable) setJavaExecutable(executable);&#10;                    }}&#10;                    isDisabled={false}&#10;                /&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Additional Java Arguments&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;-XX:+UseG1GC -XX:+ParallelRefProcEnabled...&quot;&#10;                    value={javaArgs}&#10;                    onValueChange={setJavaArgs}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:terminal&quot;/&gt;}&#10;                    description=&quot;Additional JVM arguments (excluding -Xmx and -Xms)&quot;&#10;                /&gt;&#10;&#10;                &lt;RamSlider&#10;                    value={maxMemory}&#10;                    onValueChange={setMaxMemory}&#10;                    isDisabled={false}&#10;                /&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Minimum Memory (GB)&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    type=&quot;number&quot;&#10;                    min={1}&#10;                    max={maxMemory}&#10;                    value={minMemory.toString()}&#10;                    onValueChange={(value) =&gt; setMinMemory(Number(value) || 1)}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:memory&quot;/&gt;}&#10;                    description=&quot;Minimum RAM allocation for the JVM&quot;&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Arguments */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Arguments&lt;/h3&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Minecraft Server Arguments&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;--nogui --port 25565...&quot;&#10;                    value={minecraftArgs}&#10;                    onValueChange={setMinecraftArgs}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:command-line&quot;/&gt;}&#10;                    description=&quot;Additional arguments passed to the Minecraft server&quot;&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Features */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Features&lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;&#10;                    &lt;Switch&#10;                        isSelected={upnpEnabled}&#10;                        onValueChange={setUpnpEnabled}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:wifi&quot;/&gt;&#10;                            &lt;span&gt;Enable UPnP Port Forwarding&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;&#10;                    &lt;Switch&#10;                        isSelected={autoStart}&#10;                        onValueChange={setAutoStart}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:power&quot;/&gt;&#10;                            &lt;span&gt;Auto-start on Boot&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;&#10;                    &lt;Switch&#10;                        isSelected={autoRestart}&#10;                        onValueChange={setAutoRestart}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:reload&quot;/&gt;&#10;                            &lt;span&gt;Auto-restart on Crash&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;                &lt;/div&gt;&#10;            &lt;/section&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;type LoaderSelectorProps = {&#10;    selectedLoader: string;&#10;    minecraftVersion: string | undefined;&#10;    loaderVersion: string | undefined;&#10;    onChange: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    onCustomJarChange: (file: File | undefined) =&gt; void;&#10;    isDisabled: boolean;&#10;    isSnapshot: boolean;&#10;}&#10;&#10;function LoaderSelector(props: LoaderSelectorProps)&#10;{&#10;    const {&#10;        selectedLoader,&#10;        minecraftVersion,&#10;        loaderVersion,&#10;        onChange,&#10;        isDisabled&#10;    } = props;&#10;&#10;    if (!minecraftVersion)&#10;    {&#10;        return (&#10;            &lt;p className=&quot;text-danger font-minecraft-body text-tiny italic underline&quot;&gt;&#10;                Please select a Minecraft version first.&#10;            &lt;/p&gt;&#10;        );&#10;    }&#10;&#10;    switch (selectedLoader.toLowerCase())&#10;    {&#10;        case &quot;fabric&quot;:&#10;            return (&#10;                &lt;FabricVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    onVersionChange={onChange}&#10;                    isDisabled={isDisabled}&#10;                    isSnapshot={props.isSnapshot}&#10;                /&gt;&#10;            );&#10;        case &quot;forge&quot;:&#10;            return (&#10;                &lt;ForgeVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    onVersionChange={onChange}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;quilt&quot;:&#10;            return (&#10;                &lt;QuiltVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;neoforge&quot;:&#10;            return (&#10;                &lt;NeoForgeVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;custom&quot;:&#10;            return (&#10;                &lt;FileInput&#10;                    accept=&quot;.jar,.zip,.tar.gz,.tar&quot;&#10;                    description=&quot;Upload your custom jar file or modpack archive.&quot;&#10;                    multiple={false}&#10;                    onChange={(file) =&gt; props.onCustomJarChange(file as File | undefined)}&#10;                    readOnly={isDisabled}&#10;                /&gt;&#10;            );&#10;        default:&#10;            return null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import {Button, Divider, Input, Select, SelectItem, Switch, Tab, Tabs, Textarea} from &quot;@heroui/react&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {useCallback, useEffect, useRef, useState} from &quot;react&quot;;&#10;import {LoaderType, useServer} from &quot;../../../../providers/ServerProvider.tsx&quot;;&#10;import RamSlider from &quot;../../RamSlider.tsx&quot;;&#10;import JavaExecutableSelector from &quot;../../JavaExecutableSelector.tsx&quot;;&#10;import {Tooltip} from &quot;../../../extended/Tooltip.tsx&quot;;&#10;import {MinecraftVersionSelector} from &quot;../../version-selectors/MinecraftVersionSelector.tsx&quot;;&#10;import {ForgeVersionSelector} from &quot;../../version-selectors/ForgeVersionSelector.tsx&quot;;&#10;import {FabricVersionSelector} from &quot;../../version-selectors/FabricVersionSelector.tsx&quot;;&#10;import {QuiltVersionSelector} from &quot;../../version-selectors/QuiltVersionSelector.tsx&quot;;&#10;import {NeoForgeVersionSelector} from &quot;../../version-selectors/NeoForgeVersionSelector.tsx&quot;;&#10;import {FileInput} from &quot;../../../extended/FileInput.tsx&quot;;&#10;import {NeoForge} from &quot;../../../icons/NeoForge.svg.tsx&quot;;&#10;import Quilt from &quot;../../../icons/Quilt.svg.tsx&quot;;&#10;import {getMinecraftVersionDownloadUrl} from &quot;../../../../ts/minecraft-versions.ts&quot;;&#10;import {ServerIcon} from &quot;../ServerIcon.tsx&quot;;&#10;&#10;export function ServerOptions()&#10;{&#10;    const {server, updateServer, getEntries, uploadFromUrl, uploadFile} = useServer();&#10;    const [isLoading, setIsLoading] = useState(false);&#10;    const [isSaving, setIsSaving] = useState(false);&#10;&#10;    // Form state&#10;    const [name, setName] = useState(&quot;&quot;);&#10;    const [description, setDescription] = useState(&quot;&quot;);&#10;    const [javaExecutable, setJavaExecutable] = useState(&quot;&quot;);&#10;    const [javaArgs, setJavaArgs] = useState(&quot;&quot;);&#10;    const [minecraftArgs, setMinecraftArgs] = useState(&quot;&quot;);&#10;    const [maxMemory, setMaxMemory] = useState(4);&#10;    const [minMemory, setMinMemory] = useState(1);&#10;    const [serverJar, setServerJar] = useState(&quot;&quot;);&#10;    const [upnpEnabled, setUpnpEnabled] = useState(false);&#10;    const [autoStart, setAutoStart] = useState(false);&#10;    const [autoRestart, setAutoRestart] = useState(false);&#10;&#10;    // Loader configuration state&#10;    const [loaderType, setLoaderType] = useState&lt;LoaderType&gt;(&quot;vanilla&quot;);&#10;    const [minecraftVersion, setMinecraftVersion] = useState(&quot;&quot;);&#10;    const [loaderVersion, setLoaderVersion] = useState(&quot;&quot;);&#10;    const [loaderUrl, setLoaderUrl] = useState&lt;string | undefined&gt;(undefined);&#10;    const [customJarFile, setCustomJarFile] = useState&lt;File | undefined&gt;(undefined);&#10;    const [isUploadingLoader, setIsUploadingLoader] = useState(false);&#10;    const firstLoadStateRef = useRef(false);&#10;&#10;    // Available files&#10;    const [availableFiles, setAvailableFiles] = useState&lt;string[]&gt;([]);&#10;&#10;&#10;    const loadAvailableFiles = useCallback(async () =&gt;&#10;    {&#10;        if (!server) return;&#10;&#10;        setIsLoading(true);&#10;        try&#10;        {&#10;            const entries = await getEntries(&quot;&quot;);&#10;            const files = entries.entries&#10;                .filter(entry =&gt; !entry.is_dir)&#10;                .filter(entry =&gt;&#10;                {&#10;                    const name = entry.filename.toLowerCase();&#10;                    return name.endsWith(&quot;.jar&quot;) || name.endsWith(&quot;.bat&quot;) || name.endsWith(&quot;.sh&quot;);&#10;                })&#10;                .map(entry =&gt; entry.filename);&#10;&#10;            setAvailableFiles(files);&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to load server files:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsLoading(false);&#10;        }&#10;    }, [server, getEntries]);&#10;&#10;    const handleLoaderChange = useCallback((url: string | undefined, version: string | undefined) =&gt;&#10;    {&#10;        if (!version) return;&#10;        setLoaderUrl(url);&#10;        setLoaderVersion(version);&#10;    }, []);&#10;&#10;    const generateNewJarFilename = useCallback(() =&gt;&#10;    {&#10;        if (loaderType === &quot;vanilla&quot; || loaderType === &quot;custom&quot;)&#10;        {&#10;            return `server-${minecraftVersion}.jar`;&#10;        }&#10;        return `${loaderType}-${loaderVersion}-${minecraftVersion}-server.jar`;&#10;    }, [loaderType, loaderVersion, minecraftVersion]);&#10;&#10;    const hasLoaderChanges = useCallback(() =&gt;&#10;    {&#10;        if (!server) return false;&#10;        return (&#10;            loaderType.toLowerCase() !== server.server_type.toLowerCase() ||&#10;            minecraftVersion !== server.minecraft_version ||&#10;            loaderVersion !== server.loader_version&#10;        );&#10;    }, [server, loaderType, minecraftVersion, loaderVersion]);&#10;&#10;    const handleSave = useCallback(async () =&gt;&#10;    {&#10;        if (!server) return;&#10;&#10;        setIsSaving(true);&#10;&#10;        try&#10;        {&#10;            let finalServerJar = serverJar;&#10;&#10;            // If loader configuration changed, upload a new server jar&#10;            if (hasLoaderChanges())&#10;            {&#10;                setIsUploadingLoader(true);&#10;                const newJarFilename = generateNewJarFilename();&#10;&#10;                if (loaderType !== &quot;custom&quot;)&#10;                {&#10;                    if (!loaderUrl)&#10;                    {&#10;                        throw new Error(`Loader URL is not defined for selected loader: ${loaderType}`);&#10;                    }&#10;&#10;&#10;                    await uploadFromUrl(&#10;                        loaderType === &quot;vanilla&quot; ? await getMinecraftVersionDownloadUrl(minecraftVersion) : loaderUrl,&#10;                        newJarFilename,&#10;                        (progress) =&gt; console.log(`Downloading ${loaderType} server: ${progress}%`),&#10;                        () =&gt; console.log(&quot;Download complete&quot;),&#10;                        (error) =&gt; console.error(&quot;Error uploading server jar:&quot;, error),&#10;                        server.id&#10;                    );&#10;                } else&#10;                {&#10;                    if (!customJarFile)&#10;                    {&#10;                        throw new Error(&quot;Please select a custom jar file.&quot;);&#10;                    }&#10;&#10;                    await uploadFile(&#10;                        customJarFile,&#10;                        newJarFilename,&#10;                        (bytes) =&gt; console.log(`Uploading custom jar: ${bytes} bytes`),&#10;                        () =&gt; console.log(&quot;Upload cancelled&quot;),&#10;                        server.id&#10;                    );&#10;                }&#10;&#10;                finalServerJar = newJarFilename;&#10;                setServerJar(newJarFilename);&#10;            }&#10;&#10;            // Set isUploadingLoader to false only after upload is complete&#10;            setIsUploadingLoader(false);&#10;&#10;            await updateServer({&#10;                name,&#10;                description: description || null,&#10;                java_executable: javaExecutable,&#10;                java_args: javaArgs,&#10;                minecraft_args: minecraftArgs,&#10;                max_memory: maxMemory,&#10;                min_memory: minMemory,&#10;                server_jar: finalServerJar,&#10;                upnp: upnpEnabled,&#10;                auto_start: autoStart,&#10;                auto_restart: autoRestart,&#10;                // Update loader configuration&#10;                server_type: loaderType,&#10;                minecraft_version: minecraftVersion,&#10;                loader_version: loaderVersion&#10;            });&#10;&#10;            // Refresh file list after potential jar upload&#10;            if (hasLoaderChanges())&#10;            {&#10;                await loadAvailableFiles();&#10;            }&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Failed to save server settings:&quot;, error);&#10;        } finally&#10;        {&#10;            setIsSaving(false);&#10;            setIsUploadingLoader(false);&#10;        }&#10;    }, [&#10;        server, updateServer, name, description, javaExecutable, javaArgs,&#10;        minecraftArgs, maxMemory, minMemory, serverJar, upnpEnabled,&#10;        autoStart, autoRestart, loaderType, minecraftVersion, loaderVersion, hasLoaderChanges,&#10;        generateNewJarFilename, loaderUrl, customJarFile, uploadFromUrl,&#10;        uploadFile, loadAvailableFiles&#10;    ]);&#10;&#10;    const hasChanges = useCallback(() =&gt;&#10;    {&#10;        if (!server) return false;&#10;&#10;        return (&#10;            name !== server.name ||&#10;            description !== (server.description || &quot;&quot;) ||&#10;            javaExecutable !== server.java_executable ||&#10;            javaArgs !== server.java_args ||&#10;            minecraftArgs !== server.minecraft_args ||&#10;            maxMemory !== server.max_memory ||&#10;            minMemory !== server.min_memory ||&#10;            serverJar !== server.server_jar ||&#10;            upnpEnabled !== server.upnp ||&#10;            autoStart !== server.auto_start ||&#10;            autoRestart !== server.auto_restart ||&#10;            hasLoaderChanges()&#10;        );&#10;    }, [&#10;        server, name, description, javaExecutable, javaArgs, minecraftArgs,&#10;        maxMemory, minMemory, serverJar, upnpEnabled, autoStart, autoRestart,&#10;        hasLoaderChanges&#10;    ]);&#10;    // Load server data when the component mounts or server changes&#10;    useEffect(() =&gt;&#10;    {&#10;        if (server)&#10;        {&#10;            // Only load data once when the server is first set or when server ID changes&#10;            if (!firstLoadStateRef.current)&#10;            {&#10;                console.log(&quot;Options Server&quot;, server);&#10;                firstLoadStateRef.current = true;&#10;                setName(server.name);&#10;                setDescription(server.description || &quot;&quot;);&#10;                setJavaExecutable(server.java_executable);&#10;                setJavaArgs(server.java_args);&#10;                setMinecraftArgs(server.minecraft_args);&#10;                setMaxMemory(server.max_memory);&#10;                setMinMemory(server.min_memory);&#10;                setServerJar(server.server_jar);&#10;                setUpnpEnabled(server.upnp);&#10;                setAutoStart(server.auto_start);&#10;                setAutoRestart(server.auto_restart);&#10;&#10;                // Load loader configuration&#10;                setLoaderType(server.server_type);&#10;                setMinecraftVersion(server.minecraft_version);&#10;                setLoaderVersion(server.loader_version);&#10;            }&#10;&#10;            // Always refresh a file list when server changes&#10;            loadAvailableFiles();&#10;        } else&#10;        {&#10;            // Reset the ref when no server is selected&#10;            firstLoadStateRef.current = false;&#10;        }&#10;    }, [server, loadAvailableFiles, firstLoadStateRef]);&#10;&#10;    if (!server)&#10;    {&#10;        return (&#10;            &lt;div className=&quot;flex items-center justify-center h-full&quot;&gt;&#10;                &lt;p className=&quot;text-gray-500 font-minecraft-body&quot;&gt;No server selected&lt;/p&gt;&#10;            &lt;/div&gt;&#10;        );&#10;    }&#10;&#10;    return (&#10;        &lt;div className=&quot;flex flex-col gap-4 p-6 bg-default-50 max-h-[calc(100dvh_-_400px)] h-screen min-h-[300px] overflow-y-auto&quot;&gt;&#10;            &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;                &lt;h2 className=&quot;text-xl font-minecraft-header&quot;&gt;Server Configuration&lt;/h2&gt;&#10;                &lt;Button&#10;                    color=&quot;primary&quot;&#10;                    radius=&quot;none&quot;&#10;                    isLoading={isSaving || isUploadingLoader}&#10;                    isDisabled={!hasChanges()}&#10;                    onPress={handleSave}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:save&quot;/&gt;}&#10;                    className={&quot;absolute right-10 -translate-y-[70px] z-10&quot;}&#10;                    // className={&quot;data-[has-changes=true]:fixed data-[has-changes=false]:absolute data-[has-changes=false]:right-8 data-[has-changes=true]:right-16 z-10&quot;}&#10;                    data-has-changes={hasChanges()}&#10;                &gt;&#10;                    {isUploadingLoader ? &quot;Uploading Server...&quot; : &quot;Save Changes&quot;}&#10;                &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Basic Information */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Basic Information&lt;/h3&gt;&#10;                &lt;div className={&quot;flex flex-row gap-2&quot;}&gt;&#10;                    &lt;ServerIcon id={server.id} isChangeEnabled={true} size={&quot;sm&quot;}/&gt;&#10;                    &lt;Input&#10;                        label=&quot;Server Name&quot;&#10;                        radius=&quot;none&quot;&#10;                        className=&quot;font-minecraft-body&quot;&#10;                        value={name}&#10;                        onValueChange={setName}&#10;                        startContent={&lt;Icon icon=&quot;pixelarticons:device-game-console&quot;/&gt;}&#10;                    /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;Textarea&#10;                    label=&quot;Description&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;Optional server description...&quot;&#10;                    value={description}&#10;                    onValueChange={setDescription}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:note&quot;/&gt;}&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Files */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                    &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Files&lt;/h3&gt;&#10;                    &lt;Tooltip content=&quot;Refresh file list&quot;&gt;&#10;                        &lt;Button&#10;                            isIconOnly&#10;                            size=&quot;sm&quot;&#10;                            variant=&quot;light&quot;&#10;                            radius=&quot;none&quot;&#10;                            isLoading={isLoading}&#10;                            onPress={loadAvailableFiles}&#10;                        &gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:reload&quot;/&gt;&#10;                        &lt;/Button&gt;&#10;                    &lt;/Tooltip&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;Select&#10;                    label=&quot;Server JAR File&quot;&#10;                    radius=&quot;none&quot;&#10;                    disallowEmptySelection&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    selectedKeys={serverJar ? [serverJar] : []}&#10;                    onSelectionChange={(keys) =&gt;&#10;                    {&#10;                        const selected = Array.from(keys)[0] as string;&#10;                        setServerJar(selected || &quot;&quot;);&#10;                    }}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:file&quot;/&gt;}&#10;                    placeholder=&quot;Select a server file...&quot;&#10;                    isLoading={isLoading}&#10;                    classNames={{&#10;                        base: &quot;capitalize&quot;,&#10;                        popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;                    }}&#10;&#10;                    listboxProps={{&#10;                        itemClasses: {&#10;                            base: &quot;rounded-none font-minecraft-body&quot;&#10;                        }&#10;                    }}&#10;                &gt;&#10;                    {availableFiles.map((file) =&gt; (&#10;                        &lt;SelectItem key={file}&gt;&#10;                            {file}&#10;                        &lt;/SelectItem&gt;&#10;                    ))}&#10;                &lt;/Select&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Loader Configuration */}&#10;            &lt;section className=&quot;space-y-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Type &amp; Version&lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;mx-auto&quot;&gt;&#10;                    &lt;Tabs&#10;                        radius=&quot;none&quot;&#10;                        className=&quot;font-minecraft-body&quot;&#10;                        fullWidth&#10;                        variant=&quot;solid&quot;&#10;                        color=&quot;primary&quot;&#10;                        classNames={{&#10;                            tab: &quot;flex flex-col items-center justify-center h-24 w-28&quot;&#10;                        }}&#10;                        isDisabled={isSaving || isUploadingLoader}&#10;                        selectedKey={loaderType.toLowerCase()}&#10;                        onSelectionChange={async (key) =&gt;&#10;                        {&#10;                            const newLoader = key as LoaderType;&#10;                            setLoaderType(newLoader);&#10;                            if (newLoader === &quot;vanilla&quot;)&#10;                            {&#10;                                // Reset loader URL for vanilla&#10;                                setLoaderUrl(await getMinecraftVersionDownloadUrl(minecraftVersion));&#10;                                setLoaderVersion(&quot;&quot;);&#10;                            }&#10;                        }}&#10;                    &gt;&#10;                        &lt;Tab&#10;                            key=&quot;vanilla&quot;&#10;                            title={&#10;                                &lt;&gt;&#10;                                    &lt;Icon icon=&quot;heroicons:cube-transparent-16-solid&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Vanilla&lt;/p&gt;&#10;                                &lt;/&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;fabric&quot;&#10;                            title={&#10;                                &lt;div className=&quot;relative&quot;&gt;&#10;                                    &lt;Icon icon=&quot;file-icons:fabric&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Fabric&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;forge&quot;&#10;                            title={&#10;                                &lt;&gt;&#10;                                    &lt;Icon icon=&quot;simple-icons:curseforge&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Forge&lt;/p&gt;&#10;                                &lt;/&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;quilt&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;Quilt size={32}/&gt;&#10;                                    &lt;p&gt;Quilt&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;neoforge&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;NeoForge size={32}/&gt;&#10;                                    &lt;p&gt;NeoForge&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                        &lt;Tab&#10;                            key=&quot;custom&quot;&#10;                            title={&#10;                                &lt;div className=&quot;flex justify-center items-center flex-col gap-2&quot;&gt;&#10;                                    &lt;Icon icon=&quot;pixelarticons:cloud-upload&quot; width={32}/&gt;&#10;                                    &lt;p&gt;Custom&lt;/p&gt;&#10;                                &lt;/div&gt;&#10;                            }&#10;                        /&gt;&#10;                    &lt;/Tabs&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;MinecraftVersionSelector&#10;                    onVersionChange={(version, url) =&gt;&#10;                    {&#10;                        if (!version) return;&#10;                        setMinecraftVersion(version);&#10;                        // Store the vanilla server URL if this is for vanilla servers&#10;                        if (loaderType === &quot;vanilla&quot; &amp;&amp; url)&#10;                        {&#10;                            setLoaderUrl(url);&#10;                        }&#10;                    }}&#10;                    version={minecraftVersion}&#10;                    isDisabled={isSaving || isUploadingLoader}&#10;                /&gt;&#10;&#10;                &lt;LoaderSelector&#10;                    loaderVersion={loaderVersion}&#10;                    selectedLoader={loaderType}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isSnapshot={(minecraftVersion?.includes(&quot;snapshot&quot;) || minecraftVersion?.includes(&quot;pre-release&quot;)) ?? false}&#10;                    onChange={handleLoaderChange}&#10;                    onCustomJarChange={setCustomJarFile}&#10;                    isDisabled={isSaving || isUploadingLoader}&#10;                /&gt;&#10;&#10;                {hasLoaderChanges() &amp;&amp; (&#10;                    &lt;div className=&quot;bg-warning-50 border border-warning-200 rounded-lg p-4&quot;&gt;&#10;                        &lt;div className=&quot;flex items-center gap-2 text-warning-700&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:info-box&quot;/&gt;&#10;                            &lt;p className=&quot;font-minecraft-body text-sm&quot;&gt;&#10;                                Server type or version changes detected. A new server jar will be downloaded when you save.&#10;                                {loaderType !== &quot;custom&quot; &amp;&amp; loaderUrl &amp;&amp; (&#10;                                    &lt;span className=&quot;block mt-1 opacity-75&quot;&gt;&#10;                                        New jar: {generateNewJarFilename()}&#10;                                    &lt;/span&gt;&#10;                                )}&#10;                            &lt;/p&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Java Configuration */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Java Configuration&lt;/h3&gt;&#10;&#10;                &lt;JavaExecutableSelector&#10;                    defaultSelectedExecutable={javaExecutable}&#10;                    onVersionChange={(executable) =&gt;&#10;                    {&#10;                        if (executable) setJavaExecutable(executable);&#10;                    }}&#10;                    isDisabled={false}&#10;                /&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Additional Java Arguments&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;-XX:+UseG1GC -XX:+ParallelRefProcEnabled...&quot;&#10;                    value={javaArgs}&#10;                    onValueChange={setJavaArgs}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:terminal&quot;/&gt;}&#10;                    description=&quot;Additional JVM arguments (excluding -Xmx and -Xms)&quot;&#10;                /&gt;&#10;&#10;                &lt;RamSlider&#10;                    value={maxMemory}&#10;                    onValueChange={setMaxMemory}&#10;                    isDisabled={false}&#10;                /&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Minimum Memory (GB)&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    type=&quot;number&quot;&#10;                    min={1}&#10;                    max={maxMemory}&#10;                    value={minMemory.toString()}&#10;                    onValueChange={(value) =&gt; setMinMemory(Number(value) || 1)}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:memory&quot;/&gt;}&#10;                    description=&quot;Minimum RAM allocation for the JVM&quot;&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Arguments */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Arguments&lt;/h3&gt;&#10;&#10;                &lt;Input&#10;                    label=&quot;Minecraft Server Arguments&quot;&#10;                    radius=&quot;none&quot;&#10;                    className=&quot;font-minecraft-body&quot;&#10;                    placeholder=&quot;--nogui --port 25565...&quot;&#10;                    value={minecraftArgs}&#10;                    onValueChange={setMinecraftArgs}&#10;                    startContent={&lt;Icon icon=&quot;pixelarticons:command-line&quot;/&gt;}&#10;                    description=&quot;Additional arguments passed to the Minecraft server&quot;&#10;                /&gt;&#10;            &lt;/section&gt;&#10;&#10;            &lt;Divider/&gt;&#10;&#10;            {/* Server Features */}&#10;            &lt;section className=&quot;flex flex-col gap-4&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-minecraft-header&quot;&gt;Server Features&lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-4&quot;&gt;&#10;                    &lt;Switch&#10;                        isSelected={upnpEnabled}&#10;                        onValueChange={setUpnpEnabled}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:wifi&quot;/&gt;&#10;                            &lt;span&gt;Enable UPnP Port Forwarding&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;&#10;                    &lt;Switch&#10;                        isSelected={autoStart}&#10;                        onValueChange={setAutoStart}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:power&quot;/&gt;&#10;                            &lt;span&gt;Auto-start on Boot&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;&#10;                    &lt;Switch&#10;                        isSelected={autoRestart}&#10;                        onValueChange={setAutoRestart}&#10;                        classNames={{&#10;                            label: &quot;font-minecraft-body&quot;&#10;                        }}&#10;                    &gt;&#10;                        &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                            &lt;Icon icon=&quot;pixelarticons:reload&quot;/&gt;&#10;                            &lt;span&gt;Auto-restart on Crash&lt;/span&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/Switch&gt;&#10;                &lt;/div&gt;&#10;            &lt;/section&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;type LoaderSelectorProps = {&#10;    selectedLoader: string;&#10;    minecraftVersion: string | undefined;&#10;    loaderVersion: string | undefined;&#10;    onChange: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    onCustomJarChange: (file: File | undefined) =&gt; void;&#10;    isDisabled: boolean;&#10;    isSnapshot: boolean;&#10;}&#10;&#10;function LoaderSelector(props: LoaderSelectorProps)&#10;{&#10;    const {&#10;        selectedLoader,&#10;        minecraftVersion,&#10;        loaderVersion,&#10;        onChange,&#10;        isDisabled&#10;    } = props;&#10;&#10;    if (!minecraftVersion)&#10;    {&#10;        return (&#10;            &lt;p className=&quot;text-danger font-minecraft-body text-tiny italic underline&quot;&gt;&#10;                Please select a Minecraft version first.&#10;            &lt;/p&gt;&#10;        );&#10;    }&#10;&#10;    switch (selectedLoader.toLowerCase())&#10;    {&#10;        case &quot;fabric&quot;:&#10;            return (&#10;                &lt;FabricVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    onVersionChange={onChange}&#10;                    isDisabled={isDisabled}&#10;                    isSnapshot={props.isSnapshot}&#10;                /&gt;&#10;            );&#10;        case &quot;forge&quot;:&#10;            return (&#10;                &lt;ForgeVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    onVersionChange={onChange}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;quilt&quot;:&#10;            return (&#10;                &lt;QuiltVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;neoforge&quot;:&#10;            return (&#10;                &lt;NeoForgeVersionSelector&#10;                    version={loaderVersion}&#10;                    minecraftVersion={minecraftVersion}&#10;                    isDisabled={isDisabled}&#10;                /&gt;&#10;            );&#10;        case &quot;custom&quot;:&#10;            return (&#10;                &lt;FileInput&#10;                    accept=&quot;.jar,.zip,.tar.gz,.tar&quot;&#10;                    description=&quot;Upload your custom jar file or modpack archive.&quot;&#10;                    multiple={false}&#10;                    onChange={(file) =&gt; props.onCustomJarChange(file as File | undefined)}&#10;                    readOnly={isDisabled}&#10;                /&gt;&#10;            );&#10;        default:&#10;            return null;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/FabricVersionSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/FabricVersionSelector.tsx" />
              <option name="originalContent" value="import {addToast, Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useFabricVersions} from &quot;../../../providers/LoaderVersionProviders/FabricVersionsProvider.tsx&quot;;&#10;import {getFabricServerUrl} from &quot;../../../ts/fabric-versions.ts&quot;;&#10;&#10;type FabricVersionSelectorProps = {&#10;    version?: string;&#10;    minecraftVersion: string;&#10;    isSnapshot: boolean;&#10;    onVersionChange: (url: string | undefined, version: string | undefined) =&gt; void&#10;    isDisabled: boolean&#10;}&#10;&#10;export function FabricVersionSelector(props: FabricVersionSelectorProps)&#10;{&#10;    const {minecraftVersion, version} = props;&#10;    const {fabricVersions} = useFabricVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!fabricVersions) return;&#10;        if (+(minecraftVersion.split(&quot;.&quot;)[1]) &lt; 14)&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;            return;&#10;        } // Fabric versions are not available for Minecraft versions below 1.14&#10;        const versions = fabricVersions.loader.map(i =&gt; i.version);&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            setSelectedVersion(versions[0]);&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [props, fabricVersions, selectedVersion]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let installer: string | undefined = fabricVersions?.installer?.find(i =&gt; i.stable)?.version;&#10;        if (!installer)&#10;        {&#10;            addToast({&#10;                title: &quot;Error&quot;,&#10;                description: &quot;No stable Fabric installer version found.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            return;&#10;        }&#10;        if (!selectedVersion || !minecraftVersion) return;&#10;        const url = getFabricServerUrl(selectedVersion, minecraftVersion, installer);&#10;        props.onVersionChange(url, selectedVersion);&#10;        console.log(`Selected Fabric version: ${selectedVersion}, URL: ${url}`);&#10;    }, [selectedVersion, props]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!version) return;&#10;        setSelectedVersion(version);&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Fabric Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No Fabric versions available for Minecraft versions below 1.14`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {addToast, Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useFabricVersions} from &quot;../../../providers/LoaderVersionProviders/FabricVersionsProvider.tsx&quot;;&#10;import {getFabricServerUrl} from &quot;../../../ts/fabric-versions.ts&quot;;&#10;&#10;type FabricVersionSelectorProps = {&#10;    version?: string;&#10;    minecraftVersion: string;&#10;    isSnapshot: boolean;&#10;    onVersionChange: (url: string | undefined, version: string | undefined) =&gt; void&#10;    isDisabled: boolean&#10;}&#10;&#10;export function FabricVersionSelector(props: FabricVersionSelectorProps)&#10;{&#10;    const {minecraftVersion, version} = props;&#10;    const {fabricVersions} = useFabricVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    &#10;    useEffect(() =&gt;&#10;    {&#10;        if (!fabricVersions) return;&#10;        if (+(minecraftVersion.split(&quot;.&quot;)[1]) &lt; 14)&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;            return;&#10;        } // Fabric versions are not available for Minecraft versions below 1.14&#10;        const versions = fabricVersions.loader.map(i =&gt; i.version);&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            // Only set default version if no version is controlled from parent&#10;            if (!version &amp;&amp; !selectedVersion) {&#10;                setSelectedVersion(versions[0]);&#10;            }&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [fabricVersions, minecraftVersion]); // Removed props and selectedVersion from deps&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        let installer: string | undefined = fabricVersions?.installer?.find(i =&gt; i.stable)?.version;&#10;        if (!installer)&#10;        {&#10;            addToast({&#10;                title: &quot;Error&quot;,&#10;                description: &quot;No stable Fabric installer version found.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            return;&#10;        }&#10;        if (!selectedVersion || !minecraftVersion) return;&#10;        const url = getFabricServerUrl(selectedVersion, minecraftVersion, installer);&#10;        props.onVersionChange(url, selectedVersion);&#10;        console.log(`Selected Fabric version: ${selectedVersion}, URL: ${url}`);&#10;    }, [selectedVersion, minecraftVersion, fabricVersions, props]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (version !== undefined) {&#10;            setSelectedVersion(version);&#10;        }&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Fabric Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No Fabric versions available for Minecraft versions below 1.14`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/ForgeVersionSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/ForgeVersionSelector.tsx" />
              <option name="originalContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useForgeVersions} from &quot;../../../providers/LoaderVersionProviders/ForgeVersionsProvider.tsx&quot;;&#10;&#10;type ForgeVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    onVersionChange: (url: string | undefined, version: string | undefined) =&gt; void&#10;    isDisabled: boolean&#10;}&#10;&#10;export function ForgeVersionSelector(props: ForgeVersionSelectorProps)&#10;{&#10;    const {minecraftVersion} = props;&#10;    const {forgeVersions} = useForgeVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!forgeVersions) return;&#10;        const versions = forgeVersions[minecraftVersion] as string[];&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            setSelectedVersion(versions[0]);&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [props]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!selectedVersion || !minecraftVersion) return;&#10;        props.onVersionChange(getForgeInstallerUrl(minecraftVersion, selectedVersion), selectedVersion);&#10;    }, [selectedVersion, minecraftVersion]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Forge Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            isDisabled={props.isDisabled}&#10;            listboxProps={{&#10;                emptyContent: `No Forge versions available for ${minecraftVersion}`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}&#10;&#10;function getForgeInstallerUrl(minecraftVersion: string, forgeVersion: string): string | undefined&#10;{&#10;    return `https://maven.minecraftforge.net/net/minecraftforge/forge/${minecraftVersion}-${forgeVersion}/forge-${minecraftVersion}-${forgeVersion}-installer.jar`;&#10;}" />
              <option name="updatedContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useForgeVersions} from &quot;../../../providers/LoaderVersionProviders/ForgeVersionsProvider.tsx&quot;;&#10;&#10;type ForgeVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    version?: string;&#10;    onVersionChange: (url: string | undefined, version: string | undefined) =&gt; void&#10;    isDisabled: boolean&#10;}&#10;&#10;export function ForgeVersionSelector(props: ForgeVersionSelectorProps)&#10;{&#10;    const {minecraftVersion, version} = props;&#10;    const {forgeVersions} = useForgeVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!forgeVersions) return;&#10;        const versions = forgeVersions[minecraftVersion] as string[];&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            // Only set default version if no version is controlled from parent&#10;            if (!version &amp;&amp; !selectedVersion) {&#10;                setSelectedVersion(versions[0]);&#10;            }&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [forgeVersions, minecraftVersion]); // Removed props from deps&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!selectedVersion || !minecraftVersion) return;&#10;        props.onVersionChange(getForgeInstallerUrl(minecraftVersion, selectedVersion), selectedVersion);&#10;    }, [selectedVersion, minecraftVersion, props]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (version !== undefined) {&#10;            setSelectedVersion(version);&#10;        }&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Forge Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            isDisabled={props.isDisabled}&#10;            listboxProps={{&#10;                emptyContent: `No Forge versions available for ${minecraftVersion}`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}&#10;&#10;function getForgeInstallerUrl(minecraftVersion: string, forgeVersion: string): string | undefined&#10;{&#10;    return `https://maven.minecraftforge.net/net/minecraftforge/forge/${minecraftVersion}-${forgeVersion}/forge-${minecraftVersion}-${forgeVersion}-installer.jar`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/MinecraftVersionSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/MinecraftVersionSelector.tsx" />
              <option name="originalContent" value="import {Autocomplete, AutocompleteItem, Button} from &quot;@heroui/react&quot;;&#10;import {Tooltip} from &quot;../../extended/Tooltip.tsx&quot;;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useMinecraftVersions} from &quot;../../../providers/LoaderVersionProviders/MinecraftVersionsProvider.tsx&quot;;&#10;&#10;type MinecraftVersionSelectorProps = {&#10;    onVersionChange?: (version: string | undefined, url: string | undefined) =&gt; void;&#10;    version?: string | undefined;&#10;    isDisabled?: boolean;&#10;}&#10;&#10;export function MinecraftVersionSelector(props: MinecraftVersionSelectorProps)&#10;{&#10;    const {onVersionChange, version, isDisabled} = props;&#10;    const {minecraftVersions} = useMinecraftVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    const [showSnapshots, setShowSnapshots] = useState(false);&#10;    const [showOlderVersions, setShowOlderVersions] = useState(false);&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!minecraftVersions) return;&#10;&#10;        setVersions(minecraftVersions.versions.filter(i =&gt; i.type === &quot;release&quot; || (showSnapshots &amp;&amp; i.type === &quot;snapshot&quot;) || (showOlderVersions &amp;&amp; (i.type === &quot;old_beta&quot; || i.type === &quot;old_alpha&quot;))).map(version =&gt; version.id));&#10;        setSelectedVersion(showSnapshots ? minecraftVersions.latest.snapshot : minecraftVersions.latest.release);&#10;    }, [showSnapshots, showOlderVersions, minecraftVersions]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (onVersionChange)&#10;        {&#10;            const url = minecraftVersions?.versions.find(i =&gt; i.id === selectedVersion)?.url;&#10;            onVersionChange(selectedVersion, url);&#10;        }&#10;    }, [selectedVersion, showOlderVersions, showSnapshots, minecraftVersions]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        setSelectedVersion(version);&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;div className={&quot;flex flex-row gap-2 items-center&quot;}&gt;&#10;            &lt;Autocomplete&#10;                label={`Minecraft Version`}&#10;                radius={&quot;none&quot;}&#10;                className={&quot;font-minecraft-body&quot;}&#10;                classNames={{&#10;                    base: &quot;capitalize&quot;,&#10;                    popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;                }}&#10;                size={&quot;sm&quot;}&#10;                selectedKey={selectedVersion}&#10;                onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;                showScrollIndicators&#10;                isDisabled={isDisabled}&#10;                listboxProps={{&#10;                    itemClasses: {&#10;                        base: &quot;rounded-none font-minecraft-body&quot;&#10;                    }&#10;                }}&#10;            &gt;&#10;                {versions.map((version) =&gt; (&#10;                    &lt;AutocompleteItem&#10;                        key={version}&#10;                        className={&quot;font-minecraft-body&quot;}&#10;                        textValue={version}&#10;                    &gt;&#10;                        {version}&#10;                    &lt;/AutocompleteItem&gt;&#10;                ))}&#10;            &lt;/Autocomplete&gt;&#10;            &lt;Tooltip content={&quot;Show snapshots&quot;}&gt;&#10;                &lt;Button isIconOnly radius={&quot;none&quot;} size={&quot;lg&quot;} color={showSnapshots ? &quot;primary&quot; : &quot;default&quot;} onPress={() =&gt; setShowSnapshots(prev =&gt; !prev)} isDisabled={props.isDisabled}&gt;&#10;                    &lt;Icon icon={&quot;pixelarticons:bug&quot;}/&gt;&#10;                &lt;/Button&gt;&#10;            &lt;/Tooltip&gt;&#10;            &lt;Tooltip content={&quot;Show Older Versions&quot;}&gt;&#10;                &lt;Button isIconOnly radius={&quot;none&quot;} size={&quot;lg&quot;} color={showOlderVersions ? &quot;primary&quot; : &quot;default&quot;} onPress={() =&gt; setShowOlderVersions(prev =&gt; !prev)} isDisabled={props.isDisabled}&gt;&#10;                    &lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;&#10;                &lt;/Button&gt;&#10;            &lt;/Tooltip&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Autocomplete, AutocompleteItem, Button} from &quot;@heroui/react&quot;;&#13;&#10;import {Tooltip} from &quot;../../extended/Tooltip.tsx&quot;;&#13;&#10;import {Icon} from &quot;@iconify-icon/react&quot;;&#13;&#10;import {useEffect, useState} from &quot;react&quot;;&#13;&#10;import {useMinecraftVersions} from &quot;../../../providers/LoaderVersionProviders/MinecraftVersionsProvider.tsx&quot;;&#13;&#10;&#13;&#10;type MinecraftVersionSelectorProps = {&#13;&#10;    onVersionChange?: (version: string | undefined, url: string | undefined) =&gt; void;&#13;&#10;    version?: string | undefined;&#13;&#10;    isDisabled?: boolean;&#13;&#10;}&#13;&#10;&#13;&#10;export function MinecraftVersionSelector(props: MinecraftVersionSelectorProps)&#13;&#10;{&#13;&#10;    const {onVersionChange, version, isDisabled} = props;&#13;&#10;    const {minecraftVersions} = useMinecraftVersions();&#13;&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#13;&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#13;&#10;    const [showSnapshots, setShowSnapshots] = useState(false);&#13;&#10;    const [showOlderVersions, setShowOlderVersions] = useState(false);&#13;&#10;    useEffect(() =&gt;&#13;&#10;    {&#13;&#10;        if (!minecraftVersions) return;&#13;&#10;&#13;&#10;        setVersions(minecraftVersions.versions.filter(i =&gt; i.type === &quot;release&quot; || (showSnapshots &amp;&amp; i.type === &quot;snapshot&quot;) || (showOlderVersions &amp;&amp; (i.type === &quot;old_beta&quot; || i.type === &quot;old_alpha&quot;))).map(version =&gt; version.id));&#13;&#10;        &#13;&#10;        // Only set default version if no version is controlled from parent&#13;&#10;        if (!version &amp;&amp; !selectedVersion) {&#13;&#10;            setSelectedVersion(showSnapshots ? minecraftVersions.latest.snapshot : minecraftVersions.latest.release);&#13;&#10;        }&#13;&#10;    }, [showSnapshots, showOlderVersions, minecraftVersions]); // Removed version and selectedVersion from deps&#13;&#10;&#13;&#10;    useEffect(() =&gt;&#13;&#10;    {&#13;&#10;        if (onVersionChange)&#13;&#10;        {&#13;&#10;            const url = minecraftVersions?.versions.find(i =&gt; i.id === selectedVersion)?.url;&#13;&#10;            onVersionChange(selectedVersion, url);&#13;&#10;        }&#13;&#10;    }, [selectedVersion, minecraftVersions, onVersionChange]); // Removed showOlderVersions and showSnapshots from deps&#13;&#10;&#13;&#10;    useEffect(() =&gt;&#13;&#10;    {&#13;&#10;        if (version !== undefined) {&#13;&#10;            setSelectedVersion(version);&#13;&#10;        }&#13;&#10;    }, [version]);&#13;&#10;&#13;&#10;    return (&#13;&#10;        &lt;div className={&quot;flex flex-row gap-2 items-center&quot;}&gt;&#13;&#10;            &lt;Autocomplete&#13;&#10;                label={`Minecraft Version`}&#13;&#10;                radius={&quot;none&quot;}&#13;&#10;                className={&quot;font-minecraft-body&quot;}&#13;&#10;                classNames={{&#13;&#10;                    base: &quot;capitalize&quot;,&#13;&#10;                    popoverContent: &quot;rounded-none border-primary border-1&quot;&#13;&#10;                }}&#13;&#10;                size={&quot;sm&quot;}&#13;&#10;                selectedKey={selectedVersion}&#13;&#10;                onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#13;&#10;                showScrollIndicators&#13;&#10;                isDisabled={isDisabled}&#13;&#10;                listboxProps={{&#13;&#10;                    itemClasses: {&#13;&#10;                        base: &quot;rounded-none font-minecraft-body&quot;&#13;&#10;                    }&#13;&#10;                }}&#13;&#10;            &gt;&#13;&#10;                {versions.map((version) =&gt; (&#13;&#10;                    &lt;AutocompleteItem&#13;&#10;                        key={version}&#13;&#10;                        className={&quot;font-minecraft-body&quot;}&#13;&#10;                        textValue={version}&#13;&#10;                    &gt;&#13;&#10;                        {version}&#13;&#10;                    &lt;/AutocompleteItem&gt;&#13;&#10;                ))}&#13;&#10;            &lt;/Autocomplete&gt;&#13;&#10;            &lt;Tooltip content={&quot;Show snapshots&quot;}&gt;&#13;&#10;                &lt;Button isIconOnly radius={&quot;none&quot;} size={&quot;lg&quot;} color={showSnapshots ? &quot;primary&quot; : &quot;default&quot;} onPress={() =&gt; setShowSnapshots(prev =&gt; !prev)} isDisabled={props.isDisabled}&gt;&#13;&#10;                    &lt;Icon icon={&quot;pixelarticons:bug&quot;}/&gt;&#13;&#10;                &lt;/Button&gt;&#13;&#10;            &lt;/Tooltip&gt;&#13;&#10;            &lt;Tooltip content={&quot;Show Older Versions&quot;}&gt;&#13;&#10;                &lt;Button isIconOnly radius={&quot;none&quot;} size={&quot;lg&quot;} color={showOlderVersions ? &quot;primary&quot; : &quot;default&quot;} onPress={() =&gt; setShowOlderVersions(prev =&gt; !prev)} isDisabled={props.isDisabled}&gt;&#13;&#10;                    &lt;Icon icon={&quot;pixelarticons:archive&quot;}/&gt;&#13;&#10;                &lt;/Button&gt;&#13;&#10;            &lt;/Tooltip&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;    );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/NeoForgeVersionSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/NeoForgeVersionSelector.tsx" />
              <option name="originalContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useNeoForgeVersions} from &quot;../../../providers/LoaderVersionProviders/NeoForgeVersionsProvider.tsx&quot;;&#10;&#10;type ForgeVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    isDisabled: boolean&#10;}&#10;&#10;export function NeoForgeVersionSelector(props: ForgeVersionSelectorProps)&#10;{&#10;    const {minecraftVersion} = props;&#10;    const {getFromMinecraftVersion} = useNeoForgeVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    useEffect(() =&gt;&#10;    {&#10;        const versions = getFromMinecraftVersion(minecraftVersion) as string[];&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            setSelectedVersion(versions[0]);&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [props]);&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`NeoForge Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No NeoForge versions available for ${minecraftVersion}`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useNeoForgeVersions} from &quot;../../../providers/LoaderVersionProviders/NeoForgeVersionsProvider.tsx&quot;;&#10;&#10;type NeoForgeVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    version?: string;&#10;    onVersionChange?: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    isDisabled: boolean&#10;}&#10;&#10;export function NeoForgeVersionSelector(props: NeoForgeVersionSelectorProps)&#10;{&#10;    const {minecraftVersion, version, onVersionChange} = props;&#10;    const {getFromMinecraftVersion} = useNeoForgeVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    &#10;    useEffect(() =&gt;&#10;    {&#10;        const versions = getFromMinecraftVersion(minecraftVersion) as string[];&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            // Only set default version if no version is controlled from parent&#10;            if (!version &amp;&amp; !selectedVersion) {&#10;                setSelectedVersion(versions[0]);&#10;            }&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [getFromMinecraftVersion, minecraftVersion]); // Removed props from deps&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (onVersionChange &amp;&amp; selectedVersion &amp;&amp; minecraftVersion)&#10;        {&#10;            // NeoForge installer URL structure&#10;            const url = `https://maven.neoforged.net/releases/net/neoforged/neoforge/${selectedVersion}/neoforge-${selectedVersion}-installer.jar`;&#10;            onVersionChange(url, selectedVersion);&#10;        }&#10;    }, [selectedVersion, onVersionChange, minecraftVersion]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (version !== undefined) {&#10;            setSelectedVersion(version);&#10;        }&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`NeoForge Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No NeoForge versions available for ${minecraftVersion}`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/QuiltVersionSelector.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/components/server-components/version-selectors/QuiltVersionSelector.tsx" />
              <option name="originalContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useQuiltVersions} from &quot;../../../providers/LoaderVersionProviders/QuiltVersionsProvider.tsx&quot;;&#10;&#10;type QuiltVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    isDisabled: boolean&#10;}&#10;&#10;export function QuiltVersionSelector(props: QuiltVersionSelectorProps)&#10;{&#10;    const {minecraftVersion} = props;&#10;    const {quiltVersions} = useQuiltVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(undefined);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!quiltVersions) return;&#10;        if (+(minecraftVersion.split(&quot;.&quot;)[1]) &lt; 14)&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;            return;&#10;        } // Quilt versions are not available for Minecraft versions below 1.14&#10;        const versions = quiltVersions.loader.map(i =&gt; i.version);&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            setSelectedVersion(versions[0]);&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [props]);&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Quilt Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No Quilt versions available for Minecraft versions below 1.14`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
              <option name="updatedContent" value="import {Autocomplete, AutocompleteItem} from &quot;@heroui/react&quot;;&#10;import {useEffect, useState} from &quot;react&quot;;&#10;import {useQuiltVersions} from &quot;../../../providers/LoaderVersionProviders/QuiltVersionsProvider.tsx&quot;;&#10;&#10;type QuiltVersionSelectorProps = {&#10;    minecraftVersion: string;&#10;    version?: string;&#10;    onVersionChange?: (url: string | undefined, version: string | undefined) =&gt; void;&#10;    isDisabled: boolean&#10;}&#10;&#10;export function QuiltVersionSelector(props: QuiltVersionSelectorProps)&#10;{&#10;    const {minecraftVersion, version, onVersionChange} = props;&#10;    const {quiltVersions} = useQuiltVersions();&#10;    const [selectedVersion, setSelectedVersion] = useState&lt;string | undefined&gt;(version);&#10;    const [versions, setVersions] = useState&lt;string[]&gt;([]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (!quiltVersions) return;&#10;        if (+(minecraftVersion.split(&quot;.&quot;)[1]) &lt; 14)&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;            return;&#10;        } // Quilt versions are not available for Minecraft versions below 1.14&#10;        const versions = quiltVersions.loader.map(i =&gt; i.version);&#10;        if (versions &amp;&amp; versions.length &gt; 0)&#10;        {&#10;            setVersions(versions);&#10;            // Only set default version if no version is controlled from parent&#10;            if (!version &amp;&amp; !selectedVersion) {&#10;                setSelectedVersion(versions[0]);&#10;            }&#10;        } else&#10;        {&#10;            setVersions([]);&#10;            setSelectedVersion(undefined);&#10;        }&#10;    }, [quiltVersions, minecraftVersion]); // Removed props from deps&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (onVersionChange &amp;&amp; selectedVersion &amp;&amp; minecraftVersion)&#10;        {&#10;            // Quilt uses similar URL structure to Fabric&#10;            const url = `https://maven.quiltmc.org/repository/release/org/quiltmc/quilt-loader/${selectedVersion}/quilt-loader-${selectedVersion}-installer.jar`;&#10;            onVersionChange(url, selectedVersion);&#10;        }&#10;    }, [selectedVersion, onVersionChange, minecraftVersion]);&#10;&#10;    useEffect(() =&gt;&#10;    {&#10;        if (version !== undefined) {&#10;            setSelectedVersion(version);&#10;        }&#10;    }, [version]);&#10;&#10;    return (&#10;        &lt;Autocomplete&#10;            label={`Quilt Version`}&#10;            radius={&quot;none&quot;}&#10;            className={&quot;font-minecraft-body&quot;}&#10;            classNames={{&#10;                base: &quot;capitalize&quot;,&#10;                popoverContent: &quot;rounded-none border-primary border-1&quot;&#10;            }}&#10;            size={&quot;sm&quot;}&#10;            selectedKey={selectedVersion}&#10;            onSelectionChange={value =&gt; setSelectedVersion(value as string)}&#10;            showScrollIndicators&#10;            listboxProps={{&#10;                emptyContent: `No Quilt versions available for Minecraft versions below 1.14`,&#10;                itemClasses: {&#10;                    base: &quot;rounded-none font-minecraft-body&quot;&#10;                }&#10;            }}&#10;            isDisabled={props.isDisabled}&#10;        &gt;&#10;            {versions.map((version) =&gt; (&#10;                &lt;AutocompleteItem&#10;                    key={version}&#10;                    className={&quot;font-minecraft-body&quot;}&#10;                    textValue={version}&#10;                &gt;&#10;                    {version}&#10;                &lt;/AutocompleteItem&gt;&#10;            ))}&#10;        &lt;/Autocomplete&gt;&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/ts/filesystem.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/ts/filesystem.ts" />
              <option name="originalContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress?: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        if (updateProgress) updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    static extract(archivePath: string, outputPath: string, serverId: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `extract-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/extract/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;&#10;        // Trim leading slashes from paths&#10;        archivePath = archivePath.startsWith(&quot;/&quot;) ? archivePath.substring(1) : archivePath;&#10;        outputPath = outputPath.startsWith(&quot;/&quot;) ? outputPath.substring(1) : outputPath;&#10;&#10;        // Function to cancel the extract operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel extract:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling extract:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0, 0, 0);&#10;            try&#10;            {&#10;                const url = new URL(`/api/server/${serverId}/fs/extract`, window.location.origin);&#10;                url.searchParams.set(&quot;archive&quot;, archivePath);&#10;                url.searchParams.set(&quot;directory&quot;, outputPath);&#10;                url.searchParams.set(&quot;tracker&quot;, id);&#10;&#10;                const response = await fetch(url.toString(), {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to extract the archive.&quot;}`);&#10;            }&#10;        });&#10;&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            // Check if the operation completed successfully&#10;            if (data.status === &quot;complete&quot;)&#10;            {&#10;                on_success();&#10;                return;&#10;            }&#10;&#10;            // Check if there was an error&#10;            if (data.status === &quot;error&quot;)&#10;            {&#10;                on_error(data.error || &quot;Unknown error occurred during extraction&quot;);&#10;                return;&#10;            }&#10;&#10;            // Update progress&#10;            on_progress(data.progress || 0, data.filesProcessed || 0, data.totalFiles || 0);&#10;        };&#10;&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelExtract(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel extract operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    resolve(); // Resolve immediately when connection opens&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    onSuccess();&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import {extensionFileTypeMap, getFileType} from &quot;./file-type-match.ts&quot;;&#10;import {addToast} from &quot;@heroui/react&quot;;&#10;&#10;/**&#10; * Represents a filesystem entry (file or directory)&#10; */&#10;export interface FilesystemEntry&#10;{&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    last_modified?: Date;&#10;    creation_date?: Date;&#10;    is_dir: boolean;&#10;    file_type?: string;&#10;}&#10;&#10;type FilesystemSearchResult = {&#10;    filename: string;&#10;    path: string;&#10;    size: number;&#10;    ctime: number;&#10;    mtime: number;&#10;}&#10;&#10;/**&#10; * Represents a directory listing with entries and parent path&#10; */&#10;export interface FilesystemData&#10;{&#10;    parent: string | null;&#10;    entries: FilesystemEntry[];&#10;}&#10;&#10;/**&#10; * FileSystem class for handling filesystem operations&#10; * Provides methods to browse directories and download files&#10; */&#10;export class FileSystem&#10;{&#10;&#10;    /**&#10;     * Get filesystem entries for the specified path&#10;     * @param path Directory path to browse&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem data&#10;     */&#10;    static async getEntries(path: string, serverId: string): Promise&lt;FilesystemData&gt;&#10;    {&#10;        try&#10;        {&#10;            const url = new URL(`/api/server/${serverId}/fs/files`, window.location.origin);&#10;            url.searchParams.set(&quot;path&quot;, decodeURIComponent(path));&#10;            const response = await fetch(url.toString());&#10;&#10;            if (!response.ok)&#10;            {&#10;                let body = await response.text();&#10;                if (body)&#10;                {&#10;                    throw new Error(body);&#10;                } else&#10;                {&#10;                    throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;                }&#10;            }&#10;&#10;            let tmp = await response.json() as FilesystemData;&#10;&#10;            tmp.entries = tmp.entries.map(entry =&gt;&#10;            {&#10;                if ((entry as any).created)&#10;                {&#10;                    const createdSecs = ((entry as any).created.secs_since_epoch || 0) * 1000;&#10;                    const createdNanos = ((entry as any).created.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.creation_date = new Date(createdSecs + createdNanos);&#10;                }&#10;&#10;                if ((entry as any).last_modified)&#10;                {&#10;                    const modifiedSecs = ((entry as any).last_modified.secs_since_epoch || 0) * 1000;&#10;                    const modifiedNanos = ((entry as any).last_modified.nanos_since_epoch || 0) / 1_000_000;&#10;                    entry.last_modified = new Date(modifiedSecs + modifiedNanos);&#10;                }&#10;&#10;                if (entry.is_dir)&#10;                {&#10;                    entry.file_type = &quot;Folder&quot;;&#10;                } else&#10;                {&#10;                    entry.file_type = getFileType(entry.filename)?.description ?? &quot;File&quot;;&#10;                }&#10;&#10;                if (entry.path.startsWith(&quot;\\&quot;))&#10;                {&#10;                    // alert(&quot;Detected Windows path format. This may cause issues in some browsers. Please use forward slashes (/) for paths.&quot;);&#10;                    entry.path = entry.path.substring(1); // Remove leading \\ for Windows paths}&#10;                }&#10;                return entry;&#10;            });&#10;            console.log(&quot;Loading files&quot;, tmp);&#10;            return tmp;&#10;        } catch (error: Error | any)&#10;        {&#10;            addToast({&#10;                title: &quot;Failed to get Directory&quot;,&#10;                description: error.message || error.toString() || &quot;Unknown error occurred while trying to get the directory.&quot;,&#10;                color: &quot;danger&quot;&#10;            });&#10;            console.error(&quot;Error fetching filesystem data:&quot;, error);&#10;            throw error;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download a file or directory&#10;     * @param entry Filesystem entry to download&#10;     * @param serverId Server ID to target&#10;     * @returns Promise that resolves when download is initiated&#10;     */&#10;    static async download(entry: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const cwd = window.location.pathname.replace(&quot;/files/&quot;, &quot;&quot;);&#10;        const url = new URL(`/api/server/${serverId}/fs/download`, window.location.origin);&#10;&#10;        const items = entry instanceof Array ? entry : [entry];&#10;        url.searchParams.set(&quot;items&quot;, JSON.stringify(items.map(e =&gt; e.replace(cwd, &quot;&quot;))));&#10;&#10;        const anchor = document.createElement(&quot;a&quot;);&#10;        // anchor.target = &quot;_blank&quot;;&#10;        anchor.href = url.href;&#10;        anchor.click();&#10;    }&#10;&#10;&#10;    static async copyEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/copy`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to copy: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async moveEntry(sourcePaths: string[], destinationPath: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/move`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({entries: sourcePaths, path: destinationPath}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async renameEntry(source: string, destination: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        if (destination.startsWith(&quot;/&quot;))&#10;            destination = destination.substring(1);&#10;        if (source.startsWith(&quot;/&quot;))&#10;            source = source.substring(1);&#10;&#10;        const response = await fetch(`/api/server/${serverId}/fs/rename`, {&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({source, destination}),&#10;            headers: {&quot;Content-Type&quot;: &quot;application/json&quot;}&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to move: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async deleteEntry(path: string | string[], serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/`, {&#10;            method: &quot;DELETE&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            body: JSON.stringify({paths: path instanceof Array ? path : [path]})&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to delete: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size into human-readable format&#10;     * @param bytes Size in bytes&#10;     * @returns Formatted size string (e.g., &quot;2.5 MB&quot;)&#10;     */&#10;    public static formatSize(bytes: number): string&#10;    {&#10;        if (bytes === 0) return &quot;0 Bytes&quot;;&#10;&#10;        const k = 1024;&#10;        const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;];&#10;        const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;&#10;        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &quot; &quot; + sizes[i];&#10;    }&#10;&#10;    /**&#10;     * Check if a path exists&#10;     * @param path Path to check&#10;     * @param serverId Server ID to target&#10;     * @returns Promise indicating if the path exists&#10;     */&#10;    public static async pathExists(path: string, serverId: string): Promise&lt;boolean&gt;&#10;    {&#10;        try&#10;        {&#10;            await FileSystem.getEntries(path, serverId);&#10;            return true;&#10;        } catch (error)&#10;        {&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file or directory information&#10;     * @param path Path to the file or directory&#10;     * @param serverId Server ID to target&#10;     * @returns Promise with the filesystem entry&#10;     */&#10;    public static async getInfo(path: string, serverId: string): Promise&lt;FilesystemEntry | null&gt;&#10;    {&#10;        try&#10;        {&#10;            const dirname = FileSystem.getDirectoryName(path);&#10;            const filename = FileSystem.getFileName(path);&#10;&#10;            const data = await FileSystem.getEntries(dirname, serverId);&#10;            return data.entries.find(entry =&gt; entry.filename === filename) || null;&#10;        } catch (error)&#10;        {&#10;            console.error(&quot;Error getting file info:&quot;, error);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the directory name from a path&#10;     * @param path Full path&#10;     * @returns Directory path&#10;     */&#10;    private static getDirectoryName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        if (lastSlashIndex &lt;= 0) return &quot;/&quot;;&#10;        return path.substring(0, lastSlashIndex);&#10;    }&#10;&#10;    /**&#10;     * Get the file name from a path&#10;     * @param path Full path&#10;     * @returns File name&#10;     */&#10;    private static getFileName(path: string): string&#10;    {&#10;        const lastSlashIndex = path.lastIndexOf(&quot;/&quot;);&#10;        return path.substring(lastSlashIndex + 1);&#10;    }&#10;&#10;    public static async upload(file: File, path: string, serverId: string, updateProgress?: (bytes: number) =&gt; void, onCancelled?: () =&gt; void): Promise&lt;{ promise: Promise&lt;void&gt;, cancel: () =&gt; Promise&lt;void&gt;, uploadId: string }&gt;&#10;    {&#10;        // Generate unique upload ID&#10;        const uploadId = Math.random().toString(36);&#10;&#10;        // Function to cancel the upload&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/upload/cancel/${uploadId}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel upload:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling upload:&quot;, e);&#10;            }&#10;        };&#10;&#10;        const promise = new Promise&lt;void&gt;((resolve, reject) =&gt;&#10;        {&#10;            // Set up the SSE listener for progress&#10;            const events = new EventSource(`/api/server/${serverId}/fs/upload/progress/${uploadId}`);&#10;&#10;            events.onmessage = (event) =&gt;&#10;            {&#10;                const data = JSON.parse(event.data);&#10;                switch (data.status)&#10;                {&#10;                    case &quot;progress&quot;:&#10;                        console.log(`Upload progress: ${data.bytesUploaded} bytes`);&#10;                        if (updateProgress) updateProgress(data.bytesUploaded);&#10;                        break;&#10;                    case &quot;complete&quot;:&#10;                        console.log(`Upload complete: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        resolve();&#10;                        break;&#10;                    case &quot;cancelled&quot;:&#10;                        console.log(`Upload cancelled: ${data.bytesUploaded} bytes`);&#10;                        events.close();&#10;                        if (onCancelled)&#10;                        {&#10;                            onCancelled();&#10;                        }&#10;                        resolve(); // Resolve instead of reject to avoid error handling&#10;                        break;&#10;                    case &quot;error&quot;:&#10;                        events.close();&#10;                        reject(new Error(data.message));&#10;                        break;&#10;                }&#10;            };&#10;&#10;            events.onerror = () =&gt;&#10;            {&#10;                events.close();&#10;                reject(new Error(&quot;EventSource connection failed&quot;));&#10;            };&#10;&#10;            events.onopen = () =&gt;&#10;            {&#10;                // Start the upload once connected&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;path&quot;, `${path}/${file.name}`);&#10;                uploadUrl.searchParams.set(&quot;upload_id&quot;, uploadId);&#10;&#10;                fetch(uploadUrl.toString(), {&#10;                    method: &quot;POST&quot;,&#10;                    body: file&#10;                }).then(response =&gt;&#10;                {&#10;                    if (!response.ok)&#10;                    {&#10;                        events.close();&#10;                        reject(new Error(`Upload failed: ${response.status} - ${response.statusText}`));&#10;                    }&#10;                }).catch(error =&gt;&#10;                {&#10;                    events.close();&#10;                    reject(error);&#10;                });&#10;            };&#10;        });&#10;&#10;        return {promise, cancel, uploadId};&#10;    }&#10;&#10;    static async createEntry(filename: string, cwd: string, isDirectory: boolean, serverId: string)&#10;    {&#10;        let path = `${cwd}/${filename}`;&#10;        if (path.startsWith(&quot;/&quot;))&#10;            path = path.substring(1); // Remove leading slash for consistency&#10;        const response = await fetch(`/api/server/${serverId}/fs/new`, {&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;application/json&quot;&#10;            },&#10;            method: &quot;POST&quot;,&#10;            body: JSON.stringify({path, is_directory: isDirectory})&#10;        });&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to create: ${response.statusText}`);&#10;        }&#10;    }&#10;&#10;    static async search(query: string, filename_only: boolean, serverId: string, abortSignal: AbortSignal): Promise&lt;FilesystemEntry[]&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/search?q=${encodeURIComponent(query)}&amp;filename_only=${filename_only}`, {signal: abortSignal});&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.error || `Failed to search: ${response.statusText}`);&#10;        }&#10;        const results = await response.json() as FilesystemSearchResult[];&#10;        return results.map(result =&gt;&#10;        {&#10;            let entry: FilesystemEntry = {&#10;                filename: result.filename,&#10;                path: result.path,&#10;                size: result.size,&#10;                last_modified: new Date(result.mtime * 1000),&#10;                creation_date: new Date(result.ctime * 1000),&#10;                is_dir: false&#10;            };&#10;&#10;            if (entry.is_dir)&#10;            {&#10;                entry.file_type = &quot;Folder&quot;;&#10;            } else&#10;            {&#10;                const extensions = entry.filename.toLowerCase().trim().split(&quot;.&quot;).slice(1);&#10;                let extension = extensions.length &gt; 0 ? extensions.join(&quot;.&quot;) : &quot;&quot;;&#10;                entry.file_type = extensionFileTypeMap.find(e =&gt; e.extensions.includes(extension))?.description ?? &quot;File&quot;;&#10;            }&#10;&#10;            return entry;&#10;        });&#10;    }&#10;&#10;    static archive(filename: string, filenames: string[], cwd: string, serverId: string, on_progress: (progress: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `${filename}-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/archive/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;        filenames = filenames.map(f =&gt; f.startsWith(&quot;/&quot;) ? f.substring(1) : f);&#10;        // Function to cancel the archive operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel archive:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling archive:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0);&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/archive`, {&#10;                    method: &quot;POST&quot;,&#10;                    headers: {&#10;                        &quot;Content-Type&quot;: &quot;application/json&quot;&#10;                    },&#10;                    body: JSON.stringify({entries: filenames, cwd, filename, tracker_id: id})&#10;                });&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                } else&#10;                {&#10;                    on_success();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to archive the files.&quot;}`);&#10;            }&#10;            event.close();&#10;        });&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            on_progress(data.progress);&#10;        };&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelArchive(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/archive/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel archive operation&quot;);&#10;        }&#10;    }&#10;&#10;    static extract(archivePath: string, outputPath: string, serverId: string, on_progress: (progress: number, filesProcessed: number, totalFiles: number) =&gt; void, on_success: () =&gt; void, on_error: (msg: string) =&gt; void, on_cancelled?: () =&gt; void): { cancel: () =&gt; Promise&lt;void&gt;, trackerId: string }&#10;    {&#10;        const id = `extract-${Math.random().toString(36)}`;&#10;        const event = new EventSource(`/api/server/${serverId}/fs/extract/status/${id}`);&#10;        if (event == null) throw new Error(&quot;Failed to create SSE connection&quot;);&#10;&#10;        // Trim leading slashes from paths&#10;        archivePath = archivePath.startsWith(&quot;/&quot;) ? archivePath.substring(1) : archivePath;&#10;        outputPath = outputPath.startsWith(&quot;/&quot;) ? outputPath.substring(1) : outputPath;&#10;&#10;        // Function to cancel the extract operation&#10;        const cancel = async () =&gt;&#10;        {&#10;            try&#10;            {&#10;                const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${id}`, {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    const errorData = await response.json();&#10;                    console.error(&quot;Failed to cancel extract:&quot;, errorData.message || &quot;Unknown error&quot;);&#10;                }&#10;&#10;                // Close the event source&#10;                event.close();&#10;&#10;                // Call the cancelled callback if provided&#10;                if (on_cancelled)&#10;                {&#10;                    on_cancelled();&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                console.error(&quot;Error cancelling extract:&quot;, e);&#10;            }&#10;        };&#10;&#10;        event.onopen = (async () =&gt;&#10;        {&#10;            on_progress(0, 0, 0);&#10;            try&#10;            {&#10;                const url = new URL(`/api/server/${serverId}/fs/extract`, window.location.origin);&#10;                url.searchParams.set(&quot;archive&quot;, archivePath);&#10;                url.searchParams.set(&quot;directory&quot;, outputPath);&#10;                url.searchParams.set(&quot;tracker&quot;, id);&#10;&#10;                const response = await fetch(url.toString(), {&#10;                    method: &quot;POST&quot;&#10;                });&#10;&#10;                if (!response.ok)&#10;                {&#10;                    let body = await response.text();&#10;                    try&#10;                    {&#10;                        const json = JSON.parse(body);&#10;                        on_error(json.error || json.message || body);&#10;                    } catch&#10;                    {&#10;                        on_error(body);&#10;                    }&#10;                }&#10;            } catch (e: Error | any)&#10;            {&#10;                on_error(`Error: ${e.message || e.toString() || &quot;Unknown error occurred while trying to extract the archive.&quot;}`);&#10;            }&#10;        });&#10;&#10;        event.onmessage = (event) =&gt;&#10;        {&#10;            const data = JSON.parse(event.data);&#10;&#10;            // Check if the operation was cancelled&#10;            if (data.status === &quot;cancelled&quot; &amp;&amp; on_cancelled)&#10;            {&#10;                on_cancelled();&#10;                return;&#10;            }&#10;&#10;            // Check if the operation completed successfully&#10;            if (data.status === &quot;complete&quot;)&#10;            {&#10;                on_success();&#10;                return;&#10;            }&#10;&#10;            // Check if there was an error&#10;            if (data.status === &quot;error&quot;)&#10;            {&#10;                on_error(data.error || &quot;Unknown error occurred during extraction&quot;);&#10;                return;&#10;            }&#10;&#10;            // Update progress&#10;            on_progress(data.progress || 0, data.filesProcessed || 0, data.totalFiles || 0);&#10;        };&#10;&#10;        event.onerror = () =&gt;&#10;        {&#10;            on_error(&quot;Connection closed unexpectedly&quot;);&#10;            event.close();&#10;        };&#10;&#10;        return {&#10;            cancel,&#10;            trackerId: id&#10;        };&#10;    }&#10;&#10;    static async cancelExtract(trackerId: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const response = await fetch(`/api/server/${serverId}/fs/extract/cancel/${trackerId}`, {&#10;            method: &quot;POST&quot;&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            const errorData = await response.json();&#10;            throw new Error(errorData.message || &quot;Failed to cancel extract operation&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Upload a file from a URL to the server&#10;     * @param url URL to download the file from&#10;     * @param filepath Path where the file should be saved (relative to server directory)&#10;     * @param serverId Server ID to target&#10;     * @param onProgress Callback for progress updates (progress: 0-1, downloaded: bytes, total: bytes)&#10;     * @param onSuccess Callback when upload completes successfully&#10;     * @param onError Callback when an error occurs&#10;     * @returns Promise that resolves when the upload starts (not when it completes)&#10;     */&#10;    static async uploadFromUrl(&#10;        url: string,&#10;        filepath: string,&#10;        serverId: string,&#10;        onProgress: (progress: number, downloaded: number, total: number) =&gt; void,&#10;        onSuccess: () =&gt; void,&#10;        onError: (error: string) =&gt; void&#10;    ): Promise&lt;void&gt;&#10;    {&#10;        return new Promise((resolve, reject) =&gt;&#10;        {&#10;            let isCompleted = false; // Add flag to prevent multiple completions&#10;&#10;            try&#10;            {&#10;                const uploadUrl = new URL(`/api/server/${serverId}/fs/upload-url`, window.location.origin);&#10;                uploadUrl.searchParams.set(&quot;url&quot;, url);&#10;                uploadUrl.searchParams.set(&quot;filepath&quot;, filepath);&#10;&#10;                const eventSource = new EventSource(uploadUrl.toString());&#10;&#10;                // Add error handler for connection issues&#10;                eventSource.onerror = (error) =&gt;&#10;                {&#10;                    if (!isCompleted)&#10;                    {&#10;                        console.error(&quot;EventSource connection error:&quot;, error);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Connection error during upload&quot;);&#10;                        reject(new Error(&quot;Connection error during upload&quot;));&#10;                    }&#10;                };&#10;&#10;                eventSource.onopen = () =&gt;&#10;                {&#10;                    console.log(&quot;Upload from URL started:&quot;, url);&#10;                    // Don't resolve here - wait for completion&#10;                };&#10;&#10;                eventSource.addEventListener(&quot;progress&quot;, (event: MessageEvent) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent processing after completion&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;&#10;                        if (data.progress !== undefined &amp;&amp; data.downloaded !== undefined &amp;&amp; data.total !== undefined)&#10;                        {&#10;                            onProgress(data.progress, data.downloaded, data.total);&#10;                        }&#10;                    } catch (e)&#10;                    {&#10;                        console.error(&quot;Error parsing progress data:&quot;, e);&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;error&quot;, (event: any) =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple error handling&#10;&#10;                    try&#10;                    {&#10;                        const data = JSON.parse(event.data);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(data.error || &quot;Unknown error occurred during upload from URL&quot;);&#10;                        reject(new Error(data.error || &quot;Unknown error occurred during upload from URL&quot;));&#10;                    } catch (parseError)&#10;                    {&#10;                        console.error(&quot;Error parsing error event data:&quot;, parseError);&#10;                        eventSource.close();&#10;                        isCompleted = true;&#10;                        onError(&quot;Failed to parse error response&quot;);&#10;                        reject(new Error(&quot;Failed to parse error response&quot;));&#10;                    }&#10;                });&#10;&#10;                eventSource.addEventListener(&quot;complete&quot;, () =&gt;&#10;                {&#10;                    if (isCompleted) return; // Prevent multiple completion handling&#10;                    &#10;                    console.log(&quot;Upload from URL completed:&quot;, url);&#10;                    eventSource.close();&#10;                    isCompleted = true;&#10;                    onSuccess();&#10;                    resolve(); // Only resolve when upload is actually complete&#10;                });&#10;&#10;            } catch (error: Error | any)&#10;            {&#10;                if (!isCompleted)&#10;                {&#10;                    isCompleted = true;&#10;                    onError(error.message || error.toString() || &quot;Failed to start upload from URL&quot;);&#10;                    reject(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    static async getFileContents(path: string, serverId: string): Promise&lt;string&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString());&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;&#10;        return await response.text();&#10;    }&#10;&#10;    static async setFileContents(path: string, content: string, serverId: string): Promise&lt;void&gt;&#10;    {&#10;        const url = new URL(`/api/server/${serverId}/fs/contents`, window.location.origin);&#10;        url.searchParams.set(&quot;filepath&quot;, path);&#10;        const response = await fetch(url.toString(), {&#10;            method: &quot;POST&quot;,&#10;            headers: {&#10;                &quot;Content-Type&quot;: &quot;text/plain&quot;&#10;            },&#10;            body: content&#10;        });&#10;&#10;        if (!response.ok)&#10;        {&#10;            let body = await response.text();&#10;            if (body)&#10;            {&#10;                throw new Error(body);&#10;            } else&#10;            {&#10;                throw new Error(`Error: ${response.status} - ${response.statusText}`);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>